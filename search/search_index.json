{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"cpp-on-macos/","title":"C/C++ on MacOS","text":"<p>Usually in MacOS, the default compiler is Clang. Even the <code>g++</code> command in the terminal is just a wrapper around Clang.</p> <p>Although Clang will work just fine for most of the time, sometimes it just misbehaves completely compared to GCC. Since online judges usually use GCC, it is a good idea to install GCC and tell rbx to use it.</p> <p>To use the GNU compiler, you need to install it separately.</p> <pre><code>brew install gcc\n</code></pre> <p>But, still after installing it, you need to tell rbx to use it. Find at the end of the <code>brew</code> command which version of <code>g++</code> was installed.</p> <p>For instance, if you see:</p> <pre><code>Installing gcc 14.2.0\n</code></pre> <p>This means that <code>g++-14</code> is probably available as a command to run in your terminal.</p> <p>To tell rbx to use it, you can run <code>rbx config edit</code> and add the following to the file (replace <code>g++-14</code> with whatever version you have installed):</p> <pre><code>command_substitutions:\n  g++: g++-14\n  gcc: gcc-14\n</code></pre> <p>This will tell rbx to use <code>gcc-14</code> and <code>g++-14</code> as the C and C++ compilers.</p> <p>A caveat to this is that GNU GCC sanitizers do not work on MacOS. If you need sanitizers in MacOS, you will need to tell rbx to fall back to Clang when sanitizing.</p> <pre><code>sanitizers:\n  command_substitutions:\n    g++: clang++\n    gcc: clang\n</code></pre>"},{"location":"stack-limit/","title":"Stack limit","text":"<p>When developing programming competition problems locally, it's often the case we hit the stack limit configured in our system.</p> <p>This is usually a problem because in modern online judges, the stack limit is configured to be as large as 256 MiB, but often the default configuration for Unix-like systems is way smaller than that.</p> <p>The disparity can usually cause some friction, because it's really hard to identify that a solution crashed because it exceeded the stack limit, and not because of some other reason. Thus, it's usually a good practice to increase the stack limit as much as possible to avoid the problem.</p> <p>You can check your current stack limit by running <code>ulimit -s</code> in your terminal. Also, you can check even more details about resource limits by running <code>sudo launchctl limit</code> on MacOS or <code>ulimit -a -S</code>/<code>ulimit -a -H</code> on Linux, which will show something like this:</p> <pre><code># Output of `ulimit -a` on Linux\n-t: cpu time (seconds)              unlimited\n-f: file size (blocks)              unlimited\n-d: data seg size (kbytes)          unlimited\n-s: stack size (kbytes)             8192\n-c: core file size (blocks)         0\n-v: address space (kbytes)          unlimited\n-l: locked-in-memory size (kbytes)  unlimited\n-u: processes                       2666\n-n: file descriptors                1048575\n</code></pre> <p>The values for <code>ulimit -a -S</code> indicates the soft limit -- in this example, 8 MiB --, and the values for <code>ulimit -a -H</code> indicates a hard limit. Usually, hard limits are a bit hard to configure, but soft limits can be easily increased to match the hard limit through the <code>ulimit</code> command.</p> <p>Note</p> <p>8 MiB is a really small and dangerous stack limit: it's not uncommon for a DFS with a handful of parameters in a big graph to exceed that limit. On the other hand, 64 MiB is usually enough for most problems.</p>"},{"location":"stack-limit/#increase-the-soft-stack-limit","title":"Increase the soft stack limit","text":"<p>To increase the stack limit to the maximum allowed (which will match the hard limit), you can run:</p> <pre><code>ulimit -s unlimited\n</code></pre> <p>To ensure you're not bitten by this issue so easily, rbx will complain if you try to run code while your soft stack limit is less than your hard stack limit.</p> <p>Do not worry, the fix -- which consists of adding some lines to your <code>.bashrc</code> (or the equivalent for other shells) -- is really simple and will be shown along the error message.</p> <p>Tip</p> <p>You should ensure the lines added to the file are definitely after the lines where <code>uv</code> and <code>pipx</code> paths are added to <code>$PATH$</code>, otherwise the <code>rbx</code> command will not be found.</p>"},{"location":"stack-limit/#increase-the-hard-stack-limit","title":"Increase the hard stack limit","text":"<p>Sometimes, the hard stack limit is also too small. In this case, you can increase the hard stack limit in different ways depending on your system.</p>"},{"location":"stack-limit/#on-linux","title":"On Linux","text":"<p>Open <code>/etc/security/limits.conf</code> and add the following lines:</p> <pre><code>* stack soft &lt;soft_limit_in_bytes&gt;\n* stack hard &lt;hard_limit_in_bytes&gt;\n</code></pre> <p>This configuration should persist after a reboot.</p>"},{"location":"stack-limit/#on-macos","title":"On MacOS","text":"<p>Run the following command in your terminal:</p> <pre><code>sudo launchctl limit stack &lt;soft_limit_in_bytes&gt; &lt;hard_limit_in_bytes&gt;\n</code></pre> <p>This configuration will NOT persist after a reboot, but will persist across terminals.</p>"},{"location":"intro/installation/","title":"Installation","text":"<p>You can install rbx with a single command, either using <code>pip</code>, <code>pipx</code> or <code>uv</code>. Prefer using <code>uv</code> or <code>pipx</code> to have a better isolation between the dependencies. Read more about how to install and use <code>uv</code> here.</p>"},{"location":"intro/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.9.1 or above (stable with Python 3.10).</li> <li>A C++ toolchain to compile testlib libraries (usually <code>g++</code>).</li> <li>(Optional):<ul> <li>Compilers/interpreters that you need to run your solutions on (e.g. <code>g++</code>, <code>java</code>).</li> <li>pdfLaTeX and other additional packages to convert TeX files into PDF (see https://www.latex-project.org/get/)</li> </ul> </li> </ul>"},{"location":"intro/installation/#from-pypi","title":"From PyPI","text":"<pre><code>$ uv tool install rbx.cp\n</code></pre>"},{"location":"intro/installation/#from-the-repository","title":"From the repository","text":"<pre><code>$ git clone https://github.com/rsalesc/rbx\n$ cd rbx\n$ uv tool install .\n</code></pre>"},{"location":"intro/installation/#verify-installation","title":"Verify installation","text":"rbx --help# rbx help string should show up here"},{"location":"intro/installation/#a-note-for-windows-users","title":"A note for Windows users","text":"<p>rbx is not supported on Windows. One of the main reasons (but not the only one) is that rbx heavily uses symlinks, which is inherently a POSIX feature, and even though it's been implemented in Windows recently, it's not yet perfectly supported.</p> <p>If you want to use rbx on Windows, you can do so by using the WSL (Windows Subsystem for Linux). Also, you'll have to make sure your packages are cloned within the WSL instance and filesystem. Cloning on a Windows folder and mounting it into the WSL instance will not work since symlinks will not be preserved.</p> <p>Proceed to the First Steps section.</p>"},{"location":"intro/overview/","title":"Overview","text":""},{"location":"intro/overview/#introduction","title":"Introduction","text":"<p>Quick walkthroughs to get you started with rbx.</p> <ul> <li> <p> Get rbx running in a minute</p> <p>Install rbx with <code>uv</code> on Linux or macOS.</p> <p> Installation</p> </li> <li> <p> Edit a sample problem</p> <p>Start from a simple example problem and learn the basics of rbx.</p> <p> First steps</p> </li> </ul>"},{"location":"intro/overview/#feature-guide","title":"Feature Guide","text":"<p>Learn how to use the different features of rbx.</p> <ul> <li> <p> Build your own testset</p> <p>Learn how to set samples, use generators and stress tests.</p> <p> Testset</p> </li> <li> <p> Define your constraints</p> <p>Define variables and use them in validators, checkers and even in your statements.</p> <p> Variables</p> </li> <li> <p> Verify your problem</p> <p>Ensure the correctness of your problem with validators and unit tests.</p> <p> Verification</p> </li> <li> <p> Run your solutions</p> <p>Run your solutions and verify whether they're given the expected verdict or not.</p> <p> Running</p> </li> <li> <p> Grade with custom checkers</p> <p>Learn how to write a custom checker for a problem.</p> <p> Checkers</p> </li> <li> <p> Write an interactive problem</p> <p>Learn how to write an interactive problem from scratch.</p> <p> Interactors</p> </li> <li> <p> Write, format and translate</p> <p>Learn how to write multiple statements and build them.</p> <p>  Statements</p> </li> <li> <p> Package and ship</p> <p>Build, package and ship your problem to competitive programming platforms.</p> <p> Packaging</p> </li> </ul>"},{"location":"intro/overview/#reference","title":"Reference","text":"<p>Reference documentation for rbx.</p> <ul> <li> <p> Cheatsheet</p> <p>A one stop shop for all the commands and options available in rbx.</p> <p> Cheatsheet</p> </li> <li> <p> Problem configuration</p> <p>A summary of all the configuration options available in <code>problem.rbx.yml</code>.</p> <p> <code>problem.rbx.yml</code> </p> </li> </ul>"},{"location":"setters/cheatsheet/","title":"Cheatsheet","text":""},{"location":"setters/cheatsheet/#cli","title":"CLI","text":"<p>Below you can find a list of common rbx commands. You can read more about each of them in the CLI reference.</p> Task Command Show help message <code>rbx --help</code> Open rbx configuration for editing <code>rbx config edit</code> Create a new package in folder <code>package</code> <code>rbx create</code> Compile a file given its path <code>rbx compile my/file.cpp</code> Open the problem configuration in a text editor <code>rbx edit</code> Generate all testcases <code>rbx build</code> Use dynamic timing to estimate time limits <code>rbx time</code> Run all solutions and check their tags <code>rbx run</code> Run all solutions with sanitizer <code>rbx run -s</code> Run all solutions with dynamic timing <code>rbx run -t</code> Run all solutions except the slow ones <code>rbx run -v2</code> Run all solutions without checking <code>rbx run --nocheck</code> Run a single solution <code>rbx run sols/my-solution.cpp</code> Choose solutions and run <code>rbx run -c</code> Run all solutions interactively <code>rbx irun</code> Choose solutions and run interactively <code>rbx irun -c</code> Run solutions in a single testcase <code>rbx irun -t samples/0</code> Run solutions in a generator testcase <code>rbx irun -g gen 5 10</code> Interactively visualize outputs of a recent run <code>rbx ui</code> Run the validator interactively <code>rbx validate</code> Run a stress test with name <code>break</code> <code>rbx stress break</code> Run a stress test for a generator <code>rbx stress gen -g \"[1..10]\" -f \"[sols/main.cpp ~ INCORRECT]\"</code> Run unit tests for validator and checker <code>rbx unit</code> Download testlib to the current folder <code>rbx download testlib</code> Download jngen to the current folder <code>rbx download jngen</code> Download a built-in testlib checker <code>rbx download checker wcmp.cpp</code> Build all statements <code>rbx statements build</code> Build a specific statement <code>rbx statements build &lt;name&gt;</code> Build statements for English <code>rbx statements build -l en</code> Package problem for Polygon <code>rbx package polygon</code> Package problem for BOCA <code>rbx package boca</code> Package problem for BOCA but only validate <code>rbx package boca -v1</code> List all languages available in the environment <code>rbx languages</code> Format all YAML configuration files in the package <code>rbx fix</code> Clear cache <code>rbx clear</code>"},{"location":"setters/cheatsheet/#contest-cli","title":"Contest CLI","text":"Task Command Show help message <code>rbx contest --help</code> Create a new contest <code>rbx contest create</code> Add a new problem to the contest with letter A <code>rbx contest add</code> Remove a problem from the contest <code>rbx contest remove A</code> Remove a problem at a certain path <code>rbx contest remove path/to/problem</code> Open the contest configuration in a text editor <code>rbx contest edit</code> Build all statements <code>rbx contest statements build</code> Build a specific statement <code>rbx contest statements build &lt;name&gt;</code> Build statements for English <code>rbx contest statements build en</code> Package contest for Polygon <code>rbx contest package polygon</code> Build each problem in the contest <code>rbx contest each build</code> Package each problem in the contest <code>rbx contest each package boca</code> Build problem A in the contest <code>rbx contest on A build</code> Build problems A to C in the contest <code>rbx contest on A-C build</code>"},{"location":"setters/cheatsheet/#problemrbxyml","title":"<code>problem.rbx.yml</code>","text":""},{"location":"setters/cheatsheet/#change-problem-constraints","title":"Change problem constraints","text":"<pre><code>timeLimit: 1000  # In milliseconds\nmemoryLimit: 256  # In megabytes\nmodifiers:\n  java:\n    time: 5000  # Override time for Java\n</code></pre>"},{"location":"setters/cheatsheet/#add-testlib-assets","title":"Add testlib assets","text":""},{"location":"setters/cheatsheet/#set-a-built-in-testlib-checker","title":"Set a built-in testlib checker","text":"<pre><code>rbx download checker yesno.cpp\n</code></pre> <pre><code>checker:\n  path: \"yesno.cpp\"\n</code></pre> <p>Tip</p> <p>Find here a full list of existing built-in testlib checkers.</p>"},{"location":"setters/cheatsheet/#set-a-custom-checker","title":"Set a custom checker","text":"<pre><code>checker:\n  path: \"my-checker.cpp\"\n</code></pre> <p>See here how to write a custom testlib checker.</p>"},{"location":"setters/cheatsheet/#add-a-generator","title":"Add a generator","text":"<p>Add a new generator entry to the <code>generators</code> field.</p> <pre><code>generators:\n  # ...other generators\n  - name: \"my-gen\"\n    path: \"my-gen.cpp\"\n</code></pre> <p>See here how to write a testlib-based generator.</p> <p>Tip</p> <p>To actually generate tests with this new generator, you have to add testcase groups and call the generator.</p>"},{"location":"setters/cheatsheet/#set-a-validator","title":"Set a validator","text":"<pre><code>validator:\n  path: 'my-validator.cpp`\n</code></pre> <p>See here how to write a testlib-based validator.</p>"},{"location":"setters/cheatsheet/#set-an-interactor","title":"Set an interactor","text":"<pre><code>interactor:\n  path: 'my-interactor.cpp'\n</code></pre> <p>See here how to write a testlib-based interactor.</p>"},{"location":"setters/cheatsheet/#add-a-new-solution","title":"Add a new solution","text":"<p>Implement your solution (for instance, a wrong solution in <code>sols/my-wa-solution.cpp</code>) and add it to the <code>solutions</code> field.</p> <pre><code>solutions:\n  - path: 'sols/my-wa-solution.cpp'\n    outcome: WRONG_ANSWER\n</code></pre> <p>You can see the list of possible expected outcomes here.</p>"},{"location":"setters/cheatsheet/#add-testcases","title":"Add testcases","text":""},{"location":"setters/cheatsheet/#add-a-testcase-group-with-manually-defined-tests","title":"Add a testcase group with manually defined tests","text":"<pre><code>testcases:\n  # ...other testcase groups\n  - name: \"manual-tests\"\n    testcaseGlob: \"tests/manual/*.in\" # (1)!\n</code></pre> <ol> <li> <p>Import all tests in the <code>tests/manual/</code> folder in lexicographic order.</p> <p>The test input files must end in <code>.in</code>.</p> </li> </ol>"},{"location":"setters/cheatsheet/#add-a-testcase-group-with-a-list-of-generated-tests","title":"Add a testcase group with a list of generated tests","text":"<pre><code>testcases:\n  # ...other testcase groups\n  - name: \"single-generated\"\n    generators:\n      - name: \"gen\"\n        args: \"1000 123\" # (1)!\n      - name: \"gen\"\n        args: \"1000 456\" # (2)!\n</code></pre> <ol> <li>A generated test obtained from the output of the command <code>gen 1000 123</code>.</li> <li>A generated test obtained from the output of the command <code>gen 1000 456</code>.</li> </ol>"},{"location":"setters/cheatsheet/#add-a-testcase-group-with-a-list-of-generated-tests-from-a-generator-script","title":"Add a testcase group with a list of generated tests from a generator script","text":"problem.rbx.ymlscript.txt <pre><code>testcases:\n  # ...other testcase groups\n   - name: \"generated-from-text-script\"\n     generatorScript:\n        path: \"script.txt\"\n</code></pre> <pre><code>gen 1000 123\ngen 1000 456\ngen 1000 789\n# other tests...\n</code></pre>"},{"location":"setters/cheatsheet/#add-a-testcase-group-with-a-list-of-generated-tests-from-a-dynamic-generator-script","title":"Add a testcase group with a list of generated tests from a dynamic generator script","text":"problem.rbx.ymlscript.py <pre><code>testcases:\n  # ...other testcase groups\n   - name: \"generated-from-program-script\"\n     generatorScript:\n        path: \"script.py\"\n</code></pre> <pre><code>for i in range(50):\n  print(f'gen 1000 {i}') # (1)!\n</code></pre> <ol> <li>Generates 50 random tests.</li> </ol>"},{"location":"setters/cheatsheet/#add-testgroup-specific-validator","title":"Add testgroup-specific validator","text":"<pre><code>validator:\n  path: \"my-validator.cpp\"\ntestcases:\n  - name: \"small-group\"\n    # Define tests...\n    validator:\n      path: \"my-small-validator.cpp\" # (1)!\n  - name: \"large-group\"\n    # Define tests...\n</code></pre> <ol> <li>Add a specific validator to verify constraints of a smaller sub-task of the problem.</li> </ol>"},{"location":"setters/cheatsheet/#add-variables","title":"Add variables","text":"<p>The variables below can be reused across validators and statements.</p> <pre><code>vars:\n  N:\n    min: 1\n    max: 1000\n  V:\n    max: 100000\n  MOD: py`10**9+7` # Backticks force the var to be evaluated as a Python expression.\n</code></pre>"},{"location":"setters/cheatsheet/#use-variables","title":"Use variables","text":"In testlib componentsIn statements <pre><code>#include \"rbx.h\"\n\nint32_t main() {\n  registerValidation(argc, argv);\n\n  int MIN_N = getVar&lt;int&gt;(\"N.min\"); // Read from package vars.\n  int MAX_N = getVar&lt;int&gt;(\"N.max\"); // Read from package vars.\n\n  // Rest of the validator\n}\n</code></pre> <pre><code>The maximum value of N is \\VAR{vars.N.max | sci} % (1)!\n</code></pre> <ol> <li>If <code>N.max</code> has lots of trailing zeroes, <code>sci</code> converts it to scientific notation.</li> </ol>"},{"location":"setters/cheatsheet/#add-statements","title":"Add statements","text":""},{"location":"setters/cheatsheet/#add-a-rbxtex-statement","title":"Add a rbxTeX statement","text":"<pre><code>statements:\n  # ...other statements\n  - name: 'statement-en'\n    title: \"My problem\"\n    path: \"statement/statement.rbx.tex\" # (1)!\n    type: rbxTeX\n    language: 'en'\n    configure:\n      - type: 'rbx-tex'\n        template: statement/template.rbx.tex' # (2)!\n    assets: ['statement/olymp.sty', 'statement/*.png'] # (3)!\n</code></pre> <ol> <li> <p>Defines the path to the rbxTeX file, where the building blocks of the statement    will be defined.</p> </li> <li> <p>Defines how a rbxTeX file will be converted to a normal TeX file. Here, we link      the template where our rbxTeX sections such as legend, input and output      will be inserted into.</p> </li> <li> <p>Defines assets that should be linked when the resulting statement is being compiled.</p> </li> </ol>"},{"location":"setters/cheatsheet/#extends-other-rbxtex-statements","title":"Extends other rbxTeX statements","text":"<pre><code>statements:\n  - name: 'statement'\n    title: 'My problem'\n    path: \"statement/statement.rbx.tex\"\n    type: rbxTeX\n    language: 'en'\n    configure:\n      - type: 'rbx-tex'\n        template: statement/template.rbx.tex'\n    assets: ['statement/olymp.sty', 'statement/*.png']\n  - name: 'statement-pt'\n    title: 'Meu problema'\n    extends: 'statement' # (1)!\n    language: 'pt'\n    path: 'statement/statement-pt.rbx.tex' # (2)!\n</code></pre> <ol> <li> <p>The <code>statement-pt</code> statement will inherit the properties of the <code>statement</code> statement, and override a subset of them.</p> </li> <li> <p>The <code>statement-pt</code> statement will use a different rbxTeX file, since we need to rewrite the building blocks    of the statement in another language.</p> </li> </ol>"},{"location":"setters/cheatsheet/#add-a-pdf-statement","title":"Add a PDF statement","text":"<pre><code>statements:\n  # ...other statements\n  - title: \"My problem\"\n    path: \"statement/statement.pdf\"\n    type: PDF\n    language: 'en'\n</code></pre>"},{"location":"setters/cheatsheet/#add-a-stress-test","title":"Add a stress test","text":""},{"location":"setters/cheatsheet/#add-a-stress-to-look-for-an-error-in-a-solution","title":"Add a stress to look for an error in a solution","text":"<pre><code>stresses:\n  - name: \"my-stress\"\n    generator:\n      name: 'gen'\n      args: '[1..&lt;N.max&gt;] @' # (1)!\n    finder: \"[sols/my-wa-solution.cpp] ~ INCORRECT\" # (2)!\n</code></pre> <ol> <li> <p>The <code>&lt;N.max&gt;</code> variable expands into the <code>vars.N.max</code> value that could be declared in     <code>problem.rbx.yml</code>.</p> <p>The <code>[1..&lt;N.max&gt;]</code> picks a random number in this interval before generating every test in the stress run.</p> <p>The <code>@</code> appends a few extra random characters to the end of the generator call to re-seed the generator.</p> </li> <li> <p>Expression that refers to solution <code>sols/my-wa-solution.cpp</code> and check whether it returns an incorrect outcome.</p> </li> </ol>"},{"location":"setters/cheatsheet/#add-a-stress-to-look-for-a-test-that-causes-tle-in-a-solution","title":"Add a stress to look for a test that causes TLE in a solution","text":"<pre><code>stresses:\n  - name: \"my-stress\"\n    generator:\n      name: 'gen'\n      args: '1000000 @' # (1)!\n    finder: \"[sols/my-potentially-slow-sol.cpp] ~ TLE\"\n</code></pre> <ol> <li>The <code>@</code> at the end of the <code>args</code> string appends a random string to it. This is necessary here because <code>gen 100000</code> would return the same testcase over and over, since testlib rng is seeded from its command line argc and argv.</li> </ol>"},{"location":"setters/cheatsheet/#add-unit-tests","title":"Add unit tests","text":"<pre><code>unitTests:\n  validator:\n    - glob: \"unit/validator/valid_*.in\"  # (1)!\n      outcome: VALID\n    - glob: \"unit/validator/invalid_*.in\"\n      outcome: INVALID\n  checker:\n    - glob: \"unit/checker/ac*\"  # (2)!\n      outcome: ACCEPTED\n    - glob: \"unit/checker/wa*\"\n      outcome: WRONG_ANSWER\n    # ...other checker unit tests\n</code></pre> <ol> <li> <p>Matches <code>.in</code> files relative to the problem root directory that when validated should be considered valid.</p> </li> <li> <p>Matches <code>.in</code>, <code>.out</code>, <code>.ans</code> files that when checked should be considered ACCEPTED.</p> </li> </ol>"},{"location":"setters/cheatsheet/#contestrbxyml","title":"<code>contest.rbx.yml</code>","text":""},{"location":"setters/cheatsheet/#add-a-new-problem","title":"Add a new problem","text":"<pre><code>problems:\n  - short_name: \"A\"  # Letter of the problem\n    path: \"problem_folder\"\n    color: \"ff0000\"  # Optional\n</code></pre>"},{"location":"setters/first-steps/","title":"First steps","text":"<p><code>rbx</code> is the CLI tool rbx provides for setters to prepare contests and problems.</p> <p>This document focus on a very specific and simple user journey to highlight the most common features of rbx. Feel free to explore the rest of the documentation on the sidebar to get more information about the other features.</p> <p>We'll focus on how to create a problem from a pre-initialized preset, how to write its main components and how to test it.</p> <p>You can start creating a new problem from a pre-initialized preset by running <code>rbx create</code>.</p> rbx create# This will prompt you for the name of the problem, and then create a new problem# in a folder with that name. <p>This is how the directory structure of the pre-initialized problem preset will look like:</p> <pre><code>test\n\u251c\u2500\u2500 sols  # (1)!\n\u2502   \u251c\u2500\u2500 main.cpp\n\u2502   \u251c\u2500\u2500 slow.cpp\n\u2502   \u2514\u2500\u2500 wa.cpp\n\u251c\u2500\u2500 statement  # (2)!\n\u2502   \u251c\u2500\u2500 olymp.sty\n\u2502   \u251c\u2500\u2500 projecao.png\n\u2502   \u251c\u2500\u2500 statement.rbx.tex\n\u2502   \u2514\u2500\u2500 template.rbx.tex\n\u251c\u2500\u2500 tests  # (3)!\n\u2502   \u2514\u2500\u2500 samples\n\u2502       \u251c\u2500\u2500 000.in\n\u2502       \u2514\u2500\u2500 001.in\n\u251c\u2500\u2500 gen.cpp # (4)!\n\u251c\u2500\u2500 problem.rbx.yml # (5)!\n\u251c\u2500\u2500 random.txt # (6)!\n\u251c\u2500\u2500 random.py # (7)!\n\u251c\u2500\u2500 validator.cpp # (8)!\n\u2514\u2500\u2500 wcmp.cpp # (9)!\n</code></pre> <ol> <li>All solutions for the problem: the correct and the incorrect ones.</li> <li>All statement-related assets, including the legend of the problem itself     but also the tex templates and imported graphics.</li> <li> <p>Manually defined tests of the problem.</p> <p>Note</p> <p>Automatically generated tests are not defined by explicit input and output files, but are rather defined by generator entries in the problem configuration.</p> </li> <li> <p>An example of a testlib generator. In this case, the generator is used to     generate testcases for two testgroups: <code>random</code> and <code>program-random</code>.</p> <p>Note</p> <p>A problem can have multiple generators. This one is just an example.</p> </li> <li> <p>The YAML configuration file for this problem.</p> </li> <li> <p>A generator script for the problem.</p> <p>Each line of a generator script describes one call to a generator, and a generator script groups all these calls together.</p> <p>Example:</p> <pre><code>gen 123\ngen 456\n</code></pre> <p>Calls the generator named <code>gen</code> (here in this problem, implemented through <code>gen.cpp</code>) twice, thus generating two testcases.</p> <p>In this problem, this script is used to generate the testcase group <code>random</code>.</p> </li> <li> <p>A program that outputs a generator script. Pretty similar to <code>random.txt</code>     above, except that this is a program that prints to the stdout a     generator script, and thus provides more flexibility to the setter.</p> <p>Example:</p> <pre><code>#! /usr/bin/python3\nfor i in range(10):\n    print(f'gen {i}')\n</code></pre> <p>This program outputs a generator script that creates 10 testcases with increasing parameter <code>i</code>.</p> <p>In this problem, this program is used to generate the testcase group <code>program-random</code>.</p> </li> <li> <p>A testlib validator that checks whether the generated tests are     in the correct format.</p> </li> <li> <p>A built-in testlib checker that compares tokens of the participant's output     and the judge's output.</p> </li> </ol>"},{"location":"setters/first-steps/#build","title":"Build","text":"<p>Let's skip the configuration of the problem for a second, and just build and run it. You can build a problem with <code>rbx build</code>. This will populate a <code>build</code> folder inside your problem's folder with all the testcases generated for the problem.</p> <pre><code>$ rbx build\n$ ls build\nbuild\n\u2502   \u2514\u2500\u2500 tests\n\u2502       \u251c\u2500\u2500 program-random\n\u2502       \u2502   \u2514\u2500\u2500 ...\n\u2502       \u251c\u2500\u2500 random\n\u2502       \u2502   \u2514\u2500\u2500 ...\n\u2502       \u2514\u2500\u2500 samples\n\u2502           \u2514\u2500\u2500 ...\n</code></pre> <p>You can notice it created several folders inside a <code>tests</code> directory, each of which contains the tests for a specific testgroup. For this preset in particular, we have three testsets: <code>random</code>, <code>program-random</code> and <code>samples</code>.</p> <p>If you want, you can explore these folders manually, but rbx also provides a TUI (terminal UI) to explore the testcases. You can run <code>rbx ui</code> and select the first option to explore the built testcases.</p>"},{"location":"setters/first-steps/#run","title":"Run","text":"<p>Now, let's execute <code>rbx run</code>. This command builds all testcases and executes each solution against them, evaluating whether each solution had the expected outcome.</p> <pre><code>$ rbx run\n</code></pre> <p>You can see this command prints a full run report: it shows for each testcase of each testgroup whether a certain solution passed or not. There are also links for the outputs of each problem.</p> <p>Tip</p> <p>You can notice when you call <code>rbx run</code> again, the testcases were built really fast. That's because rbx caches certain calls based on the hash tree of your package (similar to Makefile). You can explicitly clear this cache by calling <code>rbx clean</code>.</p>"},{"location":"setters/first-steps/#modifying-the-package","title":"Modifying the package","text":"<p>As you can see from the solutions and the statement, the pre-initialized preset simply implements a problem where you have to add up two numbers <code>A</code> and <code>B</code>. Let's modify the problem to compute the sum of N numbers.</p>"},{"location":"setters/first-steps/#rewrite-solutions","title":"Rewrite solutions","text":"<p>Let's start rewriting the solutions. We can probably drop the slow solution since we're just naively summing numbers anyway.</p> <p>We can develop the following accepted and wrong answer solutions.</p> sols/main.cppsols/wa.cpp <pre><code>#include &lt;bits/stdc++.h&gt;\n\nint32_t main() {\n    int n;\n    cin &gt;&gt; n;\n\n    int64_t ans = 0;\n    for(int i = 0; i &lt; n; i++) {\n        int x;\n        cin &gt;&gt; x;\n        ans += x;\n    }\n\n    cout &lt;&lt; ans &lt;&lt; endl;\n}\n</code></pre> <pre><code>#include &lt;bits/stdc++.h&gt;\n\nint32_t main() {\n    int n;\n    cin &gt;&gt; n;\n\n    int32_t ans = 0; // int32 overflows!!\n    for(int i = 0; i &lt; n; i++) {\n        int x;\n        cin &gt;&gt; x;\n        ans += x;\n    }\n\n    cout &lt;&lt; ans &lt;&lt; endl;\n}\n</code></pre> <p>To delete the <code>slow.cpp</code> solution from our package, we can just delete the file and the reference to it in <code>problem.rbx.yml</code>. The reference is located in the <code>solutions</code> section, which will look like this after the deletion:</p> <pre><code>solutions:\n  - path: 'sols/main.cpp'\n    outcome: ACCEPTED\n  - path: 'sols/wa.cpp'\n    outcome: WRONG_ANSWER\n</code></pre> <p>You can find the full list of expected outcomes here.</p>"},{"location":"setters/first-steps/#write-the-validator","title":"Write the validator","text":"<p>The testlib validator is implemented by <code>validator.cpp</code> and will look like this:</p> validator.cpp <pre><code>#include \"testlib.h\"\n#include \"rbx.h\"\n\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n\n    int MAX_N = getVar&lt;int&gt;(\"N.max\"); // (1)!\n    int MAX_A = getVar&lt;int&gt;(\"A.max\");\n\n    for (int i = 0; i &lt; n; i++) {\n        if (i) inf.readSpace();\n        inf.readInt(1, MAX_A, \"A_i\");\n    }\n    inf.readEoln();\n    inf.readEof();\n}\n</code></pre> <ol> <li><code>N.max</code> is a variable defined in <code>problem.rbx.yaml</code> that is accessible     in the validator. It allows you to change the constraints of the problem,     and instantly replicate the change in validators and statements.</li> </ol>"},{"location":"setters/first-steps/#generating-random-testcases","title":"Generating random testcases","text":"<p>Now, let's rewrite our random generator to generate <code>N</code> numbers instead of only two.</p> <p>We have to actually call this generator and generate testcases into some of the testgroups.</p> <p>Let's delete the existing test groups in <code>problem.rbx.yml</code>, except for the <code>samples</code> one, and create a new <code>main_tests</code> group. Let's generate 10 random tests for this group by using a generator script. We can either use a static generator script (represented in the example below as <code>random.txt</code>) or a dynamic generator script (represented in the example below as <code>random.py</code>).</p> gen.cpprandom.txt (static)random.py (dynamic)problem.rbx.yml <pre><code>#include \"testlib.h\"\n\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerGen(argc, argv, 1); // (1)!\n\n    int n = rnd.next(1, opt&lt;int&gt;(1));\n\n    for (int i = 0; i &lt; n; i++) {\n        if (i) cout &lt;&lt; \" \";\n        cout &lt;&lt; rnd.next(1, opt&lt;int&gt;(2));\n    }\n    cout &lt;&lt; endl;\n}\n</code></pre> <ol> <li>The generator now receive two parameters <code>N.max</code> (accessed through <code>opt&lt;int&gt;(1)</code>) and <code>A.max</code> (accessed through <code>opt&lt;int&gt;(2)</code>).</li> </ol> <pre><code>gen 1000 1000000000 1\ngen 1000 1000000000 2\ngen 1000 1000000000 3\ngen 1000 1000000000 4\ngen 1000 1000000000 5\ngen 1000 1000000000 6\ngen 1000 1000000000 7\ngen 1000 1000000000 8\ngen 1000 1000000000 9\ngen 1000 1000000000 10\n</code></pre> <pre><code>for i in range(10):\n    print(f'gen 1000 1000000000 {i}') # (1)!\n</code></pre> <ol> <li> <p>This line defines 10 random calls to the generator <code>gen</code>,      which will in turn generate testcases with <code>N</code> randomly varying     from 1 to 1000 and the numbers to be added varying from 1 to <code>1e9</code>.</p> <p>Tip</p> <p>Notice the trailing <code>{i}</code> being printed in every generator script line. That's because testlib rng seed is initialized from the <code>argv</code> given to the generator.</p> <p>Thus generators are reproducible: if we called <code>gen 1000 1000000000</code> 10 times, we would always get the same result. By appending an extra variable <code>{i}</code>, we introduce randomness to the tests.</p> </li> </ol> <pre><code># Testcases section would look like:\n\ntestcases:\n- name: 'samples'\n    testcaseGlob: 'tests/samples/*.in'\n- name: 'main_tests'  # (1)!\n    generatorScript:\n        path: 'random.txt'  # or 'random.py', in case you want to use a dynamic generator\n</code></pre> <ol> <li>Here, <code>main_tests</code> would contain the 10 tests defined in <code>random.txt</code> or <code>random.py</code>.</li> </ol> <p>Our newly defined generator <code>gen.cpp</code> will receive two positional arguments, <code>N</code> and <code>A</code>, and generate a list of <code>N</code> integers, each of which is at most <code>A</code>.</p> <p>Then, our generator script will can this generator 10 times to generate 10 different tests with <code>N</code> integers ranging from 1 to <code>A</code>.</p> <p>Now, if we run <code>rbx build</code>, we'd get our brand new generated tests.</p>"},{"location":"setters/first-steps/#update-the-statement","title":"Update the statement","text":"<p>Of course, last but not least, we have to update the statement of our problem. rbx has its own statement format, called rbxTeX. The format itself is simple, but the ecosystem behind it is complex and provides a lot of flexibility for setters.</p> <p>For now, you just need to know the body and meat of the statement is written at <code>statement/statement.rbx.tex</code>. If you open it, you will find something like the following:</p> statement/statement.rbx.tex <pre><code>%- block legend\nGiven two integers $A$ and $B$, determine the value of $A + B$.\n%- endblock\n\n%- block input\nThe input is a single line containing two integers $A$ and $B$\n($1 \\leq A, B \\leq \\VAR{vars.N.max | sci}$). % (1)!\n%- endblock\n\n%- block output\nThe output must contain only one integer, the sum of $A$ and $B$.\n%- endblock\n\n%- block notes\nNo notes.\n%- endblock\n</code></pre> <ol> <li> <p>Notice the use of <code>\\VAR</code> here, which is a command rbxTeX exposes for     you to access variables defined in <code>problem.rbx.yml</code>, similar to how you     accessed these in the testlib validator.</p> <p>The template engine used to expand <code>\\VAR{...}</code> is Jinja2. This means we can also use filters. Here in particular, we're using a pre-defined filter implemented by rbxTeX called <code>sci</code>. This filter converts numbers with lots of zeroes (for instance, 100000), into their scientific notations (<code>10^5</code>).</p> </li> </ol> <p>As you can see, similar to Polygon, you write a few blocks of LaTeX. Here, the <code>%-</code> delimits those pre-defined blocks. Your statement needs at least a legend, an input and an output. When the time comes to build this statement, these blocks will be pieced together to form the final statement.</p> <p>Let's change each corresponding block to match our new problem description.</p> statement/statement.rbx.tex <pre><code>%- block legend\nGiven $N$ integers, print their sum.\n%- endblock\n\n%- block input\nThe input has a single line containing $N$ \n($1 \\leq N \\leq \\VAR{vars.N.max | sci}$) numbers. \nThese numbers range from 1 to $\\VAR{vars.A.max | sci}$.\n%- endblock\n\n%- block output\nPrint the sum of the integers.\n%- endblock\n\n%- block notes\nNo notes.\n%- endblock\n</code></pre>"},{"location":"setters/first-steps/#next-steps","title":"Next steps","text":"<p>If you want to customize the problem even more, you can continue reading our Reference section on the sidebar.</p> <ul> <li> <p> Add a custom checker</p> <p>Want to grade solutions without comparing tokens? Check out our guide on how to add a custom checker.</p> <p> Checkers</p> </li> <li> <p> Package and ship your problem</p> <p>Want to package your problem for a judge? Check out our guide on how to package your problem.</p> <p> Packaging</p> </li> <li> <p> Stress test</p> <p>Want to generate stronger testcases? Check out our guide on how to stress test your solutions.</p> <p> Stress testing</p> </li> <li> <p> Configure further</p> <p>Want to learn all you can do in <code>problem.rbx.yml</code>? Check out our reference on how to configure your problem.</p> <p> <code>problem.rbx.yml</code></p> </li> </ul>"},{"location":"setters/statements/","title":"Macro Syntax Error","text":"<p>File: <code>setters/statements.md</code></p> <p>Line 110 in Markdown file: expected token ':', got '}' <pre><code>\\section{{{ problem.title }}}\n</code></pre></p>"},{"location":"setters/stress-testing/","title":"Stress testing","text":"<p>Stress testing is a technique used to verify the correctness of a solution by generating random inputs and checking if the solution behaves as expected.</p> <p>Although the technique is often employed to prove (or disprove) the correctness of a solution, it's also often used to find tests that break a known incorrect solution.</p> <p>Thus, it can be used both as a problem verification tool, but also as a testset construction tool. In this section, we'll go through the process of writing and running a stress test, and how to use this tool to improve our testset or the confidence in our solutions.</p>"},{"location":"setters/stress-testing/#defining-a-stress-test","title":"Defining a stress test","text":"<p>If you haven't read the Generators section yet, please do so before continuing as generators are an essential part of the stress testing framework.</p> <p>To run a stress test, we must define two expressions:</p> <ul> <li>A generator expression: a string in a special format that describes how to generate an   infinite random sequence of generator calls;</li> <li>A finder expression: a string in a special format that describes a condition for a testcase   to be considered a match for the stress test.</li> </ul>"},{"location":"setters/stress-testing/#generator-expression","title":"Generator expression","text":"<p>The generator expression is a special variation of a generator call. In fact, a generator call is a valid generator expression. Below, there are a few examples of valid generator expressions for a hypothetical generator named <code>gen</code> that generates a random integer between 1 and <code>N</code>, where <code>N</code> is a value passed on the generator call <code>gen N</code>.</p> <pre><code># A valid generator expression, but not super useful for a stress test.\n# Since generators are idempotent, the testcases will always have the same number.\ngen 100\n\n# The `@` operator is replaced by a random 8-character string when evaluated.\n# This will produce a different testcase each time, containing a random integer between 1 and 100.\ngen 100 @\n\n# Generates a number N between 1 and 100, and then generate a number between 1 and N.\ngen [1..100] @\n\n# Generates a number between 1 and N.max, where N.max is a variable defined for the problem.\ngen &lt;N.max&gt; @\n</code></pre> <p>Thus, a generator expression supports a set of operators and, when evaluated, produces a generator call. This generator call is used to produce a testcase for the stress test.</p> <p>In the table below, you can see the supported operators and their semantics.</p> <p>Operator</p> <p>Description</p> <p>Example</p> <p><code>@</code></p> <p>Random 8-char string</p> <p><code>gen 100 @</code></p> <p><code>&lt;var&gt;</code></p> <p>Variable defined for the problem</p> <p><code>gen &lt;N.max&gt; @</code></p> <p><code>[a..b]</code> </p> <p>Random integer between <code>a</code> and <code>b</code> </p> <p><code>gen [1..100] @</code> <code>gen [1..&lt;N.max&gt;] @</code></p> <p>(<code>a</code> | <code>b</code>)</p> <p>Random element <code>a</code> or <code>b</code></p> <p><code>gen (a</code> | <code>b) @</code></p>"},{"location":"setters/stress-testing/#finder-expressions","title":"Finder expressions","text":"<p>Finder expressions are domain-specific expressions evaluated by rbx that return a boolean value.</p> <p>Instead of formally defining the grammar for finder expressions, we list a few examples, with an explanation of what they do. They should give a rough understanding of how this feature works.</p> <pre><code># Find a test for which `sols/wa.cpp` returns any verdict considered incorrect.\n# Both versions are equivalent, the first one being a shorthand for the second.\nsols/wa.cpp\n[sols/wa.cpp] ~ INCORRECT\n\n# Find a test that fails one incorrect solution and a TLE solution at the same time.\n[sols/wa.cpp] ~ INCORRECT &amp;&amp; [sols/tle.cpp] ~ TLE\n\n# Find a test that fails one incorrect solution, but do not TLE other solution at the same time.\n[sols/wa.cpp] ~ INCORRECT &amp;&amp; [sols/tle.cpp] !~ TLE\n[sols/wa.cpp] ~ INCORRECT &amp;&amp; !([sols/tle.cpp] ~ TLE)\n\n# Find a test that fails one or the other.\n[sols/wa.cpp] ~ INCORRECT || [sols/wa2.cpp] ~ INCORRECT\n\n# Find a test where solutions give different verdicts.\n[sols/sol1.cpp] != [sols/sol2.cpp]\n\n# By using the ON syntax, specifies a custom checker to be used (instead of the main one).\n[sols/wa.cpp ON custom-checker.cpp] ~ INCORRECT\n\n# Use no checker whatsoever. Useful when you don't have a checker yet.\n[sols/tle.cpp ON :nil] ~ TLE\n\n# Use a 2-way checker. This checker will only require the input and the\n# output generated by the stressed program. In place of the output of the\n# main solution, an empty file will be passed.\n#\n# Useful if you don't have a main solution yet.\n[sols/wa.cpp ON 2:my_checker.cpp] ~ INCORRECT\n\n# Special operators:\n# Find a test that breaks the main solution (here, specified by a $).\n[$] ~ INCORRECT\n\n# Find a test that breaks the main solution, using the main checker in\n# a 2-way fashion.\n[$ ON 2:$] ~ INCORRECT\n</code></pre>"},{"location":"setters/stress-testing/#running-a-stress-test","title":"Running a stress test","text":"<p>rbx exposes an <code>rbx stress</code> command that can be used to run a stress test. The syntax is pretty straightforward.</p> <pre><code>rbx stress -g \"&lt;generator-expression&gt;\" -f \"&lt;finder-expression&gt;\"\n</code></pre> <p>By default, the stress test will be run for 10 seconds and will stop as soon as a match is found. You can tune these values with the <code>--findings / -n</code> and the <code>--timeout / -t</code> flags.</p> <pre><code># Runs for 2 minutes or stops after finding 3 matches.\nrbx stress -g \"&lt;generator-expression&gt;\" -f \"&lt;finder-expression&gt;\" -n 3 -t 120\nrbx stress -g \"gen 100 @\" -f sols/main.cpp\nrbx stress -g \"gen 100 @\" -f \"[sols/main.cpp] ~ INCORRECT\" -n 3 -t 120\n</code></pre> <p>The command will show a summary of what tests were found, and in case there's at least one match, it will prompt you to inform a testplan to add it to. If you skip this part, you can always copy the generator calls that were found and add them later.</p>"},{"location":"setters/stress-testing/#saving-a-stress-test","title":"Saving a stress test","text":"<p>You can save a stress test in your <code>problem.rbx.yml</code> file.</p> <pre><code>stresses:\n  - name: 'my-stress-test'\n    generator:\n      name: 'gen'\n      args: '100 @'\n    finder: '[sols/main.cpp] ~ INCORRECT'\n</code></pre> <p>You can then run the stress test with:</p> <pre><code>rbx stress my-stress-test\n</code></pre>"},{"location":"setters/stress-testing/#other-applications-of-stress-tests","title":"Other applications of stress tests","text":"<p>Besides using stress tests for checking solution outcomes, you can be creative and use it to test other components of your problem.</p> <p>For example, you can use it to test your checkers.</p> <pre><code># Find a test where the checker returns something different than WA,\n# even though the given solution always WA.\n[sols/always-wa.cpp ON custom-checker.cpp] != WA\n\n# Compare two checkers to see if they're misbehaving.\n[sols/sol.cpp ON custom-checker.cpp] != [sols/sol.cpp ON brute-force-checker.cpp]\n</code></pre> <p>Or you can even use it to test your validator and your interactor by simply stressing them to the limit.</p>"},{"location":"setters/variables/","title":"Variables","text":"<p>Variables are a way to define the constraints of your problem in a single place and reference them everywhere else.</p> <p>The motivation for having variables are simple: imagine you've decided to change the constraints of your problem. Without variables, you'd have to change this constraint in the validator, (potentially) in the checker and in the statements. It's super easy to forget about these changes, increasing the likelihood of introducing a disastrous bug in your problem.</p>"},{"location":"setters/variables/#defining-variables","title":"Defining variables","text":"<p>Variables are defined in the <code>vars</code> section of your <code>problem.rbx.yml</code> file.</p> problem.rbx.yml<pre><code># ...\nvars:\n  N:\n    min: 1\n    max: 100000\n  M:\n    min: 1\n    max: 200000\n</code></pre> <p>They're defined as key-value pairs. The keys should be valid Python identifiers and the values should be a <code>bool</code>, a <code>string</code>, an <code>int</code> or a <code>float</code>, all conforming to the YAML specification.</p> <p>Besides that, it's possible to use Python expressions that evaluate to one of these types, using the <code>py`...`</code> syntax. </p> problem.rbx.yml<pre><code># ...\nvars:\n  N:\n    max: py`10**5`\n  M:\n    max: py`2*10**5`\n</code></pre>"},{"location":"setters/variables/#using-variables","title":"Using variables","text":"<p>Variables can be used within validators, checkers and statements.</p> <p>In this section, we go through the different ways to use variables in each of these.</p>"},{"location":"setters/variables/#validators-and-checkers-c","title":"Validators and checkers (C++)","text":"<p>rbx automatically generates a <code>rbx.h</code> header file that contains the variables that were defined in the <code>problem.rbx.yml</code> file, right at the root of your package.</p> <p>This header exposes a function <code>getVar&lt;T&gt;(name)</code> that can be used to get the value of a variable as a <code>T</code>-typed object. There are 4 overloads for this function: <code>getVar&lt;bool&gt;(name)</code>, <code>getVar&lt;int&gt;(name)</code>, <code>getVar&lt;float&gt;(name)</code> and <code>getVar&lt;std::string&gt;(name)</code>.</p> <p>This header can be directly included in your validator/checker files.</p> validator.cppchecker.cpp <pre><code>#include \"testlib.h\"\n#include \"rbx.h\"\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = getVar&lt;int&gt;(\"N.max\");\n    int m = getVar&lt;int&gt;(\"M.max\");\n\n    // Single line with two numbers.\n    inf.readInt(1, n, \"n\");\n    inf.readSpace();\n    inf.readInt(1, m, \"m\");\n    inf.readEoln();\n    inf.readEof();\n}\n</code></pre> <pre><code>#include \"testlib.h\"\n#include \"rbx.h\"\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = getVar&lt;int&gt;(\"N.max\");\n    int m = getVar&lt;int&gt;(\"M.max\");\n\n    // ...\n}\n</code></pre>"},{"location":"setters/variables/#validators-other-languages","title":"Validators (other languages)","text":"<p>Validators also receive the variables as command-line arguments. This means that for the <code>problem.rbx.yml</code> above, your validator would be called roughly as follows:</p> <pre><code>./validator.exe --N.max=100000 --M.max=200000\n</code></pre> <p>You can freely parse those arguments in your language of choice.</p> <p>Checkers</p> <p>Checkers do not receive the variables as command-line arguments, as doing so is not compatible with any judging platforms.</p> <p>If you want to use variables in your checkers, they must be in C++ and you have to follow the approach outlined in the previous section.</p>"},{"location":"setters/variables/#statements","title":"Statements","text":"<p>rbxTeX statements can also use variables. This is done by using the <code>\\VAR</code> command with the <code>vars.</code> prefix.</p> statement.rbx.tex<pre><code>% ...\nYou're given a graph with \\VAR{vars.N.max} vertices and \\VAR{vars.M.max} edges.\n% ...\n</code></pre> <p>Variables can also be used within any rbxTeX statements, including loops and conditionals.</p> statement.rbx.tex<pre><code>% ...\n%- if vars.N.max &lt; 1000:\nThis problem is easy.\n%- else:\nThis problem is hard.\n%- endif\n% ...\n</code></pre> <p>Also, rbx exposes a few transform builtins that can be used to change how a variable is rendered. One of them is the <code>sci</code> builtin, which formats a number with many trailing zeroes in scientific notation.</p> statement.rbx.tex<pre><code>% ...\nYou're given a graph with \\VAR{vars.N.max | sci} vertices\nand \\VAR{vars.M.max | sci} edges.\n% ...\n</code></pre> <p>The <code>sci</code> builtin will make <code>N.max</code> and <code>M.max</code> be rendered as something like <code>10^5</code> and <code>2 x 10^5</code> respectively.</p>"},{"location":"setters/variables/#stress-tests","title":"Stress tests","text":"<p>Variables can also be used in generator expressions in stress tests with the <code>&lt;variable&gt;</code> notation.</p> <pre><code>rbx stress -g \"gen [1..&lt;N.max&gt;]\" -f \"[sols/wa.cpp] ~ INCORRECT\"\n</code></pre>"},{"location":"setters/grading/","title":"Grading","text":"<p>In competitive programming, grading is the process of running and evaluating whether the participant's solution is correct for a given testcase (or a set of testcases).</p> <p>rbx provides control over the full grading process, which in the case of setting problems, is way simpler than in the case of running an actual contest.</p> <p>In contests, the judging system is usually much more complex, and has to:</p> <ol> <li>Give a fair verdict to the participant: TLE when the solution is too slow, WA when the solution is incorrect, etc.</li> <li>Protect the system: prevent participants from cheating, from crashing the server, doing prohibited   system calls, etc.</li> </ol> <p>Security</p> <p>In the case of setting problems, we can focus on the first point, and assume setters are trustful actors and ignore the second one. Thus, rbx does not provide any mechanism to protect the system against malicious code being run. Be aware of that, and only run code written by authors you trust!</p> <p>Solutions will be run as the same user that run the <code>rbx</code> command. If you want to be extra careful, you can run <code>rbx</code> inside a Docker container, or create an isolated user with limited permissions to run it.</p>"},{"location":"setters/grading/#running-solutions","title":"Running solutions","text":"<p>Solutions run through rbx are executed through a wrapper script. This script applies memory and output limit constraints to the program through a mixture of <code>ulimit</code> calls and realtime resource usage monitoring.</p> <p>Different from judging systems, where sandboxes are usually written in C/C++ and are run as privileged users, this wrapper script is written in Python for better portability.</p>"},{"location":"setters/grading/#outcomes","title":"Outcomes","text":"<p>Right after running the solution, we must give a verdict to it (or, as we call them in rbx, an outcome).</p> <p>You can find the full list of outcomes in the table below.</p> Outcome Short name Description <code>ACCEPTED</code> <code>AC</code> The solution passed all the testcases. <code>WRONG_ANSWER</code> <code>WA</code> The solution produced an incorrect output. <code>TIME_LIMIT_EXCEEDED</code> <code>TLE</code> The solution took too much time to execute. <code>MEMORY_LIMIT_EXCEEDED</code> <code>MLE</code> The solution used too much memory. <code>IDLENESS_LIMIT_EXCEEDED</code> <code>ILE</code> The solution was idle for too long. <code>RUNTIME_ERROR</code> <code>RTE</code> The solution crashed. <code>OUTPUT_LIMIT_EXCEEDED</code> <code>OLE</code> The solution produced too much output. <code>JUDGE_FAILED</code> <code>FL</code> The judge failed to execute or produced an incorrect answer. <code>INTERNAL_ERROR</code> <code>IE</code> An internal error occurred. <p>All outcomes, except for <code>JUDGE_FAILED</code>, <code>WRONG_ANSWER</code> and <code>ACCEPTED</code> are all defined right after the solution runs.</p> <p>There's a process that needs to be executed right after the solution runs, and it's called checking, and you can read more about it in the Checkers section.</p>"},{"location":"setters/grading/#limits","title":"Limits","text":"<p>All limits that are applied to a solution are defined in <code>problem.rbx.yml</code> under the <code>*limit</code> family of fields.</p> problem.rbx.yml<pre><code># ... rest of the problem.rbx.yml ...\ntimeLimit: 1000  # 1 second\nmemoryLimit: 256  # 256 MB\n</code></pre> <p>Time is always defined in milliseconds, and memory is defined in megabytes. These limits are all applied by the wrapper script, and checked further after the solution is executed.</p> <p>You can also control the maximum size of the participant's output (which defaults to 4096 KB).</p> problem.rbx.yml<pre><code># ... rest of the problem.rbx.yml ...\noutputLimit: 1024  # 1024 KB\n</code></pre> <p>And you can also provide language-specific limits.</p> problem.rbx.yml<pre><code># ... rest of the problem.rbx.yml ...\nmodifiers:\n  java:\n    time: 2000  # 2 second\n    memory: 1024  # 1024 MB\n</code></pre>"},{"location":"setters/grading/checkers/","title":"Checkers","text":"<p>Checker is a concept introduced by testlib to verify whether the participant's solution is correct for a given testcase.</p> <p>A checking algorithm can range from a very simple diff between two files, to a much more complex algorithm such as \"does the participant output contains a path between two specific vertices by using edges that are part of the input graph?\".</p> <p>We strongly recommend using testlib checkers for your problems, as they are battle-tested and will cover most of your needs. Also, they're usually lenient with extra spaces, newlines and such.</p> <p>Think of all the frustration you had in your life with presentation errors and problems that asked you to print the \"minimum lexicographically path in a graph\" just to force the solution to be unique. testlib checkers are here to solve that.</p> <p>Non-testlib checkers</p> <p>Please, use testlib checkers. rbx is seriously opinionated about this, and although it will most of the times work with non-testlib checkers, no guarantees are given.</p> <p>This document will intentionally not cover non-testlib checkers.</p>"},{"location":"setters/grading/checkers/#built-in-testlib-checkers","title":"Built-in testlib checkers","text":"<p>rbx provides out-of-the-box support for the built-in testlib checkers defined here.</p> <p>You can use them by specifying the <code>checker</code> field in your <code>problem.rbx.yml</code> file.</p> problem.rbx.yml<pre><code># ... rest of the problem.rbx.yml ...\nchecker:\n  - path: \"wcmp.cpp\"\n</code></pre> <p>rbx will automatically detect it is a built-in checker and will download it from the testlib repository.</p> <p>The most common built-in checkers are described in the table below, but you should feel free to explore the others. The <code>wcmp.cpp</code> checker is the default checker for rbx, since it's basically a space-tolerant diff.</p> <p>Checker</p> <p>Description</p> <p><code>wcmp.cpp</code> </p> <p>Compares the sequence of words of two files, as if they were a tuple. First, the files are tokenized, and then each token is compared.</p> <p><code>ncmp.cpp</code></p> <p>Same as <code>wcmp.cpp</code>, but compares 64-bit signed integers.</p> <p><code>uncmp.cpp</code></p> <p>Same as <code>ncmp.cpp</code>, but disregards the order of the numbers.</p> <p><code>yesno.cpp</code></p> <p>Compares a single word which must be \"YES\" or \"NO\" (case-insensitive).</p> <p><code>nyesno.cpp</code></p> <p>Same as to <code>wcmp.cpp</code>, but all tokens must be \"YES\" or \"NO\" (case-insensitive).</p> <p><code>dcmp.cpp</code></p> <p>Compares two doubles by ensuring their maximal absolute or relative error is at most <code>1e-6</code>.</p> <p><code>rcmp.cpp</code></p> <p>Same as <code>dcmp.cpp</code>, but uses an error of <code>1e-9</code> instead.</p>"},{"location":"setters/grading/checkers/#custom-testlib-checkers","title":"Custom testlib checkers","text":"<p>You can also write your own testlib checkers. Checkers in rbx are programs that receives three arguments:</p> <pre><code>./checker &lt;input_file&gt; &lt;output_file&gt; &lt;answer_file&gt;\n</code></pre> <p>The arguments are:</p> <ul> <li><code>&lt;input_file&gt;</code>: the input file for the testcase.</li> <li><code>&lt;output_file&gt;</code>: the output file produced by the participant.</li> <li><code>&lt;answer_file&gt;</code>: the answer file, i.e. the one that contains the output of the model solution.</li> </ul> <p>Some times, the <code>&lt;answer_file&gt;</code> is not needed. Let's see a simple case first, and then let's look at one where the <code>&lt;answer_file&gt;</code> is needed.</p>"},{"location":"setters/grading/checkers/#output-only-case","title":"Output-only case","text":"<p>Let's say we have a problem that asks you to find a path between two vertices 1 and <code>N</code> in a graph.</p> <p>In this case, we want to check whether:</p> <ul> <li>The participant's output contains a path between two vertices 1 and <code>N</code> in the input graph.</li> <li>The path is simple, i.e. it doesn't visit any vertex (or edge) more than once.</li> </ul> <p>Let's say the input is given in the following format:</p> Input format<pre><code>N M\nu_1 v_1\nu_2 v_2\n...\nu_M v_M\n</code></pre> <p>And the output is printed in the following format:</p> Output format<pre><code>K\np_1 p_2 ... p_K\n</code></pre> <p>Where <code>K</code> is the number of vertices in the path, and <code>p_1 p_2 ... p_K</code> is the sequence of vertices in the path.</p> <p>We can write a checker that does exactly that.</p> checker.cppproblem.rbx.yml <pre><code>#include \"testlib.h\"\n\nint main(int argc, char *argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // `inf` is a stream used to read the input file.\n    int N = inf.readInt();\n    int M = inf.readInt();\n\n    vector&lt;set&lt;int&gt;&gt; adj(N + 1);\n    for (int i = 0; i &lt; M; i++) {\n        int u = inf.readInt();\n        int v = inf.readInt();\n        adj[u].insert(v);\n        adj[v].insert(u);\n    }\n\n    // Read the participant's output\n    // `ouf` is a stream used to read the participant's output.\n    int K = ouf.readInt(1, N, \"path size\"); // (1)!\n    vector&lt;int&gt; path(K);\n    for (int i = 0; i &lt; K; i++) {\n        path[i] = ouf.readInt(1, N, \"path vertex\");\n    }\n\n    // Check if the path starts at 1 and ends at N.\n    ouf.quitif(path[0] != 1, _wa, \"path does not start at 1\");  // (2)!\n    ouf.quitif(path[K - 1] != N, _wa, \"path does not end at N\");\n\n    // Check if the path is simple\n    set&lt;int&gt; seen;\n    for (int i = 0; i &lt; K; i++) {\n        ouf.quitif(seen.count(path[i]), _wa, \"path is not simple\");\n        seen.insert(path[i]);\n    }\n\n    ouf.quitf(_ok, \"path with %d vertices found\", K);  // (3)!\n}\n</code></pre> <ol> <li> <p>Notice how we're strict with the bounds of the numbers we're reading from the user. If the user     provides an invalid number, we'll mark the participant's output as wrong.</p> <p>This is especially important here, not only for correctness, but also because we'll allocate a vector of size <code>N</code> in the next step, and we don't want the participant to provide an invalid number.</p> </li> <li> <p>We use <code>quitif</code> to immediately stop the program and mark the participant's output as wrong when     some condition is not met.</p> <p>One can also use the <code>quitf</code> variant to simply quit. This allows one to write an equivalent code:</p> <pre><code>if (condition_is_not_met) {\n  ouf.quitf(_wa, \"...\");\n}\n</code></pre> </li> <li> <p>We use <code>quitf(_ok, ...)</code> to mark the participant's output as correct, and notice we can use     format specifiers in the message.</p> </li> </ol> <pre><code># ... rest of the problem.rbx.yml ...\nchecker:\n  - path: \"checker.cpp\"\n</code></pre> <p>Notice checking only the participant's output here was more than enough. We don't need to consume the <code>&lt;answer_file&gt;</code> at all.</p> <p>You can learn more about testlib streams and all the functions available in their official documentation.</p>"},{"location":"setters/grading/checkers/#output-answer-case","title":"Output + answer case","text":"<p>Sometimes, it's also important to consider the jury's solution.</p> <p>Let's consider the following modification to the problem above: now, you have to find the shortest path between two vertices 1 and <code>N</code>. We can assume the input and output format stays the same.</p> <p>The only way to be sure the participant's solution is the shortest possible is to actually find the shortest path in the input graph. That is exactly what our model solution already does, right? We could proceed in two ways here:</p> <ol> <li> <p> We could simply read the answer from the <code>&lt;answer_file&gt;</code> and ensure the participant's path size is equals to the jury's path size, and otherwise mark the participant's output as wrong.</p> </li> <li> <p> We could compare the participant's path with the jury's path, and if they are different, mark the participant's output as wrong if it's longer than the jury's path, or mark the jury's output as wrong if it's longer than the participant's path.</p> </li> </ol> <p>(1) is very dangerous for obvious reasons: what if the jury's solution is wrong? Of course, for shortest paths we simply know the optimal solution is a BFS, and it's hard to get that wrong, right? But think of more complex problems which are totally new and that probably have never been solved before. It's very easy to get that wrong, and having a checker for that can help detecting an issue in setting time (or, in worst case, in contest time).</p> <p>(2) is the way to go here, as it ensures that the participant's solution is at least as good as the jury's solution. rbx has a special outcome called <code>JUDGE_FAILED</code>, which is used to convey a checking failure, when the jury's output is wrong.</p> checker.cppproblem.rbx.yml <pre><code>#include \"testlib.h\"\n// Reads a path from the given stream, ensures it's valid\n// according to `N` and `adj`, and returns its size.\n// (1)!\nint readPath(InStream &amp;stream,\n             int N,\n             const vector&lt;set&lt;int&gt;&gt; &amp;adj) {\n  int K = stream.readInt(1, N, \"path size\");\n  vector&lt;int&gt; path(K);\n  for (int i = 0; i &lt; K; i++) {\n    path[i] = stream.readInt(1, N, \"path vertex\");\n  }\n\n  // Check if the path starts at 1 and ends at N.\n  stream.quitif(path[0] != 1, _wa, \"path does not start at 1\");\n  stream.quitif(path[K - 1] != N, _wa, \"path does not end at N\");\n\n  // Check if the path is simple\n  set&lt;int&gt; seen;\n  for (int i = 0; i &lt; K; i++) {\n    stream.quitif(seen.count(path[i]), _wa, \"path is not simple\");\n    seen.insert(path[i]);\n  }\n\n  return K;\n}\n\nint main(int argc, char *argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // `inf` is a stream used to read the input file.\n    int N = inf.readInt();\n    int M = inf.readInt();\n\n    vector&lt;set&lt;int&gt;&gt; adj(N + 1);\n    for (int i = 0; i &lt; M; i++) {\n        int u = inf.readInt();\n        int v = inf.readInt();\n        adj[u].insert(v);\n        adj[v].insert(u);\n    }\n\n    // Read the participant's output\n    // `ouf` is a stream used to read the participant's output.\n    int K = ouf.readInt(1, N);\n    vector&lt;int&gt; path(K);\n    for (int i = 0; i &lt; K; i++) {\n        path[i] = ouf.readInt(1, N);\n    }\n\n    int psize = readPath(ouf, N, adj); // participant's path size\n    int jsize = readPath(ans, N, adj); // jury's path size\n\n    // Compare sizes of the paths (2)\n    ouf.quitif(psize &gt; jsize, _wa,\n               \"participant's path is longer than the jury's path (size %d &gt; %d)\",\n               psize, jsize);\n    ans.quitif(psize &lt; jsize, _wa,\n               \"participant's path is shorter than the jury's path (size %d &lt; %d)\",\n               psize, jsize);\n\n    ouf.quitf(_ok, \"path with %d vertices found\", K);\n}\n</code></pre> <ol> <li> <p>Notice how we extract the common logic of reading a path from a stream into a function.</p> <p>testlib is smart: if quitf is called with <code>_wa</code>, it will mark the corresponding stream as wrong, resulting in a WA verdict if the participant's output is wrong, and in a JUDGE_FAILED verdict if the jury's output is wrong.</p> </li> <li> <p>We use <code>_wa</code> to mark the jury's output (represented by the <code>ans</code> stream) as wrong and cause a JUDGE_FAILED verdict.</p> <p>We could as well use <code>quitif(..., _fail, ...)</code>, which would have the same effect.</p> <p>Note</p> <p><code>_fail</code> conveys a checking failure, regardless of the stream it was applied to.</p> <p><code>_wa</code> conveys a wrong answer, and is applied to the stream that was being checked.</p> </li> </ol> <pre><code># ... rest of the problem.rbx.yml ...\nchecker:\n  - path: \"checker.cpp\"\n</code></pre> <p>Notice how we read from both outputs, validating each of them individually, and compare their sizes at the end, giving an appropriate verdict for each of them, and avoiding assuming the jury's output is 100% correct.</p> <p>You can learn more about testlib streams and all the functions available in their official documentation.</p>"},{"location":"setters/grading/interactors/","title":"Interactors","text":"<p>Interactor is a concept introduced by testlib to play the role of an agent that communicates with the participant's solution through the pair <code>stdin</code>/<code>stdout</code> in interactive problems.</p> <p>You can read more about what is an interactive problem in this thorough Codeforces blog post written by Mike Mirzayanov.</p> <p>In this section, we will see how to write an interactive problem and how to define an interactor for it in rbx.</p>"},{"location":"setters/grading/interactors/#motivational-problem","title":"Motivational problem","text":"<p>Let's assume we have a problem that asks you to find a number between 1 and <code>N</code>, where <code>N</code> is between 2 and 1000. You should find it with at most 10 guesses to the interactor. A guess is a line in the format <code>? X</code>, where <code>X</code> is a number between 1 and <code>N</code>.</p> <p>The interactor will first give you the value of <code>N</code>, and then respond each guess with <code>&lt;</code>, <code>&gt;</code> or <code>=</code> if the guess is less than, greater than or equal to the secret number, respectively. When responding with <code>=</code>, the game ends and the solution should finish execution.</p> <p>Let's assume the secret number is 7. A possible interaction between the solution and the interactor is the following:</p> Agent Line Description Interactor <code>10</code> Tells participant that <code>N = 10</code> Participant <code>? 5</code> The participant guesses 5 Interactor <code>&lt;</code> 5 is less than the secret number Participant <code>? 7</code> The participant guesses 7 Interactor <code>=</code> 7 is equal to the secret number - Both agents finish execution"},{"location":"setters/grading/interactors/#preliminary-definitions","title":"Preliminary definitions","text":"<p>Let's first of all define an interactor for the problem. In most cases, the interactor should be the very first component to be written in an interactive problem, because it is particularly hard to write solutions and test them before having one defined.</p> <p>Tip</p> <p>Of course, you can always interactively run your solution.</p> <p>Feel free to use the <code>rbx compile &lt;solution&gt;</code> command to compile them, and run them by executing <code>build/exe</code> from your project's root directory.</p> <p>In this case, you will interactively write to the solution's <code>stdin</code>, essentially playing the role of the interactor.</p> <p>A testlib interactor consists of an executable that receives two arguments:</p> <pre><code>./interactor &lt;input_file&gt; &lt;output_file&gt;\n</code></pre> <p>Besides these two files, the interactor also communicates with the solution through the <code>stdin</code>/<code>stdout</code> files.</p> <p>The interactor:</p> <ul> <li>Receives the test input from the <code>input_file</code> (the participant can't see this file);</li> <li>Writes some logging output to the <code>output_file</code> (the participant can't see this file);</li> <li>Reads the participant's output from <code>stdin</code>;</li> <li>Writes the participant's input into <code>stdout</code>.</li> </ul> <p>This structure is depicted in the following diagram:</p> <p> </p> <p>Thus, even though the communication between the two agents is done through <code>stdin</code>/<code>stdout</code>, the interactor still has its own input and output files that can have a similar purpose to the inputs and outputs of an usual batch problem.</p> <p>For this problem, let's assume we have a testset containing some input files containing two numbers: <code>N</code> and the secret number <code>S</code>, with <code>1 &lt;= S &lt;= N &lt;= 1000</code>. We can also assume we've written a validator for this file.</p> <p>Note</p> <p>Notice validators will receive the input file the interactor reads from, not the <code>stdin</code> of the participant's solution.</p>"},{"location":"setters/grading/interactors/#the-interactor","title":"The interactor","text":"<p>You can read more about testlib interactors in the official testlib documentation.</p> <p>Now that we have our input formally defined, let's write a testlib interactor and set it up in our problem.</p> <p>You can see in the commented code below how to read from each of the files available to the interactor.</p> interactor.cppproblem.rbx.yml <pre><code>#include \"testlib.h\"\n#include \"rbx.h\"\n\nusing namespace std;\n\n// Testlib interactors have a non-conventional stream setup:\n// - inf: for reading the input file\n// - ouf: for reading the participant's output\n// And two C++ IO streams for writing:\n// - cout: for writing to the participant's input\n// - tout: for writing the output file\nint main(int argc, char *argv[]) {\n    registerInteraction(argc, argv);\n\n    int N = inf.readInt(); // (1)!\n    int S = inf.readInt();\n\n    int MAX_Q = getVar&lt;int&gt;(\"Q.max\"); // (2)!\n\n    for(int i = 0; i &lt; MAX_Q; i++) {\n      int X = ouf.readInt(1, N); // (3)!\n\n      if(X &lt; S) { // (4)!\n        cout &lt;&lt; \"&lt;\" &lt;&lt; endl;\n      } else if(X &gt; S) {\n        cout &lt;&lt; \"&gt;\" &lt;&lt; endl;\n      } else {\n        cout &lt;&lt; \"=\" &lt;&lt; endl;\n        tout &lt;&lt; i+1 &lt;&lt; endl; // (5)!\n        quitf(_ok, \"found the secret number in %d guesses\", i + 1);\n      }\n    }\n\n    quitf(_wa, \"exceeded the maximum number of guesses\");\n}\n</code></pre> <ol> <li> <p>Reads the two input numbers from the input file.</p> <p>This was either provided by a generator or manually by you.</p> </li> <li> <p>Reads the maximum number of guesses allowed from the rbx variables.</p> <p>We defined this would be 10 in the statement above, but let's define this as a variable as a good practice.</p> </li> <li> <p>Reads the participant's guess from the <code>stdin</code> of the interactor / <code>stdout</code> of the solution.</p> <p>Notice we also check it is within bounds.</p> </li> <li> <p>Writes back the response to the guess to the <code>stdout</code> of the interactor / <code>stdin</code> of the solution.</p> <p>We use the common C++ <code>std::cout</code> stream for that.</p> </li> <li> <p>In case the solution is correct, writes the number of guesses to the output file for logging purposes (in some judging systems, you can inspect this file, for instance).</p> <p>We use the C++ <code>tout</code> stream for that.</p> </li> </ol> <pre><code># ... rest of the problem.rbx.yml ...\n# We have to set these for the problem to be considered interactive\ntype: COMMUNICATION\ninteractor:\n  path: 'interactor.cpp'\n# ...\nvars:\n  Q:\n    max: 10\n</code></pre>"},{"location":"setters/grading/interactors/#executing-solutions-against-the-interactor","title":"Executing solutions against the interactor","text":"<p>Solutions for interactive problems can be executed normally, similar to batch problems, with the <code>rbx run</code> and <code>rbx irun</code> commands.</p> <p>Read more about them in the Running solutions section.</p> <p>Warning</p> <p>When providing a custom input for <code>rbx irun</code>, you're actually providing the input to the interactor, NOT the solution.</p> <p>The results of the run can also be inspected using the <code>rbx ui</code> command.</p> <p>If you want to compile the solution, and interactively communicate with it as if you were the interactor agent, you can compile your solution with the <code>rbx compile</code> command and then run it manually with <code>./build/exe</code>.</p> <pre><code>rbx compile solution.cpp\n./build/exe\n# ... start interacting with the solution as the interactor ...\n</code></pre>"},{"location":"setters/grading/interactors/#do-i-need-to-write-a-checker","title":"Do I need to write a checker?","text":"<p>Short answer: no, you don't need to write a checker. In fact, the ICPC package format doesn't support one.</p> <p>Instead, this format expects the interactor to both communicate with the solution and judge it. Other judging systems do support specifying a checker, and some even require one (e.g., Polygon). However, this practice is not encouraged by rbx, as it is not part of the ICPC package format.</p> <p>Tip</p> <p>rbx will automatically generate a dummy/no-op checker when you generate a package for a judging system that requires one. You should not worry about this!</p> <p>rbx does give you the flexibility to specify a checker by setting an extra bit in the <code>problem.rbx.yml</code> file. This is put there as a guard so you don't mistakenly set a checker for your interactive problem without realizing it.</p> problem.rbx.yml<pre><code># ...\ntype: COMMUNICATION\ninteractor:\n  path: 'interactor.cpp'\n  legacy: true\nchecker:\n  path: 'checker.cpp'\n</code></pre> <p>The newly defined checker will read as the outputs for the participant's and the jury's solutions the <code>output_files</code> produced by their interactor runs (whatever was written into <code>tout</code>).</p> <p> </p> <p>Then, you could split the previously defined interactor into two files as such:</p> interactor.cppchecker.cpp <pre><code>#include \"testlib.h\"\n\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerInteraction(argc, argv);\n\n    int N = inf.readInt();\n    int S = inf.readInt();\n\n    while (true) {\n      int X = ouf.readInt(1, N);\n\n      if(X &lt; S) {\n        cout &lt;&lt; \"&lt;\" &lt;&lt; endl;\n      } else if(X &gt; S) {\n        cout &lt;&lt; \"&gt;\" &lt;&lt; endl;\n      } else {\n        cout &lt;&lt; \"=\" &lt;&lt; endl;\n        tout &lt;&lt; i+1 &lt;&lt; endl;\n      }\n    }\n\n    quitf(_ok, \"ok\"); // leave the query limit to the checker\n}\n</code></pre> <pre><code>#include \"testlib.h\"\n#include \"rbx.h\"\n\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int N = inf.readInt();\n    int S = inf.readInt();\n\n    int MAX_Q = getVar&lt;int&gt;(\"Q.max\");\n\n    int p_guesses = ouf.readInt();\n\n    if (p_guesses &gt; MAX_Q) {\n        quitf(_wa, \"participant exceeded the maximum number of guesses (%d &gt; %d)\", p_guesses, MAX_Q);\n    }\n\n    quitf(_ok, \"found the secret number in %d guesses\", p_guesses);\n}\n</code></pre> <p>Incompatible with ICPC</p> <p>This is not part of the ICPC package format, and thus rbx will throw an error if you try to generate an ICPC package for an interactive problem that has a checker.</p> <p>The solution will be to migrate the checker into the interactor.</p>"},{"location":"setters/packaging/","title":"Packaging","text":"<p>rbx supports exporting problem/contest packages into a few formats. You can see in the table below which formats are supported, and what are its supported features and limitations:</p> <p>Format</p> <p>Target Systems</p> <p>Supports</p> <p>ICPC (coming soon) </p> <p>DOMjudge, Kattis </p> <p> Interactive problems (without checker)  Batch problems  Test grouping  Limits per language  Solution verification  Package upload</p> <p>BOCA </p> <p>BOCA </p> <p> Interactive problems (with checker)  Batch problems  Limits per language  Package upload  Test grouping  Solution verification</p> <p>Polygon </p> <p>Codeforces, Polygon </p> <p> Interactive problems (with checker)  Batch problems  Limits per language  Package upload (with limitations)  Solution verification  Test grouping</p>"},{"location":"setters/packaging/#rbx-package","title":"<code>rbx package</code>","text":"<p>rbx provides an umbrella <code>rbx package &lt;format&gt;</code> command group that contains commands for each of the formats supported by it.</p> <p>All these formats support a <code>-v</code> flag, that sets the verification level for building the package.</p> <p>By default, packages will be built with the <code>-v</code> flag set to <code>4</code> (the maximum value), which means that tests will be built, validated and all solutions will be run against them, and their expected outcomes will be verified.</p> <p>You can change this by setting the <code>-v</code> flag to a different value, with the following meanings:</p> <ul> <li><code>0</code>: Tests will be built, no validation will be done.</li> <li><code>1</code>: Tests will be built and validated.</li> <li><code>2</code>: Tests will be built, validated and accepted solutions will be run against them, and their expected outcomes will be verified.</li> <li><code>3</code>: Tests will be built, validated and non-TLE solutions will be run against them, and their expected outcomes will be verified.</li> <li><code>4</code>: Tests will be built, validated and all solutions will be run against them, and their expected outcomes will be verified.</li> </ul> <p>The example below shows how to build an ICPC package by only generating tests and validating them.</p> <pre><code>rbx package icpc -v1\n</code></pre> <p>See each one of the sections dedicated to each of the avilable formats on the sidebar.</p>"},{"location":"setters/packaging/boca/","title":"Packaging: BOCA","text":"<p>rbx provides a command to build packages for BOCA.</p> <pre><code>rbx package boca\n</code></pre> <p>Or, if you want to build the package for all problems in your contest:</p> <pre><code>rbx contest each package boca\n</code></pre> <p>Both batch problems and interactive problems are supported.</p>"},{"location":"setters/packaging/boca/#interactive-problems","title":"Interactive problems","text":"<p>Interactive problems can be easily packaged for BOCA with rbx. There are some limitations to it, though:</p> <ul> <li>The BOCA package needs a checker. In case you don't provide one, the tool will automatically generate a dummy one,   one that returns AC for all inputs, as long as the interactor finishes successfully.</li> <li>The messages exchanged between the interactor and the solution will not be captured, and thus will not be visible   in the BOCA UI. If you want to inspect the interaction between them, you have to download the participant's   solution and run it locally.</li> </ul>"},{"location":"setters/packaging/boca/#uploading-to-boca","title":"Uploading to BOCA","text":"<p>You can upload the package to BOCA by setting the <code>--upload</code> / <code>-u</code> flag.</p> <pre><code>rbx package boca -u\n</code></pre> <p>Or you can use the contest-level commands below.</p> <pre><code># Will upload all problems in the contest\nrbx contest each package boca -u\n\n# Will upload only problem A\nrbx contest on A package boca -u\n\n# Will upload problems A to C\nrbx contest on A-C package boca -u\n\n# Will upload problems A and C\nrbx contest on A,C package boca -u\n</code></pre> <p>For that to work, you have to instruct rbx on how to connect to the BOCA server.</p> <p>rbx expects you to have set three environment variables, which you can, for instance, keep in your <code>.bashrc</code> or <code>.zshrc</code> files:</p> <pre><code>export BOCA_USERNAME=\"admin_username\"\nexport BOCA_PASSWORD=\"admin_password\"\nexport BOCA_BASE_URL=\"https://your.boca.com/boca\"\n</code></pre> <p>Notice the configured user must correspond to an admin of your contest, so rbx will have permissions to upload the package. Also, make sure the correct contest is activated in the BOCA server before running the command.</p>"},{"location":"setters/packaging/boca/#troubleshooting","title":"Troubleshooting","text":""},{"location":"setters/packaging/boca/#upload-is-taking-too-long-or-an-error-is-being-reported","title":"Upload is taking too long, or an error is being reported","text":"<p>BOCA packages are uploaded to the server via HTTP. By default, BOCA servers (actually, PHP servers) are configured with a really tight limit for uploaded file sizes. If you are running into this issue, you can try to increase the limit by setting the <code>upload_max_filesize</code> and the <code>post_max_size</code> directives in your <code>php.ini</code> file.</p> <p>For BOCA installations done through the official Maratona Ubuntu PPA, you can find the configuration file in <code>/etc/php/8.1/fpm/php.ini</code>, and then restart the PHP service with <code>sudo service php8.1-fpm restart</code>.</p> <p>If you want to give a shot at fixing this with a bash script, try running:</p> <pre><code>sudo sed -i 's/upload_max_filesize = .*/upload_max_filesize = 200M/' /etc/php/8.1/fpm/php.ini\nsudo sed -i 's/post_max_size = .*/post_max_size = 200M/' /etc/php/8.1/fpm/php.ini\nsudo sed -i 's/memory_limit = .*/memory_limit = 256M/' /etc/php/8.1/fpm/php.ini\nsudo service php8.1-fpm restart\n</code></pre> <p>Danger</p> <p>These limits are there for a reason, and you should only change them if you know what you're doing. Allowing big post sizes can open the door for malicious users to take advantage of that.</p> <p>Try setting it to the smallest value you need to be able to upload your packages.</p> <p>Warning</p> <p>Another option, often easier but sometimes undesirable, is to make sure your packages are not too big. Big packages will usually pose a problem if you're trying to fix a package during the contest with a slow connection.</p>"},{"location":"setters/packaging/boca/#i-removed-a-problem-from-the-contest-but-it-still-appears-in-boca","title":"I removed a problem from the contest, but it still appears in BOCA","text":"<p>rbx does not remove problems from BOCA automatically, as this is a disruptive change. You will have to remove the problem manually from BOCA.</p> <p>Also notice that, when you rearrange problems in the contest (for instance, add a problem C, and move all problems after C one position ahead), rbx will override the old C problem with the new one.</p>"},{"location":"setters/packaging/boca/#im-seeing-a-different-verdict-in-boca-than-the-one-i-got-in-rbx","title":"I'm seeing a different verdict in BOCA than the one I got in rbx","text":"<p>It's expected that some verdicts are different in BOCA, especially because the sandboxes used by both platforms are not exactly the same.</p> <p>For instance, you can see runtime errors vs. memory limit exceeded, or differences like this.</p> <p>If you see a difference that you think is not justifiable, please let us know by opening an issue on our GitHub repository.</p>"},{"location":"setters/packaging/polygon/","title":"Packaging: Polygon","text":"<p>rbx provides a command to build packages for Polygon. The Polygon format supports two types of packages: problem packages and contest packages.</p>"},{"location":"setters/packaging/polygon/#problem-packages","title":"Problem packages","text":"<p>Problem packages are built by running the following command:</p> <pre><code>rbx package polygon\n</code></pre> <p>Or, if you want to build a problem package for each problem in your contest:</p> <pre><code>rbx contest each package polygon\n</code></pre>"},{"location":"setters/packaging/polygon/#contest-packages","title":"Contest packages","text":"<p>There's also a contest-level command for building a contest package:</p> <pre><code>rbx contest package polygon\n</code></pre> <p>This command will build a single <code>.zip</code> file with all problems in the contest.</p>"},{"location":"setters/packaging/polygon/#uploading-to-codeforces-gym","title":"Uploading to Codeforces Gym","text":"<p>There are two totally different ways of uploading Polygon packages to Codeforces Gym.</p>"},{"location":"setters/packaging/polygon/#using-the-taskbook-ftp","title":"Using the Taskbook FTP","text":"<p>You can upload a contest package to Codeforces Gym by first building it with the command above, and then using the Codeforces Taskbook FTP (taskbook.codeforces.com) to upload your zip file to your contest.</p> <p>You can read more about the Taskbook by enabling coach mode, creating a new contest in the Gym, and looking at the \"Coach mode on\" section on the right side of the contest page. It will look like the image below:</p> <p></p> <p>Follow the instructions to upload your contest ZIP.</p> <p>Note</p> <p>By uploading through the Taskbook, you'll only get PDF statements. That is not a limitation of rbx, but rather the way Codeforces Gym and Taskbook work (probably for safety reasons as otherwise people could inject arbitrary HTML code into Codeforces).</p> <p>If you prefer HTML statements, you can use the option below.</p> <p>Danger</p> <p>Quite often the Taskbook FTP will be down. It seems this endpoint is not very reliable anymore. Refer to the option below, which is a bit more complicated but more reliable.</p>"},{"location":"setters/packaging/polygon/#using-the-polygon-api","title":"Using the Polygon API","text":"<p>You can also upload your problem packages to Polygon, gather them into a Polygon contest, and import them in the Gym.</p> <p>This is a process that is a bit more complicated, and has a few limitations, but that usually gives you a better result. The pros of using this method are:</p> <ul> <li>You'll get a Polygon problem instance for each problem in your contest. This means you can access the problem in Polygon,   run some custom invocations, and even tune the time limit of each problem to Codeforces' machines.</li> <li>You can get HTML statements which render natively in Codeforces.</li> <li>Does not depend on the flaky Taskbook FTP.</li> </ul> <p>Follow the step-by-step guide below to get your contest up in the Gym.</p>"},{"location":"setters/packaging/polygon/#step-1-get-a-polygon-api-key","title":"Step 1: Get a Polygon API key","text":"<p>Log in to Polygon and go to the Settings page. In the API Keys section, create a new API key and save the generated pair.</p>"},{"location":"setters/packaging/polygon/#step-2-upload-all-your-problems-to-polygon-using-the-api","title":"Step 2: Upload all your problems to Polygon using the API","text":"<p>You can upload all problems to the contest by defining the environment variables below and running the rbx command:</p> <pre><code>export POLYGON_API_KEY=&lt;your-api-key&gt;\nexport POLYGON_API_SECRET=&lt;your-api-secret&gt;\nrbx contest each package polygon -u\n</code></pre> <p>Feel free to keep those variables in your <code>.bashrc</code> (or equivalent in other shells) file if you want.</p> <p>This will create a Polygon problem for each problem in your contest following the pattern <code>&lt;contest-name&gt;-&lt;problem-shortname&gt;-&lt;problem-name&gt;</code> (example: <code>my-contest-a-my-problem</code> for a contest named <code>my-contest</code> with a problem named <code>my-problem</code> which has the letter <code>A</code>).</p> <p>This problem will contain the validator, checker, interactor, and any other files you added to the problem.</p> <p>The statement blocks will also be uploaded to Polygon, along with all model solutions.</p>"},{"location":"setters/packaging/polygon/#step-3-optional-tune-your-time-limits-and-statements-to-polygon","title":"Step 3: (Optional) Tune your time limits and statements to Polygon","text":"<p>This is the optional part that we highly recommend following. There are two components in Polygon that might not work right out of the box when you upload your problem, and it's worth checking them and tuning them if necessary.</p> <ol> <li> <p>Time limits: The time limits might not work well in the Polygon machines. We recommend you to    fire up a custom invocation in the Invocations section, and tune your time limit based on that    in the General info section.</p> </li> <li> <p>Statements: Polygon only supports rendering in HTML a subset of LaTeX commands. You might have to do some manual adjustments if you really want HTML statements in your contest. With some trial and error, it is easy to get a sense of which commands work and which don't.</p> </li> </ol>"},{"location":"setters/packaging/polygon/#step-4-create-a-new-polygon-contest-with-all-the-problems","title":"Step 4: Create a new Polygon contest with all the problems","text":"<p>Now that you have all your problems in Polygon, you can create a new contest and import all problems into it.</p> <p>Click New contest in the top-right corner, and fill in the form. Then, enter the contest and add all problems you uploaded to it. Finally, click Manage problem access and give <code>read</code> access to <code>codeforces</code> to all problems, and to the contest itself.</p> <p>After that, click Build standard packages to ensure the packages for all problems are built.</p>"},{"location":"setters/packaging/polygon/#step-5-create-a-contest-in-the-gym-and-import-the-polygon-contest","title":"Step 5: Create a contest in the Gym and import the Polygon contest","text":"<p>Enable coach mode, create a new contest and hit the Add problems from contest link.</p> <p></p> <p>In the following page, paste the contest UID in Polygon, and click the button. You can obtain the contest UID like in the picture below:</p> <p></p>"},{"location":"setters/packaging/polygon/#caveats","title":"Caveats","text":"<p>Warning</p> <p>The caveats in this section are probably the main reason you should consider using Polygon directly if your main goal is to hold a Gym contest.</p> <p>The Polygon API has a few limitations. The main two, which have huge implications on how rbx uploads your problems, are:</p> <ul> <li>The API doesn't allow you to remove solutions from a problem;</li> <li>The API doesn't allow you to remove tests from a problem.</li> </ul> <p>This means that, whenever you remove a few tests from a problem, or a solution, and re-upload, you have to manually get rid of them. rbx will successfully replace every test index that still exists, and also the solutions that exist, but it won't do anything to remove old ones.</p> <p>Also notice that whenever you tune your time limits or statements in Polygon and re-issue an upload, those modifications you did will be overridden. You have to be extra careful with that. Preferrably, you should replicate all your statement changes in rbx before uploading to Polygon.</p>"},{"location":"setters/presets/","title":"Presets","text":"<p>Note</p> <p>This documentation is mainly targeted at head setters trying to create a contest from scratch.</p> <p>If you're just a setter that wants to contribute to an already existing contest, you can probably just clone the repository the head setters shared with you and skip this documentation altogether.</p> <p>Presets is a feature that allows head setters to create a contest template that can be reused across multiple contests.</p> <p>A preset consists of four different pieces:</p> <ul> <li>A contest template: simply, a contest folder with some sensible defaults set that will   be used to bootstrap a contest based on this preset</li> <li>A problem template: a problem folder with some sensible defaults set that will   be used to bootstrap each problem based on this preset</li> <li>An environment: a configuration file that will be inherited by contests and problems   created from this preset, and that rbx will use to configure its execution environment</li> <li>A preset definition: a <code>preset.rbx.yml</code> file that will be used to define the preset   and its dependencies.</li> </ul>"},{"location":"setters/presets/#why-a-preset","title":"Why a preset?","text":"<p>Presets strongly encourage code reuse across different contests. Besides that, it provides a way to standardize the contest environment across different contests, making it easier for setters to focus on creating the contest instead of configuring the environment.</p> <p>Also, it makes it easier for setters to create new problems in a contest, offering a way for the head setter to define a starting point for the problem.</p> <p>Also, if the head setter wants to change the preset at some point, presets offer a way to synchronize the changes across all the problems and contests that use the preset.</p>"},{"location":"setters/presets/#creating-a-preset","title":"Creating a preset","text":"<p>Creating a preset is a multi-step process that starts when the head setter runs the <code>rbx preset create</code> command. By default, the command will create a new preset based on rbx default preset.</p> <pre><code>rbx presets create\n</code></pre> <p>The command will prompt you for the name of the preset, and a GitHub repository URI that can be used to reference to it.</p> <pre><code>\u2514\u2500\u2500 your-preset-name\n    \u251c\u2500\u2500 contest # (1)!\n    \u251c\u2500\u2500 problem # (2)!\n    \u251c\u2500\u2500 env.rbx.yml # (3)!\n    \u2514\u2500\u2500 preset.rbx.yml # (4)!\n</code></pre> <ol> <li>The contest template. This folder will be used to bootstrap each contest created from    this preset.</li> <li>A problem template. This folder will be used to bootstrap each problem created from    this preset.</li> <li>An environment file. This file will be used to configure the execution environment    of rbx to be used in the contest.</li> <li>A preset definition. This file will be used to define the preset and its dependencies.</li> </ol> <p>The GitHub URI will be an unique identifier of your preset, and can be used by other rbx users to fetch your preset from there if you decide to share it publicly.</p> <p>You can start from a preset of your own by specifying the <code>-p</code> flag.</p> <p>Tip</p> <p>If you want to start from a preset of your own, you can do so by specifying the <code>-p</code> flag.</p> <pre><code>rbx presets create -p your-base-preset\n</code></pre>"},{"location":"setters/presets/#setting-up-the-problem-template","title":"Setting up the problem template","text":"<p>You can go to the problem template and modify it to your liking: package structure, the <code>problem.rbx.yml</code> file, default testlib components, statement templates, etc. Everything can be customized to fulfill your requirements.</p> <p>Every problem created from this preset will be a clone of this folder, except for the folder name and the <code>name</code> field of the <code>problem.rbx.yml</code> file, which will be changed to match your problem name.</p> <p>Tip</p> <p>You can run rbx commands freely inside the problem template folder to test your template: any rbx internal folders will be ignored when inheriting from the preset.</p>"},{"location":"setters/presets/#setting-up-the-contest-template","title":"Setting up the contest template","text":"<p>You can go to the contest template and modify it to your liking: statement templates, <code>contest.rbx.yml</code> file, etc. Everything can be customized to fulfill your requirements.</p> <p>Usually, the contest template should have no problems initially. One should add problems with <code>rbx contest add</code> after the contest has been created.</p> <p>Every contest created from this preset will be a clone of this folder, except for the folder name and the <code>name</code> field of the <code>contest.rbx.yml</code> file, which will be changed to match your contest name.</p> <p>Tip</p> <p>You can run rbx commands freely inside the contest template folder to test your template: any rbx internal folders will be ignored when inheriting from the preset.</p>"},{"location":"setters/presets/#setting-up-the-environment","title":"Setting up the environment","text":"<p>The environment file will be used to configure the execution environment of rbx to be used in the contest.</p> <p>This file is rather complex, and its full reference documentation can be found here.</p> <p>You can usually get away with the environment used by the <code>default</code> preset, which is a good starting point for most contests. You can check its code here.</p>"},{"location":"setters/presets/#setting-up-the-preset-definition","title":"Setting up the preset definition","text":"<p>The preset definition file is a <code>preset.rbx.yml</code> file that will be used to define the preset and its dependencies.</p> <p>It can usually be broken down into a few sections, documented below for the default preset:</p> preset.rbx.yml<pre><code># The name of the preset.\nname: \"default\"\n\n# The URI of the preset. Usually, refers to a GitHub repository.\n# Here, refers to the \"rbx/resources/presets/default\" folder inside\n# the \"rsalesc/rbx\" repository.\nuri: \"rsalesc/rbx/rbx/resources/presets/default\"\n\n# The template to use for creating problems from this preset.\n# Refers to the `problem` folder in the preset definition.\nproblem: \"problem\"\n\n# The template to use for creating contests from this preset.\n# Refers to the `contest` folder in the preset definition.\ncontest: \"contest\"\n\n# The environment to use for the contest and problems created from this preset.\nenv: \"env.rbx.yml\"\n\n# Assets to be tracked and synced with the preset.\ntracking:\n  problem:\n    - path: \".gitignore\"\n    - path: \"statement/icpc.sty\"\n    - path: \"statement/template.rbx.tex\"\n  contest:\n    - path: \".gitignore\"\n    - path: \"statement/icpc.sty\"\n    - path: \"statement/template.rbx.tex\"\n    - path: \"statement/contest.rbx.tex\"\n      symlink: true\n</code></pre> <p>The first few sections are pretty self-explanatory. Let's focus on the <code>tracking</code> section.</p> <p>The <code>tracking</code> section describes a set of files that should be tracked by rbx when a problem or contest is created from this preset.</p> <p>If a file is tracked, it means that -- in theory -- it should be automatically synced with the preset. Let's say you have a <code>.tex</code> file that is imported by all the problems in your contest. Let's say your contest has 10 problems, but just now you realized you have to modify this <code>.tex</code> file to fix a typo.</p> <p>Usually, this would mean you have to repeat the same change in all 10 problems. With presets, you can just modify the <code>.tex</code> file in the preset definition, and run <code>rbx presets sync</code> inside your contest folder, as long as the file is tracked.</p> <p>This will sync all packages that use this preset with its newest changes, based on the set of tracked files. Files that are not tracked will not be synced.</p> <p>Tracked files can be specified both explicitly, or through Python-compliant glob patterns: <code>*.png</code>, <code>**/*.tex</code>, etc.</p>"},{"location":"setters/presets/#symlink-tracking","title":"Symlink tracking","text":""},{"location":"setters/presets/#flag-based-symlink-tracking","title":"Flag-based symlink tracking","text":"<p>When you know for sure that a file should always be kept in sync (without manual intervention), you can also create them as symlinks. Just mark the tracked file with the <code>symlink: true</code> flag, and rbx will create a symlink to the file in the package instead of copying it. Then, every modification you do to it will be instantly reflected in all other packages that use the preset.</p>"},{"location":"setters/presets/#soft-symlink-tracking","title":"Soft symlink tracking","text":"<p>An alternative way to create symlinks is to track files that are symlinks themselves. Let's suppose you have the following structure:</p> <pre><code>contest/\n\u251c\u2500\u2500 statement/\n\u2502   \u2514\u2500\u2500 icpc.sty -&gt; ../../common_icpc.sty\nproblem/\n\u2514\u2500\u2500 statement/\n    \u2514\u2500\u2500 icpc.sty -&gt; ../../common_icpc.sty\n\u2514\u2500\u2500 common_icpc.sty\n</code></pre> <p>In this case, you can track both <code>contest/statement/icpc.sty</code> and <code>problem/statement/icpc.sty</code> (no need for the <code>symlink: true</code> flag), and rbx will make sure to create a symlink to <code>common_icpc.sty</code> automagically for you.</p> <p>This approach is particularly useful when you want to share a common file between the contest and the problem packages.</p>"},{"location":"setters/presets/#using-a-preset","title":"Using a preset","text":"<p>Presets can be used both when creating a contest or when creating a problem. Below we detail all the commands where it can be used.</p> <pre><code># Create a contest from a preset.\nrbx contest create -p your-preset\n\n# Initialize a contest (in the current directory) from a preset.\nrbx contest init -p your-preset\n\n# Add a problem to a contest (that already has its own preset), using the very same preset.\nrbx contest add\n\n# Create a standalone problem from a preset.\nrbx create -p your-preset\n</code></pre> <p>In all variants above, a <code>.local.rbx</code> folder will be created at the root of the package. This folder stores a copy of the preset, snapshotted at the moment the package was created. This way, your package has its own copy of the preset, and you can either</p> <ol> <li>Modify it at will, and those changes will not be reflected in the original preset;</li> <li>Sync it to the original preset whenever you want.</li> </ol> <p>If you modify your <code>.local.rbx</code> folder, but has already created some problems inside your contest that you want to sync with the preset, you can do so by running <code>rbx presets sync</code> inside your contest folder.</p> <p>This will sync all packages that use this preset with its newest changes. In other words, it will create missing symlinks, and ask you if normal tracked files should be overridden or not.</p>"},{"location":"setters/presets/#sharing-a-preset-publicly","title":"Sharing a preset publicly","text":"<p>You can share your preset publicly by uploading it to a GitHub repository. If your repository is <code>&lt;your-organization&gt;/&lt;your-preset-name&gt;</code>, other uses can create a package from it by using</p> <pre><code>rbx contest create -p &lt;your-organization&gt;/&lt;your-preset-name&gt;\n</code></pre> <p>The preset will be cloned automatically, and then used as normal.</p>"},{"location":"setters/presets/#sharing-a-preset-privately","title":"Sharing a preset privately","text":"<p>You can share your preset privately, either through Git repositories or through other means. To initialize a contest from a private preset, you can do the following:</p> <pre><code>mkdir my-new-contest\ncd my-new-contest\n\n# Clone the preset into .local.rbx\ngit clone https://github.com/my-organization/my-preset .local.rbx\n\n# Initialize the contest\nrbx contest init\n</code></pre> <p>This will initialize the contest from the <code>.local.rbx</code> preset, which you can initialize from a private data source of your own.</p>"},{"location":"setters/reference/cli/","title":"CLI","text":"<p>TODO</p>"},{"location":"setters/reference/contest/","title":"Contest package","text":"<p>This documentation goes over how each field (or group of fields) in <code>contest.rbx.yml</code> works.</p>"},{"location":"setters/reference/contest/#contest-definition","title":"Contest definition","text":"<p>Schema: rbx.box.contest.schema.Contest</p> <p>The only required field of a contest is its <code>name</code>.</p> <p>A barebones package would look something like:</p> <pre><code>name: \"my-problem\"\n</code></pre>"},{"location":"setters/reference/contest/#contest-problem","title":"Contest problem","text":"<p>Schema: <code>List[</code><code>ContestProblem</code><code>]</code></p> <pre><code>name: \"my-contest\"\nproblems:\n  - short_name: \"A\"\n    path: \"A\"\n    color: \"ff0000\"\n  - short_name: \"B\"\n    path: \"B\"\n    color: \"00ff00\"\n</code></pre>"},{"location":"setters/reference/contest/schema/","title":"Contest schema","text":""},{"location":"setters/reference/contest/schema/#contestrbxyml","title":"<code>contest.rbx.yml</code>","text":""},{"location":"setters/reference/contest/schema/#rbx.box.contest.schema.Contest","title":"<code>Contest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of this contest.</p> required <code>problems</code> <code>List[ContestProblem]</code> <p>List of problems in this contest.</p> <code>[]</code> <code>statements</code> <code>List[ContestStatement]</code> <p>Configure statements in this contest, per language.</p> <code>None</code> <code>vars</code> <code>TypeAliasType</code> <p>Variables to be re-used across the package.</p> <code>{}</code> Source code in <code>rbx/box/contest/schema.py</code> <pre><code>class Contest(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    name: str = NameField(description='Name of this contest.')\n\n    problems: List[ContestProblem] = Field(\n        default=[], description='List of problems in this contest.'\n    )\n\n    statements: Annotated[\n        List[ContestStatement],\n        AfterValidator(is_unique_by_name),\n    ] = Field(\n        default=None,\n        description='Configure statements in this contest, per language.',\n    )\n\n    # Vars to be re-used in the statements.\n    #   - It will be available as \\VAR{vars} variable in the contest-level box statement.\n    vars: RecVars = Field(\n        default={}, description='Variables to be re-used across the package.'\n    )\n\n    @property\n    def expanded_statements(self) -&gt; List[ContestStatement]:\n        return expand_statements(self.statements)\n\n    @property\n    def expanded_vars(self) -&gt; Vars:\n        return expand_vars(self.vars)\n</code></pre>"},{"location":"setters/reference/contest/schema/#rbx.box.contest.schema.ContestProblem","title":"<code>ContestProblem</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>short_name</code> <code>str</code> <p>Short name of the problem. Usually, just an uppercase letter, but can be a sequence of uppercase letters followed by a number.</p> required <code>path</code> <code>Path | None</code> <p>Path to the problem relative to the contest package directory. If not specified, will expect the problem to be in ./{short_name}/ folder.</p> <code>None</code> <code>color</code> <code>str | None</code> <p>Color that represents this problem in the contest.</p> <p>Can be a hex color (#abcdef or #abc format), or a color name among available X11 colors.</p> <p>See https://en.wikipedia.org/wiki/X11_color_names for the list of supported color names.</p> <code>None</code> <code>colorName</code> <code>str | None</code> <p>A custom color name for the color provided by this problem.</p> <p>If not provided, will try to infer a color name from the color provided.</p> <code>None</code> Source code in <code>rbx/box/contest/schema.py</code> <pre><code>class ContestProblem(BaseModel):\n    short_name: str = ShortNameField(\n        description=\"\"\"\nShort name of the problem. Usually, just an uppercase letter,\nbut can be a sequence of uppercase letters followed by a number.\"\"\"\n    )\n    path: Optional[pathlib.Path] = Field(\n        default=None,\n        description=\"\"\"\nPath to the problem relative to the contest package directory.\nIf not specified, will expect the problem to be in ./{short_name}/ folder.\"\"\",\n    )\n\n    color: Optional[str] = Field(\n        default=None,\n        description=\"\"\"\nColor that represents this problem in the contest.\n\nCan be a hex color (#abcdef or #abc format), or a color name among available X11 colors.\n\nSee https://en.wikipedia.org/wiki/X11_color_names for the list of supported color names.\n\"\"\",\n    )\n\n    colorName: Optional[str] = Field(\n        default=None,\n        description=\"\"\"\nA custom color name for the color provided by this problem.\n\nIf not provided, will try to infer a color name from the color provided.\n\"\"\",\n        pattern=r'^[a-zA-Z]+$',\n    )\n\n    @model_validator(mode='after')\n    def check_color(self):\n        from colour import Color\n\n        if self.color is None:\n            return self\n\n        Color(self.color)\n        return self\n\n    @property\n    def hex_color(self) -&gt; Optional[str]:\n        from colour import Color\n\n        if self.color is None:\n            return None\n\n        return Color(self.color).hex_l\n\n    @property\n    def color_name(self) -&gt; Optional[str]:\n        if self.colorName is not None:\n            return self.colorName\n\n        if self.color is None:\n            return None\n\n        from colour import Color\n\n        color = Color(self.color)\n        web_color = color.web\n        if web_color.startswith('#'):\n            return 'unknown'\n        return web_color\n\n    def get_path(self) -&gt; pathlib.Path:\n        return self.path or pathlib.Path(self.short_name)\n</code></pre>"},{"location":"setters/reference/contest/schema/#rbx.box.contest.schema.ContestStatement","title":"<code>ContestStatement</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of this statement.</p> required <code>extends</code> <code>str | None</code> <p>Name of the statement to inherit from.</p> <code>None</code> <code>language</code> <code>str</code> <p>Language code for this statement (ISO 639-1).</p> <code>'en'</code> <code>title</code> <code>str</code> <p>Title of the contest in this language.</p> <code>''</code> <code>location</code> <code>str | None</code> <p>Location of the contest in this language.</p> <code>None</code> <code>date</code> <code>str | None</code> <p>Date of the contest in this language.</p> <code>None</code> <code>path</code> <code>Path</code> <p>Path to the input statement file.</p> <code>&lt;dynamic&gt;</code> <code>type</code> <code>StatementType</code> <p>Type of the input statement file.</p> <code>rbxTeX</code> <code>joiner</code> <code>JoinTexToPDF | None</code> <p>Joiner to be used to build the statement.</p> <p>This determines how problem statements will be joined into a single contest statement.</p> <code>None</code> <code>steps</code> <code>List[Union[TexToPDF, JinjaTeX, rbxToTeX, rbxMarkdownToTeX]]</code> <p>Describes a sequence of conversion steps that should be applied to the statement file of this contest.</p> <p>Usually, it is not necessary to specify these, as they can be inferred from the input statement type and the output statement type, but you can use this to force certain conversion steps to happen.</p> <code>[]</code> <code>configure</code> <code>List[Union[TexToPDF, JinjaTeX, rbxToTeX, rbxMarkdownToTeX]]</code> <p>Configure how certain conversion steps should happen when applied to the statement file of this contest.</p> <p>Different from the <code>steps</code> field, this does not force the steps to happen, but rather only configure them in case they are applied.</p> <code>[]</code> <code>assets</code> <code>List[str]</code> <p>Assets relative to the contest directory that should be included while building the statement. Files will be included in the same folder as the statement file. Can be glob pattern as well, such as <code>imgs/*.png</code>.</p> <code>[]</code> <code>override</code> <code>ProblemStatementOverride | None</code> <p>Override configuration for problem statements.</p> <code>None</code> <code>match</code> <code>str | None</code> <p>Name of the problem-level statement to match this statement against.</p> <p>If not specified, will match against the first statement of the same language.</p> <code>None</code> <code>vars</code> <code>TypeAliasType</code> <p>Variables to be re-used across the package.</p> <code>{}</code> Source code in <code>rbx/box/contest/schema.py</code> <pre><code>class ContestStatement(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    name: str = FNameField(description='Name of this statement.')\n\n    extends: Optional[str] = FNameField(\n        default=None, description='Name of the statement to inherit from.'\n    )\n\n    language: StatementLanguage = Field(\n        default='en', description='Language code for this statement (ISO 639-1).'\n    )\n\n    title: str = Field(default='', description='Title of the contest in this language.')\n\n    location: Optional[str] = Field(\n        default=None, description='Location of the contest in this language.'\n    )\n\n    date: Optional[str] = Field(\n        default=None, description='Date of the contest in this language.'\n    )\n\n    path: pathlib.Path = Field(\n        default_factory=pathlib.Path,\n        description='Path to the input statement file.',\n    )\n\n    type: StatementType = Field(\n        default=StatementType.rbxTeX, description='Type of the input statement file.'\n    )\n\n    joiner: Optional[Joiner] = Field(\n        default=None,\n        description=\"\"\"\nJoiner to be used to build the statement.\n\nThis determines how problem statements will be joined into a single contest statement.\"\"\",\n    )\n\n    steps: List[Annotated[ConversionStep, Field(discriminator='type')]] = Field(\n        default=[],\n        description=\"\"\"\nDescribes a sequence of conversion steps that should be applied to the statement file\nof this contest.\n\nUsually, it is not necessary to specify these, as they can be inferred from the\ninput statement type and the output statement type, but you can use this to force\ncertain conversion steps to happen.\n\"\"\",\n    )\n\n    configure: List[Annotated[ConversionStep, Field(discriminator='type')]] = Field(\n        default=[],\n        description=\"\"\"\nConfigure how certain conversion steps should happen when applied to the statement file of\nthis contest.\n\nDifferent from the `steps` field, this does not force the steps to happen, but rather only\nconfigure them in case they are applied.\n\"\"\",\n    )\n\n    assets: List[str] = Field(\n        default=[],\n        description=\"\"\"\nAssets relative to the contest directory that should be included while building\nthe statement. Files will be included in the same folder as the statement file.\nCan be glob pattern as well, such as `imgs/*.png`.\n\"\"\",\n    )\n\n    override: Optional[ProblemStatementOverride] = Field(\n        default=None, description='Override configuration for problem statements.'\n    )\n\n    match: Optional[str] = FNameField(\n        default=None,\n        description=\"\"\"\n        Name of the problem-level statement to match this statement against.\n\n        If not specified, will match against the first statement of the same language.\n        \"\"\",\n    )\n\n    # Vars to be re-used in the statement.\n    #   - It will be available as \\VAR{vars} variable in the contest-level box statement.\n    vars: RecVars = Field(\n        default={}, description='Variables to be re-used across the package.'\n    )\n\n    @property\n    def expanded_vars(self) -&gt; Vars:\n        return expand_vars(self.vars)\n</code></pre>"},{"location":"setters/reference/contest/schema/#rbx.box.contest.schema.ProblemStatementOverride","title":"<code>ProblemStatementOverride</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>configure</code> <code>List[Union[TexToPDF, JinjaTeX, rbxToTeX, rbxMarkdownToTeX]]</code> <p>Configure how certain conversion steps should happen when applied to the statement file.</p> <p>Different from the <code>steps</code> field, this does not force the steps to happen, but rather only configure them in case they are applied.</p> <code>[]</code> <code>vars</code> <code>Dict[str, Union[int, float, bool, str]]</code> <p>Variables to be merged into the problem statement vars.</p> <code>{}</code> Source code in <code>rbx/box/contest/schema.py</code> <pre><code>class ProblemStatementOverride(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    configure: List[Annotated[ConversionStep, Field(discriminator='type')]] = Field(\n        default=[],\n        description=\"\"\"\nConfigure how certain conversion steps should happen when applied to the statement file.\n\nDifferent from the `steps` field, this does not force the steps to happen, but rather only\nconfigure them in case they are applied.\n\"\"\",\n    )\n\n    vars: Dict[str, Primitive] = Field(\n        default={},\n        description='Variables to be merged into the problem statement vars.',\n    )\n</code></pre>"},{"location":"setters/reference/environment/","title":"Environment","text":"<p>An environment file is a YAML configuration file that describes the environment in which rbx will execute your code.</p> <p>The <code>Environment</code> class is used to describe the environment in which the code will be executed. You can follow the schema of this class to figure out everything you can configure in the environment file, but here we'll describe the most common fields.</p>"},{"location":"setters/reference/environment/#compilation-configuration","title":"Compilation configuration","text":"<p>You can define a few default settings for compilation by using the <code>defaultCompilation</code> field.</p> <p>You can look at the <code>CompilationConfig</code> class for more details of what you can do, but here's an example with a few useful settings:</p> <pre><code>defaultCompilation:\n  # Defines a few default limits when compiling in the sandbox.\n  sandbox:\n    timeLimit: 10000 # 10 seconds\n    wallTimeLimit: 10000 # 20 seconds\n    memoryLimit: 1024 # 1gb\n</code></pre> <p>Usually, the default values here are enough, but you can customize this for your needs. For instance, if you have a very slow computer at hand, you might want to increase the limits to ensure the compilers have the time to do their job.</p>"},{"location":"setters/reference/environment/#default-execution-configuration","title":"Default execution configuration","text":"<p>You can establish similar limits for code execution by using the <code>defaultExecution</code> field, by using the <code>ExecutionConfig</code> class.</p> <pre><code>defaultExecution:\n  # Defines a few default limits when running programs in the sandbox.\n  sandbox:\n    timeLimit: 10000 # 10 seconds\n    wallTimeLimit: 10000 # 20 seconds\n    memoryLimit: 1024 # 1gb\n</code></pre> <p>Notice these limits are language agnostic, and problem agnostic. This means you should set this to a value larger than any limit you expect for any problem. This is mostly used to ensure programs that eat too much memory or take too long to finish, but don't have limits applied to them, don't hang forever or crash your system. Examples are checkers, validators, etc.</p>"},{"location":"setters/reference/environment/#languages","title":"Languages","text":"<p>The <code>languages</code> field is used to define the languages supported by the environment. This is a list of <code>EnvironmentLanguage</code> objects, which you can look at the schema for more details.</p> <p>Here's an example of a language definition:</p> <pre><code>languages:\n  - name: \"cpp\" # (1)!\n    readableName: \"C++17\" # (2)!\n    extension: \"cpp\" # (3)!\n    compilation: # (4)!\n      commands:\n        - \"g++ -std=c++20 -O2 -o {executable} {compilable}\"\n    execution: # (5)!\n      command: \"./{executable}\"\n    fileMapping: # (6)!\n      compilable: \"compilable.cpp\"\n</code></pre> <ol> <li>The <code>name</code> field is the name of the language, which will be used to identify the language when    explicitly specifying the language of a solution or other code item in your packages.</li> <li>The <code>readableName</code> field is the name of the language as it will be displayed to you.</li> <li>The <code>extension</code> field identifies the extension of files that will be automatically inferred    to have been written in this language.</li> <li>The <code>compilation</code> field is a <code>CompilationConfig</code> object where    you can specify how code in this language should be compiled. Notice the use of the <code>{executable}</code> and <code>{compilable}</code> placeholders.</li> <li>The <code>execution</code> field is an <code>ExecutionConfig</code> object where    you can specify how code in this language should be executed.</li> <li>The <code>fileMapping</code> field is a <code>FileMapping</code> object where    you can specify how files should be named when copied into the sandbox. Notice you can refer to these    files by using the <code>{file}</code> placeholder in the <code>compilation</code> and <code>execution</code> fields.</li> </ol>"},{"location":"setters/reference/environment/#file-mapping","title":"File mapping","text":"<p>The <code>fileMapping</code> field is a <code>FileMapping</code> object where you can specify how files should be named when copied into the sandbox.</p> <p>Notice you can refer to these files by using the <code>{file}</code> placeholder in the <code>compilation</code> and <code>execution</code> fields when configuring new languages.</p> <p>Here's an example of a file mapping for the Java language, and how you would consume them in the <code>compilation</code> and <code>execution</code> fields:</p> <pre><code>languages:\n  - name: \"java\"\n    readableName: \"Java\"\n    extension: \"java\"\n    compilation:\n      commands:\n        - \"javac -Xlint -encoding UTF-8 {compilable}\"\n        - \"jar cvf {executable} @glob:*.class\"\n    execution:\n      command:\n        \"java -Xss100m -Xmx{{ memory }}m -Xms{{ initialMemory }}m -cp {executable}\n        Main\"\n    fileMapping:\n      compilable: \"Main.java\"\n      executable: \"Main.jar\"\n</code></pre> <p>Notice how we use the <code>{compilable}</code> and <code>{executable}</code> placeholders in the <code>compilation</code> and <code>execution</code> fields, and name them appropriately in the <code>fileMapping</code> field.</p>"},{"location":"setters/reference/environment/#command-variables","title":"Command variables","text":"<p>Also, notice you have a few variables that are available to you in the <code>compilation</code> and <code>execution</code> fields.</p> <ul> <li><code>{compilable}</code>: The path to the file that should be compiled.</li> <li><code>{executable}</code>: The path to the file that should be executed.</li> <li><code>{stdin}</code>: The path to the file that should be used as standard input.</li> <li><code>{stdout}</code>: The path to the file that should be used as standard output.</li> <li><code>{stderr}</code>: The path to the file that should be used as standard error.</li> <li><code>{{ memory }}</code>: The memory limit for the sandbox.</li> <li><code>{{ initialMemory }}</code>: The initial memory for the sandbox.</li> </ul> <p>And you also have available to you a <code>@glob:...</code> command that is expanded into a list of files that match the glob pattern. This is particularly useful for languages that need multiple files to be compiled or executed (such as Java in the example above).</p>"},{"location":"setters/reference/environment/#timing-estimation","title":"Timing estimation","text":"<p>Last but not least, you can configure a timing formula to be used when estimating time limits after running <code>rbx time</code> or <code>rbx run -t</code>.</p> <p>By default, the formula is <code>step_up(max(fastest * 3, slowest * 1.5), 100)</code>. The following variables/functions are available to you:</p> <ul> <li><code>fastest</code>: The time of the fastest solution among all AC solutions.</li> <li><code>slowest</code>: The time of the slowest solution among all AC solutions.</li> <li><code>step_up(value, step)</code>: Returns the value rounded up to the nearest multiple of <code>step</code>.</li> <li><code>step_down(value, step)</code>: Returns the value rounded down to the nearest multiple of <code>step</code>.</li> <li><code>max(a, b)</code>: Returns the maximum of <code>a</code> and <code>b</code>.</li> <li><code>min(a, b)</code>: Returns the minimum of <code>a</code> and <code>b</code>.</li> </ul> <p>You might specify a different formula by using the <code>timing</code> field:</p> <pre><code>timing:\n  formula: \"step_up(max(fastest * 2, slowest * 1.5), 100)\"\n</code></pre>"},{"location":"setters/reference/environment/schema/","title":"Environment schema","text":""},{"location":"setters/reference/environment/schema/#environment","title":"Environment","text":""},{"location":"setters/reference/environment/schema/#rbx.box.environment.BaseCompilationConfig","title":"<code>BaseCompilationConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>commands</code> <code>List[str] | None</code> <p>Commands to compile the program.</p> <code>[]</code> <code>sandbox</code> <code>EnvironmentSandbox | None</code> <p>Sandbox configuration to use when compiling for this language.</p> <code>None</code> <code>passthrough</code> <code>bool | None</code> <p>Whether to pass through the compilable as an executable file.</p> <code>None</code> Source code in <code>rbx/box/environment.py</code> <pre><code>class BaseCompilationConfig(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    commands: Optional[List[str]] = Field(\n        default=[],\n        description=\"\"\"Commands to compile the program.\"\"\",\n    )\n\n    sandbox: Optional[EnvironmentSandbox] = Field(\n        default=None,\n        description=\"\"\"Sandbox configuration to use when compiling for this language.\"\"\",\n    )\n\n    passthrough: Optional[bool] = Field(\n        default=None,\n        description=\"\"\"Whether to pass through the compilable as an executable file.\"\"\",\n    )\n</code></pre>"},{"location":"setters/reference/environment/schema/#rbx.box.environment.BaseExecutionConfig","title":"<code>BaseExecutionConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str | None</code> <p>Command to run the program.</p> <code>None</code> <code>sandbox</code> <code>EnvironmentSandbox | None</code> <p>Sandbox configuration to use when executing for this language.</p> <code>None</code> <code>problemLimits</code> <code>Limits</code> <p>Original limits of the problem.</p> <code>&lt;dynamic&gt;</code> Source code in <code>rbx/box/environment.py</code> <pre><code>class BaseExecutionConfig(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    command: Optional[str] = Field(\n        default=None,\n        description=\"\"\"Command to run the program.\"\"\",\n    )\n\n    sandbox: Optional[EnvironmentSandbox] = Field(\n        default=None,\n        description=\"\"\"Sandbox configuration to use when executing for this language.\"\"\",\n    )\n\n    problemLimits: Limits = Field(\n        default_factory=Limits,\n        description=\"\"\"Original limits of the problem.\"\"\",\n    )\n</code></pre>"},{"location":"setters/reference/environment/schema/#rbx.box.environment.CompilationConfig","title":"<code>CompilationConfig</code>","text":"<p>               Bases: <code>BaseCompilationConfig</code></p> <p>Parameters:</p> Name Type Description Default <code>solutionOverrides</code> <code>SolutionCompilationOverrides</code> <p>Overrides to apply when compiling solutions for this language.</p> <code>&lt;dynamic&gt;</code> Source code in <code>rbx/box/environment.py</code> <pre><code>class CompilationConfig(BaseCompilationConfig):\n    solutionOverrides: SolutionCompilationOverrides = Field(\n        default_factory=SolutionCompilationOverrides,\n        description=\"\"\"Overrides to apply when compiling solutions for this language.\"\"\",\n    )\n</code></pre>"},{"location":"setters/reference/environment/schema/#rbx.box.environment.Environment","title":"<code>Environment</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>defaultFileMapping</code> <code>FileMapping | None</code> <p>Default mapping for files within the sandbox. Fields in the mapping can be individually overridden in the language configuration.</p> <code>None</code> <code>defaultCompilation</code> <code>CompilationConfig | None</code> <p>Default compilation configuration to use when compiling programs. Fields in the compilation config can be individually overridden in the language configuration.</p> <code>None</code> <code>defaultExecution</code> <code>ExecutionConfig | None</code> <p>Default execution configuration to use when running programs. Fields in the execution config can be individually overridden in the language configuration.</p> <code>None</code> <code>languages</code> <code>List[EnvironmentLanguage]</code> <p>Configuration for each language supported in this environment.</p> <code>[]</code> <code>sandbox</code> <code>str</code> <p>Identifier of the sandbox used by this environment (e.g. \"stupid\")</p> <code>'stupid'</code> <code>timing</code> <code>TimingConfig</code> <p>Timing configuration for the environment.</p> <code>&lt;dynamic&gt;</code> <code>extensions</code> <code>Extensions | None</code> <p>Extensions to be added to the environment.</p> <code>None</code> <code>buildDir</code> <code>Path</code> <p>Directory to store the build files.</p> <code>PosixPath('build')</code> Source code in <code>rbx/box/environment.py</code> <pre><code>class Environment(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    defaultFileMapping: Optional[FileMapping] = Field(\n        default=None,\n        description=\"\"\"Default mapping for files within the sandbox. Fields in the mapping can be\nindividually overridden in the language configuration.\"\"\",\n    )\n\n    defaultCompilation: Optional[CompilationConfig] = Field(\n        default=None,\n        description=\"\"\"Default compilation configuration to use when compiling programs. Fields in\nthe compilation config can be individually overridden in the language configuration.\"\"\",\n    )\n\n    defaultExecution: Optional[ExecutionConfig] = Field(\n        default=None,\n        description=\"\"\"Default execution configuration to use when running programs. Fields in the\nexecution config can be individually overridden in the language configuration.\"\"\",\n    )\n\n    languages: List[EnvironmentLanguage] = Field(\n        default=[],\n        description=\"\"\"Configuration for each language supported in this environment.\"\"\",\n    )\n\n    sandbox: str = Field(\n        default='stupid',\n        description=\"\"\"Identifier of the sandbox used by this environment (e.g. \"stupid\")\"\"\",\n    )\n\n    timing: TimingConfig = Field(\n        default_factory=TimingConfig,\n        description=\"\"\"Timing configuration for the environment.\"\"\",\n    )\n\n    extensions: Optional[Extensions] = Field(\n        default=None,\n        description=\"\"\"Extensions to be added to the environment.\"\"\",\n    )\n\n    buildDir: pathlib.Path = Field(\n        default=pathlib.Path('build'),\n        description=\"\"\"Directory to store the build files.\"\"\",\n    )\n</code></pre>"},{"location":"setters/reference/environment/schema/#rbx.box.environment.EnvironmentLanguage","title":"<code>EnvironmentLanguage</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Identifier of this language within this environment.</p> required <code>readableName</code> <code>str | None</code> <p>Readable name for this language.</p> <code>None</code> <code>extension</code> <code>str</code> <p>File extension supported by this language. If there's only one language that supports a certain file extension in the environment, the tool will automatically identify the language based on such extension.</p> required <code>extraExtensions</code> <code>List[str]</code> <p>Extra file extensions supported by this language. If not specified, the tool will automatically identify the language based on such extensions.</p> <code>&lt;dynamic&gt;</code> <code>compilation</code> <code>CompilationConfig | None</code> <p>Compilation config to use when compiling programs for this language.</p> <code>None</code> <code>execution</code> <code>ExecutionConfig</code> <p>Execution config to use when running programs for this language.</p> required <code>fileMapping</code> <code>FileMapping | None</code> <p>Mapping for files within the sandbox. If not specified, the default mapping for the environment will be used.</p> <code>None</code> <code>extensions</code> <code>LanguageExtensions | None</code> <p>Extensions to apply for this language.</p> <code>None</code> Source code in <code>rbx/box/environment.py</code> <pre><code>class EnvironmentLanguage(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    name: str = Field(\n        description=\"\"\"Identifier of this language within this environment.\"\"\"\n    )\n\n    readableName: Optional[str] = Field(\n        default=None,\n        description=\"\"\"Readable name for this language.\"\"\",\n    )\n\n    extension: str = Field(\n        description=\"\"\"File extension supported by this language. If there's only one language\nthat supports a certain file extension in the environment, the tool\nwill automatically identify the language based on such extension.\"\"\"\n    )\n\n    extraExtensions: List[str] = Field(\n        default_factory=list,\n        description=\"\"\"Extra file extensions supported by this language. If not specified, the tool\nwill automatically identify the language based on such extensions.\"\"\",\n    )\n\n    compilation: Optional[CompilationConfig] = Field(\n        default=None,\n        description=\"\"\"Compilation config to use when compiling programs for this language.\"\"\",\n    )\n\n    execution: ExecutionConfig = Field(\n        description=\"\"\"Execution config to use when running programs for this language.\"\"\"\n    )\n\n    fileMapping: Optional[FileMapping] = Field(\n        default=None,\n        description=\"\"\"Mapping for files within the sandbox. If not specified, the default mapping\nfor the environment will be used.\"\"\",\n    )\n\n    extensions: Optional[LanguageExtensions] = Field(\n        default=None,\n        description=\"\"\"Extensions to apply for this language.\"\"\",\n    )\n\n    def get_extension(self, name: str, _: Type[T]) -&gt; Optional[T]:\n        if self.extensions is None:\n            return None\n        if not hasattr(self.extensions, name):\n            return None\n        return getattr(self.extensions, name)\n\n    def get_extension_or_default(self, name: str, cls: Type[T]) -&gt; T:\n        return self.get_extension(name, cls) or cls()\n</code></pre>"},{"location":"setters/reference/environment/schema/#rbx.box.environment.EnvironmentSandbox","title":"<code>EnvironmentSandbox</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>maxProcesses</code> <code>int | None</code> <p>Max. number of process to allow to run concurrently for the program.</p> <code>1</code> <code>timeLimit</code> <code>int | None</code> <p>Time limit in milliseconds to allow the program to run.</p> <code>None</code> <code>wallTimeLimit</code> <code>int | None</code> <p>Wall time limit in milliseconds to allow the program to run.</p> <code>None</code> <code>memoryLimit</code> <code>int | None</code> <p>Memory limit in MiB.</p> <code>None</code> <code>fileSizeLimit</code> <code>int | None</code> <p>File size limit in KiB</p> <code>None</code> <code>stackLimit</code> <code>int | None</code> <p>Stack limit in MiB.</p> <code>None</code> <code>preserveEnv</code> <code>bool | None</code> <p>Whether to preserve env. variables coming from the host.</p> <code>False</code> <code>mirrorDirs</code> <code>List[str] | None</code> <p>Directories in the host that should be read-only exposed to the sandbox.</p> <code>[]</code> Source code in <code>rbx/box/environment.py</code> <pre><code>class EnvironmentSandbox(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    maxProcesses: Optional[int] = Field(\n        default=1,\n        description=\"\"\"Max. number of process to allow to run concurrently for the program.\"\"\",\n    )\n\n    timeLimit: Optional[int] = Field(\n        default=None,\n        description=\"\"\"Time limit in milliseconds to allow the program to run.\"\"\",\n    )\n\n    wallTimeLimit: Optional[int] = Field(\n        default=None,\n        description=\"\"\"Wall time limit in milliseconds to allow the program to run.\"\"\",\n    )\n\n    memoryLimit: Optional[int] = Field(\n        default=None,\n        description=\"\"\"Memory limit in MiB.\"\"\",\n    )\n\n    fileSizeLimit: Optional[int] = Field(\n        default=None,\n        description=\"\"\"File size limit in KiB\"\"\",\n    )\n\n    stackLimit: Optional[int] = Field(\n        default=None,\n        description=\"\"\"Stack limit in MiB.\"\"\",\n    )\n\n    preserveEnv: Optional[bool] = Field(\n        default=False,\n        description=\"\"\"Whether to preserve env. variables coming from the host.\"\"\",\n    )\n\n    mirrorDirs: Optional[List[str]] = Field(\n        default=[],\n        description=\"\"\"Directories in the host that should be read-only exposed to the sandbox.\"\"\",\n    )\n</code></pre>"},{"location":"setters/reference/environment/schema/#rbx.box.environment.ExecutionConfig","title":"<code>ExecutionConfig</code>","text":"<p>               Bases: <code>BaseExecutionConfig</code></p> <p>Parameters:</p> Name Type Description Default <code>solutionOverrides</code> <code>SolutionExecutionOverrides</code> <p>Overrides to apply when executing solutions for this language.</p> <code>&lt;dynamic&gt;</code> Source code in <code>rbx/box/environment.py</code> <pre><code>class ExecutionConfig(BaseExecutionConfig):\n    solutionOverrides: SolutionExecutionOverrides = Field(\n        default_factory=SolutionExecutionOverrides,\n        description=\"\"\"Overrides to apply when executing solutions for this language.\"\"\",\n    )\n</code></pre>"},{"location":"setters/reference/environment/schema/#rbx.box.environment.FileMapping","title":"<code>FileMapping</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>str</code> <p>Path where to copy the stdin file to before running the program, relative to the sandbox root.</p> <code>'stdin'</code> <code>output</code> <code>str</code> <p>Path where to output the stdout file after running the program, relative to the sandbox root.</p> <code>'stdout'</code> <code>error</code> <code>str</code> <p>Path where to output the stderr file after running the program, relative to the sandbox root.</p> <code>'stderr'</code> <code>capture</code> <code>str</code> <p>Path where to output the capture file after running the program, relative to the sandbox root.</p> <code>'capture'</code> <code>compilable</code> <code>str</code> <p>Path where to copy the compilable file to before compiling the program, relative to the sandbox root.</p> <code>'{source}'</code> <code>executable</code> <code>str</code> <p>Path to where to output the executable file after compiling the program, relative to the sandbox root.</p> <code>'executable'</code> Source code in <code>rbx/box/environment.py</code> <pre><code>class FileMapping(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    input: str = Field(\n        default='stdin',\n        description=\"\"\"Path where to copy the stdin file to before running the program,\nrelative to the sandbox root.\"\"\",\n    )\n\n    output: str = Field(\n        default='stdout',\n        description=\"\"\"Path where to output the stdout file after running the program,\nrelative to the sandbox root.\"\"\",\n    )\n\n    error: str = Field(\n        default='stderr',\n        description=\"\"\"Path where to output the stderr file after running the program,\nrelative to the sandbox root.\"\"\",\n    )\n\n    capture: str = Field(\n        default='capture',\n        description=\"\"\"Path where to output the capture file after running the program,\nrelative to the sandbox root.\"\"\",\n    )\n\n    compilable: str = Field(\n        default='{source}',\n        description=\"\"\"Path where to copy the compilable file to before compiling the program,\nrelative to the sandbox root.\"\"\",\n    )\n\n    executable: str = Field(\n        default='executable',\n        description=\"\"\"Path to where to output the executable file after compiling the program,\nrelative to the sandbox root.\"\"\",\n    )\n</code></pre>"},{"location":"setters/reference/environment/schema/#rbx.box.environment.SolutionCompilationOverrides","title":"<code>SolutionCompilationOverrides</code>","text":"<p>               Bases: <code>BaseCompilationConfig</code></p> Source code in <code>rbx/box/environment.py</code> <pre><code>class SolutionCompilationOverrides(BaseCompilationConfig):\n    pass\n</code></pre>"},{"location":"setters/reference/environment/schema/#rbx.box.environment.SolutionExecutionOverrides","title":"<code>SolutionExecutionOverrides</code>","text":"<p>               Bases: <code>BaseExecutionConfig</code></p> Source code in <code>rbx/box/environment.py</code> <pre><code>class SolutionExecutionOverrides(BaseExecutionConfig):\n    pass\n</code></pre>"},{"location":"setters/reference/environment/schema/#rbx.box.environment.TimingConfig","title":"<code>TimingConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str</code> <p>Formula to use to calculate the time limit for the environment.</p> <code>'step_up(max(fastest * 3, slowest * 1.5), 100)'</code> Source code in <code>rbx/box/environment.py</code> <pre><code>class TimingConfig(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    formula: str = Field(\n        default='step_up(max(fastest * 3, slowest * 1.5), 100)',\n        description=\"\"\"Formula to use to calculate the time limit for the environment.\"\"\",\n    )\n</code></pre>"},{"location":"setters/reference/environment/schema/#extensions","title":"Extensions","text":""},{"location":"setters/reference/environment/schema/#rbx.box.extensions.Extensions","title":"<code>Extensions</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>boca</code> <code>BocaExtension | None</code> <p>Environment-level extensions for BOCA packaging.</p> <code>None</code> Source code in <code>rbx/box/extensions.py</code> <pre><code>class Extensions(BaseModel):\n    boca: Optional[BocaExtension] = Field(\n        default=None, description='Environment-level extensions for BOCA packaging.'\n    )\n</code></pre>"},{"location":"setters/reference/environment/schema/#rbx.box.extensions.LanguageExtensions","title":"<code>LanguageExtensions</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>boca</code> <code>BocaLanguageExtension | None</code> <p>Language-level extensions for BOCA packaging.</p> <code>None</code> Source code in <code>rbx/box/extensions.py</code> <pre><code>class LanguageExtensions(BaseModel):\n    boca: Optional[BocaLanguageExtension] = Field(\n        default=None, description='Language-level extensions for BOCA packaging.'\n    )\n</code></pre>"},{"location":"setters/reference/environment/schema/#boca","title":"BOCA","text":""},{"location":"setters/reference/environment/schema/#rbx.box.packaging.boca.extension.BocaExtension","title":"<code>BocaExtension</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>languages</code> <code>List[Literal[str, str, str, str, str, str, str]]</code> <code>['c', 'cpp', 'cc', 'kt', 'java', 'py2', 'py3']</code> <code>flags</code> <code>Dict[Literal[str, str, str, str, str, str, str], str]</code> <code>{}</code> <code>maximumTimeError</code> <code>float</code> <code>0.2</code> <code>preferContestLetter</code> <code>bool</code> <code>False</code> <code>usePypy</code> <code>bool</code> <code>False</code> Source code in <code>rbx/box/packaging/boca/extension.py</code> <pre><code>class BocaExtension(BaseModel):\n    languages: typing.List[BocaLanguage] = list(typing.get_args(BocaLanguage))\n    flags: typing.Dict[BocaLanguage, str] = {}\n    maximumTimeError: float = _MAX_REP_ERROR\n    preferContestLetter: bool = False\n    usePypy: bool = False\n\n    def flags_with_defaults(self) -&gt; typing.Dict[BocaLanguage, str]:\n        res: typing.Dict[BocaLanguage, str] = {\n            'c': '-std=gnu11 -O2 -lm -static',\n            'cpp': '-O2 -lm -static',\n            'cc': '-std=c++20 -O2 -lm -static',\n        }\n        res.update(self.flags)\n        return res\n</code></pre>"},{"location":"setters/reference/environment/schema/#rbx.box.packaging.boca.extension.BocaLanguageExtension","title":"<code>BocaLanguageExtension</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>bocaLanguage</code> <code>str | None</code> <code>None</code> Source code in <code>rbx/box/packaging/boca/extension.py</code> <pre><code>class BocaLanguageExtension(BaseModel):\n    # BocaLanguage this rbx language matches with.\n    bocaLanguage: typing.Optional[str] = None\n</code></pre>"},{"location":"setters/reference/package/","title":"Problem package","text":"<p>This documentation goes over how each field (or group of fields) in <code>problem.rbx.yml</code> works.</p>"},{"location":"setters/reference/package/#problem-definition","title":"Problem definition","text":"<p>Schema: rbx.box.schema.Package</p> <p>The three main required fields in a <code>problem.rbx.yml</code> package are:</p> <ul> <li><code>name</code>: supports anything matching the regex <code>^[a-zA-Z0-9\\-]+$</code></li> <li><code>timeLimit</code>: the time limit of your problem, in milliseconds.</li> <li><code>memoryLimit</code>: the memory limit of your problem, in megabytes.</li> </ul> <p>A barebones package would look something like:</p> <pre><code>name: \"test-problem\"\ntimeLimit: 1000  # 1 second TL\nmemoryLimit: 256  # 256 MB ML\n</code></pre>"},{"location":"setters/reference/package/#language-modifiers","title":"Language Modifiers","text":"<p>You can add extra language-based limit modifiers to problems.</p> <pre><code>name: \"test-problem\"\ntimeLimit: 1000  # 1 second TL\nmemoryLimit: 256  # 256 MB ML\nmodifiers:\n  java:\n    time: 2000  # 2 second TL for Java\n    memory: 512  # 512 MB ML for Java\n</code></pre>"},{"location":"setters/reference/package/#task-type","title":"Task Type","text":"<p>Field: <code>type</code> Schema: rbx.box.schema.TaskType</p> <p>You can use this (optional) field to specify the type of your problem. If you're building an interactive problem, for instance, you should set this to <code>COMMUNICATION</code>, otherwise the default <code>BATCH</code> will be used.</p> <pre><code>name: \"interactive-problem\"\ntype: COMMUNICATION\ntimeLimit: 1000  # 1 second TL\nmemoryLimit: 256  # 256 MB ML\n</code></pre>"},{"location":"setters/reference/package/#variables","title":"Variables","text":"<p>Field: <code>vars</code> Schema: <code>Dict[str, Union[str, int, float, bool]]</code></p> <p>In the package definition you can define variables that can be referenced in statements, validators, checkers, interactors and stress tests.</p> <p>This is useful to maintain consistency when changing constraints of your problem. A common mistake this field tries to solve is changing constraints in the statement, but not updating them in the other components.</p> <pre><code>vars:\n  N:\n    max: 10000\n  A:\n    max: 100000\n  MOD: py`10**9+7` # Backticks force the var to be evaluated as a Python expression.\n</code></pre> <p>rbx automatically generates an <code>rbx.h</code> header file in the root of your package that you can include in your code to read these variables.</p> <pre><code>#include \"rbx.h\"\n\nint main() {\n  int MAX_N = getVar&lt;int&gt;(\"N.max\");\n  // Rest of your code...\n}\n</code></pre> <p>If you're not using C++ for your components, consider doing so as the rbx experience is tightly integrated with testlib.</p> <p>If not, you can still use the variables in validators, see the Validators section for more information.</p> <p>Warning</p> <p>Refrain from using variables in generators. Although it is tempting to use <code>rbx.h</code> in there, it is not recommended to do so.</p> <p>Read more on the Generators section.</p> <p>Note</p> <p>Variable names should be valid Python identifiers.</p>"},{"location":"setters/reference/package/#checker","title":"Checker","text":"<p>Field: <code>checker</code> Schema: rbx.box.schema.CodeItem</p> <p>Checkers are also a very important part of your problem package, and define how the output of a solution will be judged.</p> <p>The checker is controlled through the top-level parameter <code>checker</code>, and is optional. In the case it is not specified, rbx falls back to testlib's wcmp.cpp, which is a token-based checker that compares the output of the solution with the expected answer. In case of interactive problems, a checker is not required.</p> <p>rbx is tightly integrated with testlib, and thus you can either specify:</p> <ol> <li> <p>The name of any checker in defined in testlib's checkers folder. The checker will be automatically downloaded when running solutions and building the package.</p> <pre><code>checker:\n  path: \"yesno.cpp\"\n</code></pre> <p>Tip</p> <p>If you want to explicitly download a checker from testlib, you can run <code>rbx download checker [name-of-the-checker]</code>.</p> </li> <li> <p>A custom testlib-based checker of your own, placed in the folder (or any sub-folder) of your package.</p> <pre><code>checker:\n  path: \"my-testlib-based-checker.cpp\"\n</code></pre> <p>Tip</p> <p>rbx automatically places <code>testlib.h</code> together with your code when compiling it, but you can explicitly download it with <code>rbx download testlib</code> if you want.</p> <p>Recommended</p> <p>This is usually the recommended solution when building a custom checker, as rbx provides a clear integration with testlib and you can use include <code>rbx.h</code> in your checker to read variables.</p> </li> <li> <p>A custom checker (not necessarily using testlib). It can even be in other language, in which case we suggest specifying the <code>language</code> property.</p> <pre><code>checker:\n  path: \"my-custom-checker.py\"\n  language: \"python\"\n</code></pre> <p>Warning</p> <p>Currently, it is not possible to use variables in custom checkers not written in C++.</p> <p>Note</p> <p>Although this is not a testlib-based checker, we still expect checker programs to follow the same command line structure as testlib, which is receiving and reading three file paths from the command line.</p> <p>Thus, your checker program will be called as <code>&lt;program&gt; &lt;input-file&gt; &lt;output-file&gt; &lt;expected-answer-file&gt;</code>.</p> </li> </ol>"},{"location":"setters/reference/package/#interactor","title":"Interactor","text":"<p>Field: <code>interactor</code> Schema: rbx.box.schema.Interactor</p> <p>You can specify an interactor for your problem, or leave this field empty for non-interactive problems.</p> <pre><code>interactor:\n  path: \"my-interactor.cpp\"\n</code></pre> <p>According to the ICPC package specification, used by the ICPC World Finals, interactors cannot be specified together with a checker, and an error will be thrown if both are present.</p> <p>rbx enforces this rule, but supports interactive problems with a checker if you set the <code>legacy</code> flag in the interactor definition.</p> <pre><code>interactor:\n  path: \"my-interactor.cpp\"\n  legacy: true\n</code></pre> <p>Danger</p> <p>rbx currently only supports testlib-based interactors. If you do not use a testlib-based interactor, rbx will not complain but might behave unexpectedly.</p> <p>Warning</p> <p>Notice that a few judges do not support interactors with a checker, and an error will be thrown if you try to build a package for an unsupported judge with both components specified.</p>"},{"location":"setters/reference/package/#generators","title":"Generators","text":"<p>Field: <code>generators</code> Schema: <code>List[</code><code>Generator</code><code>]</code></p> <p>You can also specify a set of testcase generators that can be re-used in different places in your package (testgroup generation, stress tests to name a couple).</p> <p>Again, we encourage the use of testlib-based generators, but give you the flexibility to develop however you like.</p> <p>After implementing a generator, you can define it in <code>problem.rbx.yml</code> similar to how you define a checker, but you also have to name it to be able to reference it down the line.</p> <pre><code>generators:\n  - name: \"gen\"\n    path: \"my-gen.cpp\"\n</code></pre> <p>Notice also how the <code>generators</code> field is a list, and as such you can define multiple generators.</p> <p>Danger</p> <p>Refrain from using Variables in generators. Although it is tempting to depend on them, it is not a good practice.</p> <p>This will make your generator sensible to the changes you make to the <code>vars</code> field, meaning if you found a testcase that breaks a specific solution, but it depends on a <code>vars</code> entry and you change it, you might end up with a totally different test. Instead, you should be able to describe all your generator parameters through static variables.</p>"},{"location":"setters/reference/package/#solutions","title":"Solutions","text":"<p>Field: <code>solutions</code> Schema: <code>List[</code><code>Solution</code><code>]</code></p> <p>You can specify multiple solutions to your problem, including incorrect ones to check that your testset is strong enough.</p> <p>You can define them similarly to generators and checkers, but you also have to provide an expected outcome for them.</p> <pre><code>solutions:\n  - path: \"sols/main.cpp\"\n    outcome: accepted\n  - path: \"sols/slow.cpp\"\n    outcome: tle\n  - path: \"sols/wa.cpp\"\n    outcome: wa\n</code></pre> <p>Also, you have to define an accepted solution. The first accepted solution in this list will be considered the main solution to generate answers for the testcases.</p> <p>For a full list of expected outcomes, see here.</p>"},{"location":"setters/reference/package/#testcase-groups","title":"Testcase groups","text":"<p>Field: <code>testcases</code> Schema: <code>List[</code><code>TestcaseGroup</code><code>]</code></p> <p>You can define multiple testgroups for you problem. For each testgroup, you can define tests for it in five (5) different ways:</p> <ol> <li> <p>Specifying a sequence of manually defined testcases present in your package's directory with the <code>testcases</code> field.</p> <pre><code>testcases:\n  - name: \"group-1\"\n    testcases:\n      - inputPath: \"manual-tests/1.in\"\n        outputPath: \"manual-tests/1.ans\"\n      - inputPath: \"manual-tests/1.in\"\n</code></pre> <p>Note</p> <p>Notice how the <code>outputPath</code> is optional. If it is not defined, the main solution will be used to generate an output. This is the recommended approach.</p> </li> <li> <p>Specifying a glob of input paths with the <code>testcaseGlob</code> field.</p> <pre><code>testcases:\n  - name: \"group-1\"\n    testcaseGlob: \"tests/*.in\" # (1)!\n</code></pre> <ol> <li>Pick all files ending in <code>.in</code> inside the <code>tests/</code> folder as test inputs for     the testgroup. The files are taken in lexicographically increasing order.</li> </ol> </li> <li> <p>Specifying a list of generator calls with the <code>generators</code> field.</p> <pre><code>testcases:\n  - name: \"generated\"\n    generators:\n      - name: \"gen1\"\n        args: \"1000 30\"\n      - name: \"gen1\"\n        args: \"1000 42\"\n</code></pre> </li> <li> <p>Specifying a static generator script with the <code>generatorScript</code> field:</p> problem.rbx.ymlscript.txt <pre><code>testcases:\n  - name: \"generated\"\n    generatorScript:\n      path: \"script.txt\"\n</code></pre> <pre><code>gen 1000 30\ngen 1000 42\n# ...other tests\n</code></pre> <p>Note</p> <p>The <code>.txt</code> extension is necessary for rbx to identify this is a static script.</p> <p>Recommended</p> <p>This is usually the recommended approach to generate a few pre-defined testcases. Prefer this over the <code>generators</code> call to keep <code>problem.rbx.yml</code> cleaner.</p> </li> <li> <p>Specifying a dynamic generator script with the <code>generatorScript</code> field:</p> problem.rbx.ymlscript.py <pre><code>testcases:\n  - name: \"generated\"\n    generatorScript:\n      path: \"script.py\"\n</code></pre> <pre><code># Generates 10 different cases with different parameters.\nfor i in range(10):\n  print(f'gen 1000 {i}')\n</code></pre> <p>Recommended</p> <p>This is usually the recommended approach to generate multiple random testcases.</p> </li> </ol> <p>Warning</p> <p>If the platform you package the problem for does not support testgroups, tests will be flattened into a single group, and the tests will be executed in the order the groups were defined.</p>"},{"location":"setters/reference/package/#samples","title":"Samples","text":"<p>You can also specify samples to be included in your statement by defining a testgroup named <code>samples</code>. This testgroup has to be the first one defined, otherwise an error will be raised.</p>"},{"location":"setters/reference/package/#validators","title":"Validators","text":"<p>Field: <code>validator</code>, <code>testcases.validator</code> Schema: rbx.box.schema.CodeItem</p> <p>You can specify testlib validators that check whether both manual and generated testcases are in the correct format.</p> <p>You can specify validators in two places:</p> <ol> <li> <p>In the package definition, through the <code>validator</code> field.</p> <pre><code>validator:\n  path: \"validator.cpp\"\n</code></pre> </li> <li> <p>In the testgroup definition, through the <code>validator</code> field, in which case this validator will be executed only for this group, and the package one will be ignored.</p> <pre><code>validator:\n  path: \"validator.cpp\"\ntestcases:\n  - name: \"group-with-usual-constraints\"\n    # ...other testgroup definitions\n  - name: \"group-with-different-constraints\"\n    # ...other testgroup definitions\n    validator:\n      path: \"validator-alternative.cpp\"\n</code></pre> </li> </ol> <p>You can pass variables to validators in two different ways.</p> <ol> <li> <p>(C++ only) Include the <code>rbx.h</code> header and using the <code>getVar</code> accessor.</p> <pre><code>#include \"testlib.h\"\n#include \"rbx.h\"\n\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n\n    int MAX_N = getVar&lt;int&gt;(\"N.max\"); // Read from package vars.\n\n    inf.readInt(1, MAX_N, \"N\");\n    inf.readEoln();\n    inf.readEof();\n}\n</code></pre> <p>This header is automatically generated at your problem's root directory by rbx.</p> <p>Recommended</p> <p>This is the recommended approach of passing variables to validators.</p> </li> <li> <p>Read the variables from the command line.</p> <p>rbx passes all the variables defined in the <code>vars</code> section to the validator through <code>--{name}={value}</code> parameters. You are responsible for writing code to parse them.</p> <pre><code>import sys\n\nvariables = {}\n\nfor arg in sys.argv[1:]:\n  if arg.startswith('--') and '=' in arg:\n    name, value = arg[2:].split('=', 1)\n    variables[name] = value\n\n# Use variables...\n</code></pre> </li> </ol>"},{"location":"setters/reference/package/#extra-validators","title":"Extra validators","text":"<p>You can also specify extra validators to be used in your testcases, both at the problem-level and testgroup-level.</p> <pre><code>validator:\n  path: \"validator.cpp\"\ntestcases:\n  - name: \"group-1\"\n    # ...other testgroup definitions\n  - name: \"group-2-without-solution\"\n    # a group whose testcases don't have a solution\n    extraValidators:\n      - path: \"validator-no-solution.cpp\"\n</code></pre>"},{"location":"setters/reference/package/#stress-tests","title":"Stress tests","text":"<p>Field: <code>stresses</code> Schema: <code>List[</code><code>Stress</code><code>]</code></p> <p>You can pre-define stress tests with a few applications in mind, such as:</p> <ul> <li>Finding testcases that break incorrect solutions;</li> <li>Ensuring solutions you expect to be correct cannot be broken.</li> </ul> <p>Let's break down each field in the stress test below:</p> <pre><code>stresses:\n  - name: \"stress1\"\n    generator:\n      name: \"gen\"\n      args: \"--N.max=[1..1000] @\"\n    finder: \"[sols/wa.cpp] ~ INCORRECT\"\n</code></pre> <ul> <li><code>name</code>: a name for the stress test. Useful when calling this test through <code>rbx stress [name]</code>.</li> <li><code>generator</code>: a generator expression to be repeatedly evaluated in this stress test.</li> <li><code>name</code>: the name of the generator</li> <li><code>args</code>: args pattern to be passed to generator.<ul> <li>You can pass a random integer by writing something like <code>[1..1000]</code>.</li> <li>You can pass variables defined in the <code>vars</code> section with something like <code>&lt;N.max&gt;</code>.</li> <li>You can pass a random choice by writing something like <code>(a|b|c)</code>.</li> <li>You can pass a random hex string by passing <code>@</code>.</li> </ul> </li> <li><code>finder</code>: a finder expression that, when evaluated to true, consider the given generated test as a match</li> </ul>"},{"location":"setters/reference/package/#unit-tests","title":"Unit tests","text":"<p>Field: <code>unitTests</code> Schema: <code>UnitTests</code></p> <p>You can specify unit tests for your validator and your checker through the <code>unitTests</code> field.</p> <pre><code>unitTests:\n  validator:\n    - glob: \"unit/validator/valid_*.in\"  # (1)!\n      outcome: VALID\n    - glob: \"unit/validator/invalid_*.in\"  # (2)!\n      outcome: INVALID\n  checker: \n    - glob: \"unit/checker/ac*\"  # (3)!\n      outcome: ACCEPTED\n    - glob: \"unit/checker/wa*\"\n      outcome: WRONG_ANSWER\n</code></pre> <ol> <li> <p>Specify a glob to match manually crafted input files that when validated should be considered valid.</p> </li> <li> <p>Specify a glob to match manually crafted input files that when validated should be considered INVALID.</p> </li> <li> <p>Specify a glob to match files named <code>unit/checker/ac*(.in|.out|.ans)</code> that when checked should be considered ACCEPTED.</p> </li> </ol> <p>Validator globs are really simple: they should match <code>.in</code> files relative to the problem root directory. Those files will be passed to the validator program and validated.</p> <p>Checker globs are a bit more complex, since they accept three different parameters:</p> <ul> <li>A <code>.in</code> file, the input for the testcase;</li> <li>A <code>.out</code> file, the output of the participant's program;</li> <li>A <code>.ans</code> file, the output of the main solution.</li> </ul> <p>Thus, to test a checker, you should provide a subset of these three (3) files. The checker unit test definition expects a glob that matches the names of these three files. Thus, the glob <code>unit/checker/ac*</code> will match, for instance, <code>unit/checker/ac.in</code>, <code>unit/checker/ac.out</code> and <code>unit/checker/ac.ans</code>.</p> <p>Not all three files must exist, only those required by the checker.</p>"},{"location":"setters/reference/package/schema/","title":"Problem schema","text":""},{"location":"setters/reference/package/schema/#problemrbxyml","title":"<code>problem.rbx.yml</code>","text":""},{"location":"setters/reference/package/schema/#rbx.box.schema.Checker","title":"<code>Checker</code>","text":"<p>               Bases: <code>CodeItem</code></p> <p>Parameters:</p> Name Type Description Default <code>fallback_to</code> <code>Checker | None</code> <p>Checker to fall back to if the mainly specified checker does not exist.</p> <code>None</code> <code>mode</code> <code>Literal[str, str]</code> <p>In which compatibility mode the checker should be run.</p> <code>'testlib'</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class Checker(CodeItem):\n    model_config = ConfigDict(extra='forbid')\n\n    fallback_to: Optional[Checker] = Field(\n        default=None,\n        description=\"\"\"Checker to fall back to if the mainly specified checker does not exist.\"\"\",\n    )\n\n    mode: Literal['testlib', 'boca'] = Field(\n        default='testlib',\n        description=\"\"\"In which compatibility mode the checker should be run.\"\"\",\n    )\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.CheckerTest","title":"<code>CheckerTest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>glob</code> <code>str</code> <p>A glob pattern for the files to be used as unit test input for the checker. This glob should simultaneously match the input, output, and answer files (.in, .out, .ans). If one of them is not present, an empty file will be used instead.</p> required <code>outcome</code> <code>ExpectedOutcome</code> <p>The expected outcome of the checker.</p> <code>ACCEPTED</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class CheckerTest(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    glob: str = Field(\n        description=\"\"\"\nA glob pattern for the files to be used as unit test input for the checker.\nThis glob should simultaneously match the input, output, and answer files (.in, .out, .ans).\nIf one of them is not present, an empty file will be used instead.\n\"\"\",\n    )\n\n    outcome: ExpectedOutcome = Field(\n        default=ExpectedOutcome.ACCEPTED,\n        description='The expected outcome of the checker.',\n    )\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.CodeItem","title":"<code>CodeItem</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the code file, relative to the package directory.</p> required <code>language</code> <code>str | None</code> <p>The language of the code file.</p> <code>None</code> <code>compilationFiles</code> <code>List[str] | None</code> <p>Extra files that should be placed alongside the code file during its compilation, such as testlib.h, jngen.h, etc.</p> <p>The paths should be given relative to the package directory, but will be included relative to the <code>path</code> directory.</p> <p>Testlib and jngen are already included by default.</p> <code>[]</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class CodeItem(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    path: pathlib.Path = Field(\n        description=\"\"\"The path to the code file, relative to the package directory.\"\"\"\n    )\n\n    language: Optional[str] = Field(\n        default=None, description=\"\"\"The language of the code file.\"\"\"\n    )\n\n    compilationFiles: Optional[List[str]] = Field(\n        default=[],\n        description=\"\"\"\nExtra files that should be placed alongside the code file during its compilation,\nsuch as testlib.h, jngen.h, etc.\n\nThe paths should be given relative to the package directory, but will be included\nrelative to the `path` directory.\n\nTestlib and jngen are already included by default.\n\"\"\",\n    )\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome","title":"<code>ExpectedOutcome</code>","text":"<p>               Bases: <code>AutoEnum</code></p> Source code in <code>rbx/box/schema.py</code> <pre><code>class ExpectedOutcome(AutoEnum):\n    ANY = alias('any')  # type: ignore\n    \"\"\"Expected outcome for any outcome.\"\"\"\n\n    ACCEPTED = alias('accepted', 'ac', 'correct')  # type: ignore\n    \"\"\"Expected outcome for correct solutions (AC).\"\"\"\n\n    ACCEPTED_OR_TLE = alias(\n        'accepted or time limit exceeded',\n        'accepted or tle',\n        'ac or tle',\n        'ac/tle',\n        'ac+tle',\n    )  # type: ignore\n    \"\"\"Expected outcome for solutions that finish with either AC or TLE.\n\n    Especially useful when you do not care about the running time of this solution, and\n    want it to not be considered when calculating the timelimit for the problem.\"\"\"\n\n    WRONG_ANSWER = alias('wrong answer', 'wa')  # type: ignore\n    \"\"\"Expected outcome for solutions that finish successfully,\n    but the produced output are incorrect (WA).\"\"\"\n\n    INCORRECT = alias('fail', 'incorrect')  # type: ignore\n    \"\"\"Expected outcome for solutions that finish with any non-AC verdict.\"\"\"\n\n    RUNTIME_ERROR = alias('runtime error', 'rte', 're')  # type: ignore\n    \"\"\"Expected outcome solutions that finish with non-zero code (RTE).\"\"\"\n\n    TIME_LIMIT_EXCEEDED = alias('time limit exceeded', 'timeout', 'tle', 'tl')  # type: ignore\n    \"\"\"Expected outcome for solutions that do not finish in time.\"\"\"\n\n    MEMORY_LIMIT_EXCEEDED = alias('memory limit exceeded', 'mle', 'ml')  # type: ignore\n    \"\"\"Expected outcome for solutions that use more memory than allowed.\"\"\"\n\n    OUTPUT_LIMIT_EXCEEDED = alias('output limit exceeded', 'ole', 'ol')  # type: ignore\n    \"\"\"Expected outcome for solutions that use more output than allowed.\"\"\"\n\n    TLE_OR_RTE = alias('tle or rte', 'tle/rte', 'tle+rte', 'tle or re', 'tle+re')  # type: ignore\n    \"\"\"Expected outcome for solutions that finish with either TLE or RTE.\n\n    Especially useful for environments where TLE and RTE are indistinguishable.\"\"\"\n\n    JUDGE_FAILED = alias('judge failed', 'jf')  # type: ignore\n    \"\"\"Expected outcome for solutions that finish with a judge failed verdict.\n\n    Only useful for checker tests.\"\"\"\n\n    def style(self) -&gt; str:\n        if self == ExpectedOutcome.ANY:\n            return 'orange'\n        if self == ExpectedOutcome.ACCEPTED:\n            return 'green'\n        if self == ExpectedOutcome.WRONG_ANSWER:\n            return 'red'\n        if self == ExpectedOutcome.INCORRECT:\n            return 'red'\n        if self.match(Outcome.TIME_LIMIT_EXCEEDED):\n            return 'yellow'\n        if self.match(Outcome.RUNTIME_ERROR):\n            return 'blue'\n        if self.match(Outcome.MEMORY_LIMIT_EXCEEDED):\n            return 'yellow'\n        return 'magenta'\n\n    def is_slow(self) -&gt; bool:\n        return self in [ExpectedOutcome.TIME_LIMIT_EXCEEDED, ExpectedOutcome.TLE_OR_RTE]\n\n    def matches_tle_and_is_incorrect(self) -&gt; bool:\n        return self.match(Outcome.TIME_LIMIT_EXCEEDED) and not self.match(\n            Outcome.ACCEPTED\n        )\n\n    def match(self, outcome: Outcome) -&gt; bool:\n        if self == ExpectedOutcome.ANY:\n            return True\n        if self == ExpectedOutcome.ACCEPTED:\n            return outcome == Outcome.ACCEPTED\n        if self == ExpectedOutcome.ACCEPTED_OR_TLE:\n            return outcome in {Outcome.ACCEPTED} or outcome.is_slow()\n        if self == ExpectedOutcome.WRONG_ANSWER:\n            return outcome == Outcome.WRONG_ANSWER\n        if self == ExpectedOutcome.INCORRECT:\n            return (\n                outcome\n                in {\n                    Outcome.WRONG_ANSWER,\n                    Outcome.RUNTIME_ERROR,\n                    Outcome.MEMORY_LIMIT_EXCEEDED,\n                    Outcome.OUTPUT_LIMIT_EXCEEDED,\n                }\n                or outcome.is_slow()\n            )\n        if self == ExpectedOutcome.RUNTIME_ERROR:\n            return outcome == Outcome.RUNTIME_ERROR\n        if self == ExpectedOutcome.TIME_LIMIT_EXCEEDED:\n            return outcome.is_slow()\n        if self == ExpectedOutcome.MEMORY_LIMIT_EXCEEDED:\n            return outcome == Outcome.MEMORY_LIMIT_EXCEEDED\n        if self == ExpectedOutcome.TLE_OR_RTE:\n            return outcome in {Outcome.RUNTIME_ERROR} or outcome.is_slow()\n        if self == ExpectedOutcome.OUTPUT_LIMIT_EXCEEDED:\n            return outcome == Outcome.OUTPUT_LIMIT_EXCEEDED\n        if self == ExpectedOutcome.JUDGE_FAILED:\n            return outcome == Outcome.JUDGE_FAILED\n        return False\n\n    def get_matches(self) -&gt; List[Outcome]:\n        return [outcome for outcome in Outcome if self.match(outcome)]\n\n    def intersect(self, rhs: 'ExpectedOutcome') -&gt; bool:\n        return bool(set(self.get_matches()) &amp; set(rhs.get_matches()))\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome.ACCEPTED","title":"<code>ACCEPTED = alias('accepted', 'ac', 'correct')</code>","text":"<p>Expected outcome for correct solutions (AC).</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome.ACCEPTED_OR_TLE","title":"<code>ACCEPTED_OR_TLE = alias('accepted or time limit exceeded', 'accepted or tle', 'ac or tle', 'ac/tle', 'ac+tle')</code>","text":"<p>Expected outcome for solutions that finish with either AC or TLE.</p> <p>Especially useful when you do not care about the running time of this solution, and want it to not be considered when calculating the timelimit for the problem.</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome.ANY","title":"<code>ANY = alias('any')</code>","text":"<p>Expected outcome for any outcome.</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome.INCORRECT","title":"<code>INCORRECT = alias('fail', 'incorrect')</code>","text":"<p>Expected outcome for solutions that finish with any non-AC verdict.</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome.JUDGE_FAILED","title":"<code>JUDGE_FAILED = alias('judge failed', 'jf')</code>","text":"<p>Expected outcome for solutions that finish with a judge failed verdict.</p> <p>Only useful for checker tests.</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome.MEMORY_LIMIT_EXCEEDED","title":"<code>MEMORY_LIMIT_EXCEEDED = alias('memory limit exceeded', 'mle', 'ml')</code>","text":"<p>Expected outcome for solutions that use more memory than allowed.</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome.OUTPUT_LIMIT_EXCEEDED","title":"<code>OUTPUT_LIMIT_EXCEEDED = alias('output limit exceeded', 'ole', 'ol')</code>","text":"<p>Expected outcome for solutions that use more output than allowed.</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome.RUNTIME_ERROR","title":"<code>RUNTIME_ERROR = alias('runtime error', 'rte', 're')</code>","text":"<p>Expected outcome solutions that finish with non-zero code (RTE).</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome.TIME_LIMIT_EXCEEDED","title":"<code>TIME_LIMIT_EXCEEDED = alias('time limit exceeded', 'timeout', 'tle', 'tl')</code>","text":"<p>Expected outcome for solutions that do not finish in time.</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome.TLE_OR_RTE","title":"<code>TLE_OR_RTE = alias('tle or rte', 'tle/rte', 'tle+rte', 'tle or re', 'tle+re')</code>","text":"<p>Expected outcome for solutions that finish with either TLE or RTE.</p> <p>Especially useful for environments where TLE and RTE are indistinguishable.</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome.WRONG_ANSWER","title":"<code>WRONG_ANSWER = alias('wrong answer', 'wa')</code>","text":"<p>Expected outcome for solutions that finish successfully, but the produced output are incorrect (WA).</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.Generator","title":"<code>Generator</code>","text":"<p>               Bases: <code>CodeItem</code></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the generator.</p> required Source code in <code>rbx/box/schema.py</code> <pre><code>class Generator(CodeItem):\n    model_config = ConfigDict(extra='forbid')\n\n    name: str = Field(description=\"\"\"The name of the generator.\"\"\")\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.GeneratorCall","title":"<code>GeneratorCall</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the generator to call.</p> required <code>args</code> <code>str | None</code> <p>The arguments to pass to the generator.</p> <code>None</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class GeneratorCall(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    name: str = Field(description='The name of the generator to call.')\n\n    args: Optional[str] = Field(\n        default=None, description='The arguments to pass to the generator.'\n    )\n\n    def __str__(self) -&gt; str:\n        return f'{self.name} {self.args}'\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.GeneratorScript","title":"<code>GeneratorScript</code>","text":"<p>               Bases: <code>CodeItem</code></p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Path</code> <p>The root directory where the generators should be fetched from.</p> <code>&lt;dynamic&gt;</code> <code>format</code> <code>Literal[str, str]</code> <p>The format of the generator script.</p> <code>'rbx'</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class GeneratorScript(CodeItem):\n    model_config = ConfigDict(extra='forbid')\n\n    root: pathlib.Path = Field(\n        default_factory=pathlib.Path,\n        description=\"\"\"The root directory where the generators should be fetched from.\"\"\",\n    )\n\n    format: Literal['rbx', 'box'] = Field(\n        default='rbx', description=\"\"\"The format of the generator script.\"\"\"\n    )\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.Interactor","title":"<code>Interactor</code>","text":"<p>               Bases: <code>CodeItem</code></p> <p>Parameters:</p> Name Type Description Default <code>legacy</code> <code>bool</code> <p>Whether this interactor is a legacy interactor and needs a checker to be specified.</p> <code>False</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class Interactor(CodeItem):\n    model_config = ConfigDict(extra='forbid')\n\n    legacy: bool = Field(\n        default=False,\n        description=\"\"\"\nWhether this interactor is a legacy interactor and needs a checker to be specified.\n\"\"\",\n    )\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.LimitModifiers","title":"<code>LimitModifiers</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>timeMultiplier</code> <code>float | None</code> <p>Multiplier for time limit.</p> <code>None</code> <code>time</code> <code>int | None</code> <p>Value to override time limit with, in milliseconds.</p> <code>None</code> <code>memory</code> <code>int | None</code> <p>Value to override memory limit with, in MB.</p> <code>None</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class LimitModifiers(BaseModel):\n    timeMultiplier: Optional[float] = Field(\n        default=None, description='Multiplier for time limit.'\n    )\n    time: Optional[int] = Field(\n        default=None, description='Value to override time limit with, in milliseconds.'\n    )\n    memory: Optional[int] = Field(\n        default=None, description='Value to override memory limit with, in MB.'\n    )\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.LimitsProfile","title":"<code>LimitsProfile</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>inheritFromPackage</code> <code>bool</code> <p>Whether to inherit limits from the package.</p> <code>False</code> <code>timeLimit</code> <code>int | None</code> <p>Time limit of the problem, in milliseconds.</p> <code>None</code> <code>memoryLimit</code> <code>int | None</code> <p>Memory limit of the problem, in MB.</p> <code>None</code> <code>outputLimit</code> <code>int | None</code> <p>Output limit of the problem, in KB.</p> <code>None</code> <code>modifiers</code> <code>Dict[str, LimitModifiers]</code> <p>Limit modifiers that can be specified per language.</p> <code>{}</code> <code>formula</code> <code>str | None</code> <p>A formula to estimate the time limit for the problem.</p> <code>None</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class LimitsProfile(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    inheritFromPackage: bool = Field(\n        default=False,\n        description=\"\"\"\nWhether to inherit limits from the package.\n\"\"\",\n    )\n\n    timeLimit: Optional[int] = Field(\n        default=None, description='Time limit of the problem, in milliseconds.'\n    )\n\n    memoryLimit: Optional[int] = Field(\n        default=None, description='Memory limit of the problem, in MB.'\n    )\n\n    outputLimit: Optional[int] = Field(\n        default=None, description='Output limit of the problem, in KB.'\n    )\n\n    modifiers: Dict[str, LimitModifiers] = Field(\n        default={},\n        description=\"\"\"\n    Limit modifiers that can be specified per language.\n    \"\"\",\n    )\n\n    formula: Optional[str] = Field(\n        default=None,\n        description=\"\"\"\nA formula to estimate the time limit for the problem.\n\"\"\",\n    )\n\n    def timelimit_for_language(self, language: Optional[str] = None) -&gt; int:\n        assert self.timeLimit is not None\n        res = self.timeLimit\n        if language is not None and language in self.modifiers:\n            modifier = self.modifiers[language]\n            if modifier.time is not None:\n                res = modifier.time\n            if modifier.timeMultiplier is not None:\n                res = int(res * float(modifier.timeMultiplier))\n        if 'RBX_TIME_MULTIPLIER' in utils.environ():\n            res = int(res * float(utils.environ()['RBX_TIME_MULTIPLIER']))\n        return res\n\n    def memorylimit_for_language(self, language: Optional[str] = None) -&gt; int:\n        assert self.memoryLimit is not None\n        res = self.memoryLimit\n        if language is None:\n            return res\n        if language not in self.modifiers:\n            return res\n        modifier = self.modifiers[language]\n        if modifier.memory is not None:\n            return modifier.memory\n        return res\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.Package","title":"<code>Package</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the problem.</p> required <code>titles</code> <code>Dict[str, str]</code> <p>Titles for the problem in each language. Languages should be specified as lowercase ISO 639-1 codes.</p> <code>{}</code> <code>type</code> <code>TaskType</code> <p>The type of the problem.</p> <code>BATCH</code> <code>timeLimit</code> <code>int</code> <p>Time limit of the problem, in milliseconds.</p> required <code>memoryLimit</code> <code>int</code> <p>Memory limit of the problem, in MB.</p> required <code>outputLimit</code> <code>int</code> <p>Output limit of the problem, in KB.</p> <code>4096</code> <code>modifiers</code> <code>Dict[str, LimitModifiers]</code> <p>Limit modifiers that can be specified per language.</p> <code>{}</code> <code>checker</code> <code>Checker | None</code> <p>The checker for this problem.</p> <code>None</code> <code>interactor</code> <code>Interactor | None</code> <p>The interactor for this problem.</p> <code>None</code> <code>validator</code> <code>CodeItem | None</code> <p>The validator for this problem.</p> <code>None</code> <code>extraValidators</code> <code>List[CodeItem]</code> <p>Extra validators for this problem.</p> <code>[]</code> <code>generators</code> <code>List[Generator]</code> <p>Generators for this problem.</p> <code>[]</code> <code>solutions</code> <code>List[Solution]</code> <p>All tested solutions for this problem.</p> <p>The first solution in this list should be the main solution -- the one that is correct and used as reference -- and should have the <code>accepted</code> outcome.</p> <code>[]</code> <code>testcases</code> <code>List[TestcaseGroup]</code> <p>Testcases for the problem.</p> <code>[]</code> <code>stresses</code> <code>List[Stress]</code> <p>Stress tests for the problem.</p> <code>[]</code> <code>statements</code> <code>List[Statement]</code> <p>Statements for the problem.</p> <code>[]</code> <code>vars</code> <code>TypeAliasType</code> <p>Variables to be re-used across the package.</p> <code>{}</code> <code>unitTests</code> <code>UnitTests</code> <p>Unit tests for components of this problem.</p> <code>&lt;dynamic&gt;</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class Package(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    # Name of the problem.\n    name: str = NameField(description='The name of the problem.')\n\n    titles: Dict[str, str] = Field(\n        default={},\n        description='Titles for the problem in each language. '\n        'Languages should be specified as lowercase ISO 639-1 codes.',\n    )\n\n    type: TaskType = Field(\n        default=TaskType.BATCH, description='The type of the problem.'\n    )\n\n    timeLimit: int = Field(description='Time limit of the problem, in milliseconds.')\n\n    memoryLimit: int = Field(description='Memory limit of the problem, in MB.')\n\n    outputLimit: int = Field(\n        default=4 * 1024, description='Output limit of the problem, in KB.'\n    )\n\n    modifiers: Dict[str, LimitModifiers] = Field(\n        default={},\n        description=\"\"\"\n    Limit modifiers that can be specified per language.\n    \"\"\",\n    )\n\n    checker: Optional[Checker] = Field(\n        default=None, description='The checker for this problem.'\n    )\n\n    interactor: Optional[Interactor] = Field(\n        default=None, description='The interactor for this problem.'\n    )\n\n    validator: Optional[CodeItem] = Field(\n        default=None, description='The validator for this problem.'\n    )\n\n    extraValidators: List[CodeItem] = Field(\n        default=[], description='Extra validators for this problem.'\n    )\n\n    generators: List[Generator] = Field(\n        default=[], description='Generators for this problem.'\n    )\n\n    solutions: List[Solution] = Field(\n        default=[],\n        description=\"\"\"\nAll tested solutions for this problem.\n\nThe first solution in this list should be the main solution -- the one\nthat is correct and used as reference -- and should have the `accepted` outcome.\n\"\"\",\n    )\n\n    testcases: List[TestcaseGroup] = Field(\n        default=[], description='Testcases for the problem.'\n    )\n\n    stresses: List[Stress] = Field(\n        default=[], description='Stress tests for the problem.'\n    )\n\n    statements: Annotated[\n        List[Statement],\n        AfterValidator(is_unique_by_name),\n    ] = Field(default=[], description='Statements for the problem.')\n\n    # Vars to be re-used across the package.\n    #   - It will be passed as --key=value arguments to the validator.\n    #   - It will be available as \\VAR{key} variables in the rbx statement.\n    vars: RecVars = Field(\n        default={}, description='Variables to be re-used across the package.'\n    )\n\n    unitTests: UnitTests = Field(\n        default_factory=UnitTests,\n        description='Unit tests for components of this problem.',\n    )\n\n    @property\n    def expanded_statements(self) -&gt; List[Statement]:\n        return expand_statements(self.statements)\n\n    @property\n    def expanded_vars(self) -&gt; Vars:\n        return expand_vars(self.vars)\n\n    @model_validator(mode='after')\n    def check_first_solution_is_main_if_there_is_ac(self):\n        if all(sol.outcome != Outcome.ACCEPTED for sol in self.solutions):\n            # No main solution.\n            return self\n        if self.solutions:\n            if self.solutions[0].outcome != ExpectedOutcome.ACCEPTED:\n                raise PydanticCustomError(\n                    'MISSING_MAIN_SOLUTION',\n                    'The first solution in the package must have the \"ACCEPTED\" outcome if there are ACCEPTED solutions.',\n                )\n        return self\n\n    @model_validator(mode='after')\n    def samples_come_first(self):\n        for i, group in enumerate(self.testcases):\n            if group.name == 'samples' and i &gt; 0:\n                raise PydanticCustomError(\n                    'SAMPLES_NOT_FIRST',\n                    'The \"samples\" group must be the first group in the package, but is actually the {i}-th',\n                    {'i': i + 1},\n                )\n        return self\n\n    @model_validator(mode='after')\n    def check_checker_and_interactor_for_task_type(self):\n        if self.type == TaskType.BATCH:\n            if self.interactor is not None:\n                raise PydanticCustomError(\n                    'INTERACTOR_NOT_ALLOWED',\n                    'Interactor is not allowed for batch problems. Change the task type to COMMUNICATION.',\n                )\n        if self.type == TaskType.COMMUNICATION:\n            if self.checker is not None and (\n                self.interactor is None or not self.interactor.legacy\n            ):\n                raise PydanticCustomError(\n                    'CHECKER_NOT_ALLOWED',\n                    'Checkers should not be specified for communication problems.',\n                )\n        return self\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.Solution","title":"<code>Solution</code>","text":"<p>               Bases: <code>CodeItem</code></p> <p>Parameters:</p> Name Type Description Default <code>outcome</code> <code>ExpectedOutcome</code> <p>The expected outcome of this solution.</p> <code>ACCEPTED</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class Solution(CodeItem):\n    model_config = ConfigDict(extra='forbid')\n\n    outcome: ExpectedOutcome = Field(\n        default=ExpectedOutcome.ACCEPTED,\n        description=\"\"\"The expected outcome of this solution.\"\"\",\n    )\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.Stress","title":"<code>Stress</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the stress test.</p> required <code>generator</code> <code>GeneratorCall</code> <p>Generator pattern to call during stress-test.</p> required <code>finder</code> <code>str</code> <p>Finder expression to be used to match against generated tests.</p> required Source code in <code>rbx/box/schema.py</code> <pre><code>class Stress(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    name: str = NameField(description='The name of the stress test.')\n\n    generator: GeneratorCall = Field(\n        description='Generator pattern to call during stress-test.'\n    )\n\n    finder: str = Field(\n        description='Finder expression to be used to match against generated tests.'\n    )\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.TaskType","title":"<code>TaskType</code>","text":"<p>               Bases: <code>AutoEnum</code></p> Source code in <code>rbx/box/schema.py</code> <pre><code>class TaskType(AutoEnum):\n    BATCH = alias('batch')  # type: ignore\n    \"\"\"Batch task.\"\"\"\n\n    COMMUNICATION = alias('communication')  # type: ignore\n    \"\"\"Communication task.\"\"\"\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.TaskType.BATCH","title":"<code>BATCH = alias('batch')</code>","text":"<p>Batch task.</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.TaskType.COMMUNICATION","title":"<code>COMMUNICATION = alias('communication')</code>","text":"<p>Communication task.</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.Testcase","title":"<code>Testcase</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>inputPath</code> <code>Path</code> <p>The path of the input file.</p> required <code>outputPath</code> <code>Path | None</code> <p>The path of the output file.</p> <code>None</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class Testcase(BaseModel):\n    __test__ = False\n\n    model_config = ConfigDict(extra='forbid')\n\n    inputPath: pathlib.Path = Field(description=\"\"\"The path of the input file.\"\"\")\n\n    outputPath: Optional[pathlib.Path] = Field(\n        default=None, description=\"\"\"The path of the output file.\"\"\"\n    )\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.TestcaseGroup","title":"<code>TestcaseGroup</code>","text":"<p>               Bases: <code>TestcaseSubgroup</code></p> <p>Parameters:</p> Name Type Description Default <code>subgroups</code> <code>List[TestcaseSubgroup]</code> <p>A list of test subgroups to define for this group.</p> <code>[]</code> <code>validator</code> <code>CodeItem | None</code> <p>A validator to use to validate the testcases of this group. If specified, will use this validator instead of the package-level validator. Useful in cases where the constraints vary across test groups.</p> <code>None</code> <code>weight</code> <code>float | None</code> <p>The weight of this group in the final score. Useful for problems that have points.</p> <code>1.0</code> <code>model_solution</code> <code>ForwardRef('Optional[Solution]')</code> <p>The solution to be used to generate outputs for this testgroup.</p> <p>Can only be set for the \"samples\" testgroup.</p> <code>None</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class TestcaseGroup(TestcaseSubgroup):\n    model_config = ConfigDict(extra='forbid')\n\n    subgroups: List[TestcaseSubgroup] = Field(\n        default=[],\n        description=\"\"\"\nA list of test subgroups to define for this group.\n        \"\"\",\n    )\n\n    validator: Optional[CodeItem] = Field(\n        default=None,\n        description=\"\"\"\nA validator to use to validate the testcases of this group.\nIf specified, will use this validator instead of the package-level validator.\nUseful in cases where the constraints vary across test groups.\n\"\"\",\n    )\n\n    weight: Optional[float] = Field(\n        default=1.0,\n        description=\"\"\"\nThe weight of this group in the final score. Useful for\nproblems that have points.\n\"\"\",\n    )\n\n    model_solution: Optional[Solution] = Field(\n        default=None,\n        description=\"\"\"\nThe solution to be used to generate outputs for this testgroup.\n\nCan only be set for the \"samples\" testgroup.\n\"\"\",\n    )\n\n    @model_validator(mode='after')\n    def check_model_solution_for_samples(self):\n        if self.name == 'samples':\n            return self\n        if self.model_solution is not None:\n            raise PydanticCustomError(\n                'MODEL_SOLUTION_NOT_ALLOWED',\n                'Model solution can only be set for the \"samples\" testgroup.',\n            )\n        return self\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.TestcaseSubgroup","title":"<code>TestcaseSubgroup</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the test group.</p> required <code>testcases</code> <code>List[Testcase]</code> <p>The path of testcases to add to this group, in the order they're defined.</p> <code>[]</code> <code>testcaseGlob</code> <code>str | None</code> <p>A Python glob that matches input file paths relative to the package directory. The globbed files should end with the extension \".in\", and their corresponding outputs, if defined, should have the same file name, but ending with \".ans\".</p> <code>None</code> <code>generators</code> <code>List[GeneratorCall]</code> <p>A list of generators to call to generate testcases for this group.</p> <code>[]</code> <code>generatorScript</code> <code>GeneratorScript | None</code> <p>A generator script to call to generate testcases for this group.</p> <code>None</code> <code>extraValidators</code> <code>List[CodeItem]</code> <p>A list of extra validators to use to validate the testcases of this subgroup.</p> <code>[]</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class TestcaseSubgroup(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    name: str = NameField(description='The name of the test group.')\n\n    testcases: List[Testcase] = Field(\n        default=[],\n        description=\"\"\"\nThe path of testcases to add to this group,\nin the order they're defined.\"\"\",\n    )\n\n    testcaseGlob: Optional[str] = Field(\n        default=None,\n        description=\"\"\"\nA Python glob that matches input file paths relative to the\npackage directory. The globbed files should end with the extension\n\".in\", and their corresponding outputs, if defined, should have the same file name,\nbut ending with \".ans\".\n\"\"\",\n    )\n\n    generators: List[GeneratorCall] = Field(\n        default=[],\n        description=\"\"\"\nA list of generators to call to generate testcases for this group.\n\"\"\",\n    )\n\n    generatorScript: Optional[GeneratorScript] = Field(\n        default=None,\n        description=\"\"\"\nA generator script to call to generate testcases for this group.\n\"\"\",\n    )\n\n    extraValidators: List[CodeItem] = Field(\n        default=[],\n        description=\"\"\"\nA list of extra validators to use to validate the testcases of this subgroup.\n\"\"\",\n    )\n\n    @model_validator(mode='after')\n    def check_oneof(self) -&gt; 'TestcaseSubgroup':\n        _check_oneof(\n            self,\n            [\n                'testcases',\n                'testcaseGlob',\n                'generators',\n                'generatorScript',\n            ],\n        )\n        return self\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.UnitTests","title":"<code>UnitTests</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>validator</code> <code>List[ValidatorTest]</code> <p>Unit tests for the validator.</p> <code>[]</code> <code>checker</code> <code>List[CheckerTest]</code> <p>Unit tests for the checker.</p> <code>[]</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class UnitTests(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    validator: List[ValidatorTest] = Field(\n        default=[],\n        description='Unit tests for the validator.',\n    )\n\n    checker: List[CheckerTest] = Field(\n        default=[],\n        description='Unit tests for the checker.',\n    )\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ValidatorOutcome","title":"<code>ValidatorOutcome</code>","text":"<p>               Bases: <code>AutoEnum</code></p> Source code in <code>rbx/box/schema.py</code> <pre><code>class ValidatorOutcome(AutoEnum):\n    VALID = alias('valid')  # type: ignore\n    \"\"\"Expected outcome for valid tests.\"\"\"\n\n    INVALID = alias('invalid')  # type: ignore\n    \"\"\"Expected outcome for invalid tests.\"\"\"\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ValidatorOutcome.INVALID","title":"<code>INVALID = alias('invalid')</code>","text":"<p>Expected outcome for invalid tests.</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ValidatorOutcome.VALID","title":"<code>VALID = alias('valid')</code>","text":"<p>Expected outcome for valid tests.</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ValidatorTest","title":"<code>ValidatorTest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>glob</code> <code>str</code> <p>A glob pattern for the input files to be used as unit test input for the validator.</p> required <code>outcome</code> <code>ValidatorOutcome</code> <p>The expected outcome of the validator.</p> <code>VALID</code> <code>validator</code> <code>CodeItem | None</code> <p>The validator to use for this test. If not specified, will use the package-level validator.</p> <code>None</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class ValidatorTest(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    glob: str = Field(\n        description='A glob pattern for the input files to be used as unit test input for the validator.'\n    )\n    outcome: ValidatorOutcome = Field(\n        default=ValidatorOutcome.VALID,\n        description='The expected outcome of the validator.',\n    )\n\n    validator: Optional[CodeItem] = Field(\n        default=None,\n        description='The validator to use for this test. If not specified, will use the package-level validator.',\n    )\n</code></pre>"},{"location":"setters/reference/package/schema/#statements","title":"Statements","text":""},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.Statement","title":"<code>Statement</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of this statement.</p> required <code>extends</code> <code>str | None</code> <p>Name of the statement that this statement extends.</p> <code>None</code> <code>language</code> <code>str</code> <p>Language code of this statement (ISO 639-1).</p> <code>'en'</code> <code>title</code> <code>str | None</code> <p>Title of the problem, as it appears in the statement. Can be left unset if the problem has no title or if title comes from the <code>titles</code> field of the package.</p> <code>None</code> <code>path</code> <code>Path</code> <p>Path to the input statement file.</p> <code>&lt;dynamic&gt;</code> <code>type</code> <code>StatementType</code> <p>Type of the input statement file.</p> <code>rbxTeX</code> <code>steps</code> <code>List[Union[TexToPDF, JinjaTeX, rbxToTeX, rbxMarkdownToTeX]]</code> <p>Describes a sequence of conversion steps that should be applied to the statement file.</p> <p>Usually, it is not necessary to specify these, as they can be inferred from the input statement type and the output statement type, but you can use this to force certain conversion steps to happen.</p> <code>[]</code> <code>configure</code> <code>List[Union[TexToPDF, JinjaTeX, rbxToTeX, rbxMarkdownToTeX]]</code> <p>Configure how certain conversion steps should happen when applied to the statement file.</p> <p>Different from the <code>steps</code> field, this does not force the steps to happen, but rather only configure them in case they are applied.</p> <code>[]</code> <code>assets</code> <code>List[str]</code> <p>Assets relative to the package directory that should be included while building the statement. Files will be included in the same folder as the statement file, preserving their relativeness. Can be glob pattern as well, such as <code>imgs/*.png</code>.</p> <code>[]</code> <code>vars</code> <code>TypeAliasType</code> <p>Variables to be used in the statement.</p> <code>{}</code> Source code in <code>rbx/box/statements/schema.py</code> <pre><code>class Statement(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    name: str = FNameField(description='Name of this statement.')\n\n    extends: Optional[str] = FNameField(\n        default=None,\n        description='Name of the statement that this statement extends.',\n    )\n\n    language: StatementLanguage = Field(\n        default='en', description='Language code of this statement (ISO 639-1).'\n    )\n\n    title: Optional[str] = Field(\n        default=None,\n        description='Title of the problem, as it appears in the statement. '\n        'Can be left unset if the problem has no title or if title comes '\n        'from the `titles` field of the package.',\n    )\n\n    path: pathlib.Path = Field(\n        default_factory=pathlib.Path, description='Path to the input statement file.'\n    )\n\n    type: StatementType = Field(\n        default=StatementType.rbxTeX, description='Type of the input statement file.'\n    )\n\n    steps: List[Annotated[ConversionStep, Field(discriminator='type')]] = Field(\n        default=[],\n        description=\"\"\"\nDescribes a sequence of conversion steps that should be applied to the statement file.\n\nUsually, it is not necessary to specify these, as they can be inferred from the\ninput statement type and the output statement type, but you can use this to force\ncertain conversion steps to happen.\n\"\"\",\n    )\n\n    configure: List[Annotated[ConversionStep, Field(discriminator='type')]] = Field(\n        default=[],\n        description=\"\"\"\nConfigure how certain conversion steps should happen when applied to the statement file.\n\nDifferent from the `steps` field, this does not force the steps to happen, but rather only\nconfigure them in case they are applied.\n\"\"\",\n    )\n\n    assets: List[str] = Field(\n        default=[],\n        description=\"\"\"\nAssets relative to the package directory that should be included while building\nthe statement. Files will be included in the same folder as the statement file, preserving\ntheir relativeness. Can be glob pattern as well, such as `imgs/*.png`.\n\"\"\",\n    )\n\n    vars: RecVars = Field(\n        default={},\n        description='Variables to be used in the statement.',\n    )\n\n    @property\n    def expanded_vars(self) -&gt; Vars:\n        return expand_vars(self.vars)\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.StatementType","title":"<code>StatementType</code>","text":"<p>               Bases: <code>AutoEnum</code></p> Source code in <code>rbx/box/statements/schema.py</code> <pre><code>class StatementType(AutoEnum):\n    rbxTeX = alias('rbx-tex')  # type: ignore\n    \"\"\"Statement written in rbxTeX format.\"\"\"\n\n    rbxMarkdown = alias('rbxMd', 'rbx-markdown', 'rbx-md')  # type: ignore\n    \"\"\"Statement written in rbxMarkdown format.\"\"\"\n\n    TeX = alias('tex')\n    \"\"\"Statement written in pure LaTeX format.\"\"\"\n\n    JinjaTeX = alias('jinja-tex')\n    \"\"\"Statement written in LaTeX format with Jinja2 expressions.\"\"\"\n\n    PDF = alias('pdf')\n    \"\"\"Statement is a PDF.\"\"\"\n\n    def get_file_suffix(self) -&gt; str:\n        if self == StatementType.TeX:\n            return '.tex'\n        if self == StatementType.rbxTeX:\n            return '.rbx.tex'\n        if self == StatementType.rbxMarkdown:\n            return '.rbx.md'\n        if self == StatementType.JinjaTeX:\n            return '.jinja.tex'\n        if self == StatementType.PDF:\n            return '.pdf'\n        raise ValueError(f'Unknown statement type: {self}')\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.StatementType.rbxTeX","title":"<code>rbxTeX = alias('rbx-tex')</code>","text":"<p>Statement written in rbxTeX format.</p>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.StatementType.rbxMarkdown","title":"<code>rbxMarkdown = alias('rbxMd', 'rbx-markdown', 'rbx-md')</code>","text":"<p>Statement written in rbxMarkdown format.</p>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.StatementType.TeX","title":"<code>TeX = alias('tex')</code>","text":"<p>Statement written in pure LaTeX format.</p>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.StatementType.JinjaTeX","title":"<code>JinjaTeX = alias('jinja-tex')</code>","text":"<p>Statement written in LaTeX format with Jinja2 expressions.</p>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.StatementType.PDF","title":"<code>PDF = alias('pdf')</code>","text":"<p>Statement is a PDF.</p>"},{"location":"setters/reference/package/schema/#conversion-nodes","title":"Conversion nodes","text":""},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.ConversionType","title":"<code>ConversionType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> Source code in <code>rbx/box/statements/schema.py</code> <pre><code>class ConversionType(str, Enum):\n    rbxToTex = 'rbx-tex'\n    \"\"\"Conversion from rbxTeX to LaTeX.\"\"\"\n\n    rbxMarkdownToTeX = 'rbx-md-tex'\n    \"\"\"Conversion from rbxMarkdown to LaTeX.\"\"\"\n    TexToPDF = 'tex2pdf'\n    \"\"\"Conversion from LaTeX to PDF using pdfLaTeX.\"\"\"\n\n    JinjaTeX = 'jinja-tex'\n    \"\"\"Conversion from LaTeX with Jinja2 expressions to LaTeX.\"\"\"\n\n    def __repr__(self):\n        return str.__repr__(self.value)\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.ConversionType.JinjaTeX","title":"<code>JinjaTeX = 'jinja-tex'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Conversion from LaTeX with Jinja2 expressions to LaTeX.</p>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.ConversionType.TexToPDF","title":"<code>TexToPDF = 'tex2pdf'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Conversion from LaTeX to PDF using pdfLaTeX.</p>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.ConversionType.rbxMarkdownToTeX","title":"<code>rbxMarkdownToTeX = 'rbx-md-tex'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Conversion from rbxMarkdown to LaTeX.</p>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.ConversionType.rbxToTex","title":"<code>rbxToTex = 'rbx-tex'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Conversion from rbxTeX to LaTeX.</p>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.JinjaTeX","title":"<code>JinjaTeX</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>Literal[ConversionType]</code> required Source code in <code>rbx/box/statements/schema.py</code> <pre><code>class JinjaTeX(BaseModel):\n    type: Literal[ConversionType.JinjaTeX]\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.JoinTexToPDF","title":"<code>JoinTexToPDF</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configures the joining of contest and problem texes to PDF.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>Literal[JoinerType]</code> required Source code in <code>rbx/box/statements/schema.py</code> <pre><code>class JoinTexToPDF(BaseModel):\n    \"\"\"Configures the joining of contest and problem texes to PDF.\"\"\"\n\n    type: Literal[JoinerType.TexToPDF]\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.JoinerType","title":"<code>JoinerType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> Source code in <code>rbx/box/statements/schema.py</code> <pre><code>class JoinerType(str, Enum):\n    TexToPDF = 'tex2pdf'\n    \"\"\"Join contest tex and problem texs to PDF using pdfLaTeX.\"\"\"\n\n    def __repr__(self):\n        return str.__repr__(self.value)\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.JoinerType.TexToPDF","title":"<code>TexToPDF = 'tex2pdf'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Join contest tex and problem texs to PDF using pdfLaTeX.</p>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.TexToPDF","title":"<code>TexToPDF</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configures the conversion between LaTeX and PDF using pdfLaTeX.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>Literal[ConversionType]</code> required Source code in <code>rbx/box/statements/schema.py</code> <pre><code>class TexToPDF(BaseModel):\n    \"\"\"Configures the conversion between LaTeX and PDF using pdfLaTeX.\"\"\"\n\n    type: Literal[ConversionType.TexToPDF]\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.rbxMarkdownToTeX","title":"<code>rbxMarkdownToTeX</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configures the conversion between rbxMarkdown and LaTeX.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>Literal[ConversionType]</code> required Source code in <code>rbx/box/statements/schema.py</code> <pre><code>class rbxMarkdownToTeX(BaseModel):\n    \"\"\"Configures the conversion between rbxMarkdown and LaTeX.\"\"\"\n\n    type: Literal[ConversionType.rbxMarkdownToTeX]\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.rbxToTeX","title":"<code>rbxToTeX</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configures the conversion between rbxTeX and LaTeX.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>Literal[ConversionType]</code> required <code>template</code> <code>Path</code> <p>Path to the template that should be used to render the rbx-tex blocks.</p> <code>PosixPath('template.rbx.tex')</code> Source code in <code>rbx/box/statements/schema.py</code> <pre><code>class rbxToTeX(BaseModel):\n    \"\"\"Configures the conversion between rbxTeX and LaTeX.\"\"\"\n\n    type: Literal[ConversionType.rbxToTex]\n\n    template: pathlib.Path = Field(\n        default=pathlib.Path('template.rbx.tex'),\n        description='Path to the template that should be used to render the rbx-tex blocks.',\n    )\n</code></pre>"},{"location":"setters/running/","title":"Running","text":"<p>rbx provides a range of options to run your solutions. In the sections below, we'll go through each of them.</p>"},{"location":"setters/running/#running-solutions-on-the-whole-testset","title":"Running solutions on the whole testset","text":"<p>You can use the <code>rbx run</code> command to run your solutions on the whole testset.</p> <p>The command will run all selected solutions (or all declared solutions if none are selected) on all testcases, providing for each of them the solution outcome, and for the whole testset the timing and memory usage.</p> <p>Below are some examples of how to use the command.</p> <pre><code># Run all solutions on all testcases\nrbx run\n\n# Run a single solution (or a list of solutions) on all testcases\nrbx run &lt;solution-name&gt; ...\n\n# Run all AC solutions on all testcases\nrbx run --outcome AC\n\n# Run all WA solutions on all testcases\nrbx run --outcome WA\n\n# Run all solutions, and provide a table-like output instead\n# of the default output\nrbx run -d\n\n# Interactively pick which solutions to run\nrbx run -c\n</code></pre> <p>One can also set the verification level to be used when running the solutions.</p> <pre><code>rbx run -v{0,1,2,3,4}\n</code></pre> <p>You can read more about each verification level here.</p> <p>By default, rbx will run solutions with the maximum verification level. This means tests will be built and verified, and that all solutions will be run with twice the time limit, and a warning will show up if a TLE solution passed in <code>2*TL</code>.</p> <p>The results of a <code>rbx run</code> command can be inspected through the <code>rbx ui</code> command, as shown in the animation below.</p>"},{"location":"setters/running/#running-tests-with-custom-inputs","title":"Running tests with custom inputs","text":"<p>You might want to run your solutions on a testcase that is not part of the testset, or even on a specific testcase of the testset.</p> <p>You can do this with the <code>rbx irun</code> command. The command will select which solutions to run similar to <code>rbx run</code>. This means you can specify with the following flags:</p> <pre><code># Run a single solution (or a list of solutions) on a specific testcase\nrbx irun &lt;solution-name&gt; ...\n\n# Run all AC solutions on a specific testcase\nrbx irun --outcome AC\n\n# Interactively pick which solutions to run\nrbx irun -c\n</code></pre> <p>By default, <code>rbx irun</code> will prompt you to type a testcase input. After you've finished typing it, you can press <code>Ctrl+D</code> to tell rbx that you're done.</p> <p>rbx will then run the solutions on the testcase you've provided, and print the results into files. You can also use the <code>-p</code> flag to instruct it to print the results into the console instead.</p> <p>Tip</p> <p>By default, the test you've written will be validated, so make sure you've typed it perfectly.</p> <p>If you want to disable validation, you can pass the <code>-v0</code> flag to set the verification level to 0.</p> <p>You can also specify a certain testcase of the testset to run using the <code>-t</code> flag followed by the testcase notation, which is composed of <code>&lt;testgroup-name&gt;/&lt;testcase-index&gt;</code>. For instance, <code>samples/0</code> is the first testcase in the <code>sample</code> testgroup, and <code>secret/10</code> is the 11th testcase in the <code>secret</code> testgroup.</p> <pre><code>rbx irun -t sample/0\n</code></pre> <p>Last but not least, you can also specify a generator call to be used when generating the testcase.</p> <pre><code>rbx irun -g \"gen 100 123\" -p\n</code></pre>"},{"location":"setters/testset/","title":"Testset","text":"<p>The testset contains the tests that will be used to judge a problem, and can be decomposed into two components:</p> <ul> <li>Its skeleton: which are tests are samples? how other tests are grouped?</li> <li>How to generate tests for each group? Are the tests manually defined? Are they generated by a script?</li> </ul> <p>The test skeleton can be specified in the <code>problem.rbx.yml</code> file through the <code>testcases</code> field. This field is a list of <code>TestcaseGroup</code> objects, which describe a group of tests.</p> <p>Every test group should have an unique name. The name will be used to identify the group of tests when running rbx commands. There's a special reserved name, <code>samples</code>, which will be used to identify the group of samples.</p> <p>Below, an example of a very simple, ICPC-style test plan: just two groups, one secret, with tests hidden to the user and one with the samples.</p> problem.rbx.yml<pre><code># ...\ntestcases:\n  - name: 'samples'\n  - name: 'secret'\n</code></pre> <p>Of course, we have to add tests to these groups. The rest of this section will be devoted to this topic.</p> <p>There are 5 different ways of adding tests to group:</p> <p>Method</p> <p>Field</p> <p>Description</p> <p>List of testcases </p> <p><code>testcases</code> </p> <p>A list of <code>Testcase</code> objects that manually defines a few testcases.</p> <p>A testcase glob </p> <p><code>testcaseGlob</code> </p> <p>A path glob (string) that matches a set of testcase inputs (<code>.in</code> files).</p> <p>A list of generator calls </p> <p><code>generators</code> </p> <p>A list of <code>GeneratorCall</code> objects, which describe how to generate the tests for the group.</p> <p>A static generator script (aka a testplan)</p> <p><code>generatorScript</code> </p> <p>A path to a <code>.txt</code> file -- each of its lines is a generator call for a testcase.</p> <p>A dynamic generator script </p> <p><code>generatorScript</code> </p> <p>A path to a code or script that, when called, will generate a static generator script.</p> <p>In this section, we'll talk about the two most recommended approaches: using a testcase glob and using a generator script.</p>"},{"location":"setters/testset/#defining-the-testset","title":"Defining the testset","text":""},{"location":"setters/testset/#testcase-glob","title":"Testcase glob","text":"<p>Testcase globbing is the simplest way of adding manually defined tests to a group.</p> problem.rbx.yml<pre><code>testcases:\n  - name: 'samples'\n    testcaseGlob: 'tests/*.in'\n</code></pre> <p>In the example above, we define a group of samples which will contains tests matching the glob <code>tests/*.in</code>.</p> <p>Thus, if there are 3 files in the <code>tests</code> directory, <code>tests/01.in</code>, <code>tests/02.in</code> and <code>tests/03.in</code>, all these three will be added to the samples group.</p> <p>Test ordering</p> <p>The order of the tests will be the lexicographical order of the files.</p> <p>Be careful to not define tests as <code>1.in</code>, <code>2.in</code>, ..., <code>10.in</code> as this will lead to a test set where test <code>10.in</code> is executed before test <code>2.in</code>.</p> <p>Instead, define the tests as <code>01.in</code>, <code>02.in</code>, ..., <code>10.in</code>, using leading zeroes.</p>"},{"location":"setters/testset/#generator-script","title":"Generator script","text":"<p>If you haven't read the Generators section yet, you should read it before proceeding.</p> <p>A generator script is a script that will be used to generate tests for a group.</p> <p>It can be either a static script (in which case we also call it a testplan) or a dynamic script, and can be specified through the <code>generatorScript</code> field of a test group.</p>"},{"location":"setters/testset/#static-generator-script-aka-testplan","title":"Static generator script (aka testplan)","text":"<p>A static generator script (or a testplan) is a <code>.txt</code> file containing a list of line-separated generator calls.</p> <p>A generator call is simply a pair of <code>&lt;generator-name&gt; &lt;generator-args...&gt;</code>, where <code>&lt;generator-args&gt;</code> is a list of space-separated arguments to pass to the generator.</p> <p>Testplan can also have lines starting with a <code>#</code>, denoting this line is a comment and should be ignored, or even empty lines.</p> <p>Below there's an example of a testplan for a problem that has two generators, <code>random</code> and <code>small</code>, and how to define it in the <code>problem.rbx.yml</code> file.</p> testplan.txtproblem.rbx.yml <pre><code># Two random tests\nrandom 10 100\nrandom 10 1000\n\n# Two small tests\nsmall 50\nsmall 100\n</code></pre> <pre><code>testcases:\n  - name: 'samples'\n    testcaseGlob: 'tests/*.in'\n  - name: 'secret'\n    generatorScript:\n      path: 'testplan.txt'\n</code></pre>"},{"location":"setters/testset/#dynamic-generator-script","title":"Dynamic generator script","text":"<p>A dynamic generator script is a code that produces a testplan. Think of a code (in Python, or even in C++) that produces a testplan file as its output.</p> <p>Below, there's an example of a dynamic generator script for a problem that has a <code>random</code> generator.</p> testplan.pyproblem.rbx.yml <pre><code>for i in range(10):\n    print(f\"random {i}\")\n</code></pre> <pre><code>testcases:\n  - name: 'samples'\n    testcaseGlob: 'tests/*.in'\n  - name: 'secret'\n    generatorScript:\n      path: 'testplan.py'\n</code></pre> <p>The script spits a testplan with exactly 10 random tests, each one generated from a different argument between 0 and 9.</p>"},{"location":"setters/testset/#what-about-the-outputs","title":"What about the outputs?","text":"<p>Until now, we've just generated the inputs of our testcases. What about the outputs? Where they come from?</p> <p>By default, rbx will use the model solution to generate the outputs of the testcases. This will be done when building the testset.</p> <p>The model solution is the topmost accepted solution in the <code>solutions</code> field of the <code>problem.rbx.yml</code> file.</p> <p>In some cases, though, it's useful to specify a different output than the one generated by the model solution. Think of cases where there are multiple possible correct outputs, but the one given by the model solution reveals too much about the intended solution.</p> <p>In these cases, you can create a <code>.out</code> file in the very same path (and with the very same name) as the <code>.in</code> files you've manually defined. You can only create manually crafted outputs for testcases you've defined manually (with a testcase glob, for instance).</p> <p>Let's look at the file tree above, and assume we have a testcase glob for samples such as <code>tests/*.in</code>.</p> <pre><code>- tests/\n  - 01.in\n  - 01.out\n  - 02.in\n</code></pre>"},{"location":"setters/testset/#building-the-testset","title":"Building the testset","text":"<p>The command below can be used to build the testset.</p> <pre><code>rbx build\n</code></pre> <p>This command will build the testset, using the generator scripts to generate the tests for each group. All tests will be written to the <code>build/tests</code> directory, which you can inspect manually in our file system.</p> <p>This command also accepts an extra verification flag (<code>-v</code>), which you can use to control whether validators will be run after generating the tests or not. The flag defaults to <code>-v0</code>, which means no verification will be done.</p> <pre><code>rbx build -v1\n</code></pre> <p>You can read more about the verification level flag in the verification section and about validation in the Validators section.</p>"},{"location":"setters/testset/#visualizing-the-testset","title":"Visualizing the testset","text":"<p>You can use the <code>rbx ui</code> to visualize the testcases that were built through the <code>rbx build</code> command.</p> <pre><code>rbx ui\n</code></pre> <p>This command will start an interactive UI in your terminal which you can use to browse the testset.</p>"},{"location":"setters/testset/generators/","title":"Generators","text":"<p>Generators are a testlib concept. They are programs that produce a testcase for a problem.</p> <p>In this section, we'll learn how to write a generator. If you already know how to do so, you can take a look at the Testset section to learn how to use them to produce your testset.</p>"},{"location":"setters/testset/generators/#generator-call","title":"Generator call","text":"<p>In rbx, generators are programs that produce a testplan from a given list of arguments.</p> <p>Let's say we have an executable <code>generator.exe</code>. Calling it should produce a testcase into the stdout.</p> <pre><code>./generator.exe 123 &gt; testcase\n</code></pre> <p>The program + all the arguments passed to it constitute what we call a generator call.</p> <p>In rbx, every generator should have a name. This name is used to identify the generator within a generator call for a better readability. These names are defined in the <code>problem.rbx.yml</code>.</p> problem.rbx.yml <pre><code>generators:\n    - name: \"generator\"\n      path: \"generator.cpp\"  \n</code></pre> <p>A valid generator call for the generator above would be <code>generator 123</code>.</p>"},{"location":"setters/testset/generators/#idempotency","title":"Idempotency","text":"<p>Generators should be idempotent. This means that two equal generator calls should always produce the same output.</p> <p>testlib <code>rnd</code> library is designed to be used in an idempotent way. In fact, the seed number for the <code>rnd</code> object's random number generator is a hash of the generator call.</p> <p>This means that using the <code>rnd</code> object in a generator as the only source of randomness will guarantee idempotency.</p> <p>Introducing randomness</p> <p>If you need to generate a testcase with the same set of parameters, but with a different seed, simply append a few random characters to the generator call.</p> <p>They will be ignored by your generator, but will be used to compute the seed for <code>rnd</code>, potentially producing a different testcase.</p> <pre><code>gen 100\ngen 100 abc\n</code></pre> <p>The two generator calls above will produce the same testcase for a generator expecting a single positional argument. The trailing <code>abc</code> piece is just used to produce a different seed.</p>"},{"location":"setters/testset/generators/#writing-a-generator","title":"Writing a generator","text":"<p>You can read more about generators in the testlib documentation. It's very thorough and show a bunch of details about the APIs.</p> <pre><code>#include \"testlib.h\"\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int N = opt&lt;int&gt;(1);\n    int MAX = opt&lt;int&gt;(\"MAX\");\n\n    for (int i = 0; i &lt; N; i++) {\n      if (i) cout &lt;&lt; \" \";\n      cout &lt;&lt; rnd.next(1, MAX);\n    }\n    cout &lt;&lt; endl;\n}\n</code></pre> <p>The generator above produces a testcase with <code>N</code> integers, each one between 1 and <code>MAX</code>, separated by spaces.</p> <p>testlib provides the <code>opt&lt;...&gt;()</code> function to parse command line arguments, in two variants:</p> <ul> <li><code>opt&lt;&gt;(int i)</code>: Parses a positional argument in the i-th position (1-indexed).</li> <li><code>opt&lt;&gt;(string name)</code>: Parses argument with the given name.</li> </ul> <p>In the case above, a valid generator call would be:</p> <pre><code>./generator.exe 10 --MAX_A=1000\n</code></pre> <p>To generate 10 random integers ranging from 1 to 1000.</p> <p>Random numbers can be generated using the <code>rnd</code> object. The <code>rnd.next()</code> function can be used to generate a random integer between two values, but there are also other overrides available for it.</p> <p>Take a look at the testlib documentation for more details, and also at the examples on their GitHub repository.</p> <p>Info</p> <p>You can always call your generator manually with:</p> <pre><code>rbx compile &lt;path-to-generator&gt;\nbuild/exe args...\n</code></pre> <p>You can also run solutions interactively against a generator call with:</p> <pre><code>rbx irun -g \"&lt;generator-name&gt; &lt;args...&gt;\"\n</code></pre> <p>Read more about <code>rbx irun</code> in the Running solutions section.</p>"},{"location":"setters/testset/generators/#jngen-the-jack-of-all-trades","title":"Jngen, the jack of all trades","text":"<p>rbx also has a built-in integration with jngen. This is a test generation library implemented by Ivan Smirnov.</p> <p>Jngen is a very powerful library that can generate all sorts of random objects: permutations, trees, graphs, strings, and more.</p> <p>It is a bit less mature and tested than testlib, but it's a great tool to have in your toolbox. Check it at its GitHub repository.</p> <p>To implement a Jngen-based generator, it suffices to include the <code>jngen.h</code> header</p> <p>Under development</p> <p>This section is under development. If you want to contribute, please send a PR to our repository.</p>"},{"location":"setters/verification/","title":"Verification","text":"<p>rbx provides a range of solutions to improve the quality and correctness of your testset and the testlib assets you use. You can see a quick summary of the features in the table below, and then read more about each one in the following sections.</p> <p>Feature</p> <p>Description</p> <p>Validators </p> <p>Check whether your test inputs are conforming the to the format you expect.</p> <p>Unit tests </p> <p>Check whether your checker and/or validator are behaving as expected against manually defined inputs.</p> <p>Stress testing </p> <p>Check whether your validators, checkers and correct solutions are behaving as expected against randomly generated inputs.</p>"},{"location":"setters/verification/#verification-level","title":"Verification Level","text":"<p>rbx also has the concept of a verification level. This is a way to specify how strict the verification should be when building your testset and running solutions.</p> <p>The verification level will usually be specified along your rbx command.</p> <pre><code>rbx build -v{0,1}  # defaults to 1\nrbx run -v{0,1,2,3,4}  # defaults to 4\nrbx package -v{0,1,2,3,4}  # defaults to 4\n</code></pre> <p>The verification level is a non-negative incremental enum, which means that the level <code>N+1</code> will include all the checks of level <code>N</code>, plus what is specified in the table below:</p> Level Description <code>0</code> / <code>NONE</code> No verification. <code>1</code> / <code>VALIDATE</code> Run validators on the generated testset. <code>2</code> / <code>FAST_SOLUTIONS</code> Run all non-TLE solutions. <code>3</code> / <code>ALL_SOLUTIONS</code> Run all solutions, including TLE. <code>4</code> / <code>FULL</code> Run solutions with twice the TL to check if TLE solutions still pass. <p>Setting a larger value is usually the recommended approach to ensure all your expectations are being met.</p> <p>Setting a smaller value is usually useful when you want to run the commands faster, and you are sure that the checks you are running are not being violated.</p>"},{"location":"setters/verification/unit-tests/","title":"Unit tests","text":"<p>rbx provides a way for you to unit test your validators and your checker.</p> <p>You can define unit tests in the <code>unitTests</code> field in your <code>problem.rbx.yml</code> file.</p> problem.rbx.yml<pre><code>unitTests:\n  validator:\n    - glob: unit/validator/valid_*.in\n      outcome: VALID\n    - glob: unit/validator/invalid_*.in\n      outcome: INVALID\n  checker:\n    - glob: unit/checker/ac*\n      outcome: ACCEPTED\n    - glob: unit/checker/wa*\n      outcome: WRONG_ANSWER\n</code></pre> <p>The unit tests can be run with the following command:</p> <pre><code>rbx unit\n</code></pre> <p>In the next sections, we'll go through what each of these fields mean, and how to define the actual test inputs.</p>"},{"location":"setters/verification/unit-tests/#testing-validators","title":"Testing validators","text":"<p>Let's say we have a validator that checks if the input contains a connected graph in the format.</p> <pre><code>N M\nu_1 v_1\nu_2 v_2\n...\nu_M v_M\n</code></pre> <p>We'll omit the actual validator code here for simplicity, but you can see an example at the Validators section.</p> <p>We can create positive (valid) and negative (invalid) unit tests for the problem by defining the following in our <code>problem.rbx.yml</code> file:</p> problem.rbx.yml<pre><code>unitTests:\n  validator:\n    - glob: unit/validator/valid_*.in\n      outcome: VALID\n    - glob: unit/validator/invalid_*.in\n      outcome: INVALID\n</code></pre> <p>Now, every input file matching the glob <code>unit/validator/valid_*.in</code> will be considered a valid input and every input file matching the glob <code>unit/validator/invalid_*.in</code> will be considered an invalid input.</p> <p>To check the tests are working properly, let's create the following files in the <code>unit/validator</code> directory:</p> valid_CONNECTED.ininvalid_NOT_CONNECTED.ininvalid_VERTEX_OUT_OF_BOUNDS.in unit/validator/valid_CONNECTED.in<pre><code>3 3\n1 2\n2 3\n1 3\n</code></pre> unit/validator/invalid_NOT_CONNECTED.in<pre><code>3 1\n1 2\n</code></pre> unit/validator/invalid_VERTEX_OUT_OF_BOUNDS.in<pre><code>3 3\n1 2\n2 3\n2 4\n</code></pre> <p>Now, when you run <code>rbx unit</code>, you should see all the three tests passing if the validator is implemented correctly, and we should see failures if the validator does not behave as expected.</p>"},{"location":"setters/verification/unit-tests/#testing-checkers","title":"Testing checkers","text":"<p>Now, let's say we have a checker that checks whether the output of the participant is a path between two vertices 1 and <code>N</code> in a graph with <code>N</code> vertices and <code>M</code> edges.</p> <p>Let's say we have a checker that expects a number <code>K</code> in the first line, and then <code>K</code> numbers on the second line, which are the vertices on the path.</p> <p>The checker code is omitted for simplicity. You can check the complete code in the Checkers section.</p> <p>We can create unit tests for this checker by defining the following in our <code>problem.rbx.yml</code> file:</p> problem.rbx.yml<pre><code>unitTests:\n  checker:\n    - glob: unit/checker/ac*\n      outcome: ACCEPTED\n    - glob: unit/checker/wa*\n      outcome: WRONG_ANSWER\n</code></pre> <p>These will define the general skeleton of our checker unit tests. Remember that checkers are a bit more complex than validators, and accept three different files as input:</p> <ul> <li><code>&lt;file&gt;.in</code>: The input file for this testcase.</li> <li><code>&lt;file&gt;.out</code>: The output file of the participant for this testcase.</li> <li><code>&lt;file&gt;.ans</code>: The answer file (output of the model solution) for this testcase.</li> </ul> <p>The glob pattern <code>unit/checker/ac*</code> will match any file that starts with <code>ac</code> in its name, and ends with <code>.in</code>, <code>.out</code>, or <code>.ans</code>. Then, these three files will be passed to the checker for testing. If some of them are missing, the checker will simply receive an empty file in their place.</p> <p>Let's say we have the following files in the <code>unit/checker</code> directory:</p> ac_VALID_PATH.inac_VALID_PATH.out unit/checker/ac_VALID_PATH.in<pre><code>3 2\n1 2\n2 3\n</code></pre> unit/checker/ac_VALID_PATH.out<pre><code>3\n1 2 3\n</code></pre> <p>Here, we don't even set a <code>.ans</code> file, because the aforementioned checker will simply ignore it anyways. If you run <code>rbx unit</code>, this test should pass, because the checker will indeed return accepted for this output.</p> <p>Let's test now that the checker fails when the output is not a valid path on the output.</p> wa_NON_EXISTING_EDGE.inwa_NON_EXISTING_EDGE.out unit/checker/wa_NON_EXISTING_EDGE.in<pre><code>3 2\n1 3\n1 2\n</code></pre> unit/checker/wa_NON_EXISTING_EDGE.out<pre><code>3\n1 2 3\n</code></pre> <p>If you run <code>rbx unit</code>, this test should also pass, because the checker will indeed return wrong answer for this output, since the participant's output uses an edge that does not exist in the input.</p> <p>In problems where the model solution output is consumed by the checker, we can additionally define the <code>.ans</code> file as well, and the checker will consume it.</p>"},{"location":"setters/verification/unit-tests/#testing-extra-validators","title":"Testing extra validators","text":"<p>You can test extra validators in the same way as the main validator by simply specifying the validator that should be testedin the <code>unitTests</code> field. By default, the main validator will be tested.</p> problem.rbx.yml<pre><code>unitTests:\n  validator:\n    - glob: unit/validator/valid_*.in\n      outcome: VALID\n    - glob: unit/validator/invalid_*.in\n      outcome: INVALID\n    - glob: unit/extra-validator/valid_*.in\n      outcome: VALID\n      validator: extra-validator.cpp\n    - glob: unit/extra-validator/invalid_*.in\n      outcome: INVALID\n      validator: extra-validator.cpp\n</code></pre>"},{"location":"setters/verification/validators/","title":"Validators","text":"<p>Validator is a concept introduced by testlib to verify whether the tests you generate for a problem are in the format you really expect.</p> <p>Think of the frustrating scenarios where you've written in the statement that the graph should be connected, or a tree, or a DAG, but there was a test in your testset that contradicted this. Even experienced setters make these mistakes, and it's important to have extra guards to catch them.</p> <p>Similar to Codeforces, rbx offers built-in support for testlib validators (and also encourages you to use it), but also provides the flexibility for you to write your own.</p>"},{"location":"setters/verification/validators/#motivational-problem","title":"Motivational problem","text":"<p>For the next sections, let's assume we have a problem that asks you to find a path between two vertices 1 and <code>N</code> in a connected graph with <code>N</code> vertices numbered from 1 to <code>N</code>, where <code>N</code> is between 2 and 1000 and <code>M</code> is between 1 and <code>N * (N - 1) / 2</code>.</p> <p>Let's assume the input is given like this:</p> <pre><code>3 2\n1 2\n2 3\n</code></pre> <p>In the first line, we have the number of vertices <code>N</code> and the number of edges <code>M</code>, separated by a single space.</p> <p>In the next <code>M</code> lines, we have the edges of the graph, represented by two integers <code>u</code> and <code>v</code> separated by a single space, indicating that there is an undirected edge between vertex <code>u</code> and vertex <code>v</code>. Then, the file ends.</p> <p>Let's write a validator to verify that our testset does not violate these constraints.</p>"},{"location":"setters/verification/validators/#using-testlib-validators","title":"Using testlib validators","text":"<p>You can read more about testlib validators in the Codeforces documentation.</p> <p>To use a testlib validator, you need to specify the path to the validator in the <code>validator</code> field. testlib validators are always written in C++ and should include the <code>testlib.h</code> header. rbx treats this header especially, and will automatically place it along your validator when compiling it.</p> problem.rbx.yml<pre><code>validator:\n  path: 'validator.cpp'\n</code></pre> <p>Let's write a simple validator that checks the input format above.</p> validator.cpp<pre><code>#include \"testlib.h\"\n\nint main(int argc, char *argv[]) {\n  registerValidation(argc, argv);\n\n  int n = inf.readInt(2, 1000, \"N\"); // (1)!\n  inf.readSpace();\n  int m = inf.readInt(1, n * (n - 1) / 2, \"M\"); // (2)!\n  inf.readEoln();\n\n  // Read all the M edges of the graph.\n  for (int i = 0; i &lt; m; i++) {\n    int u = inf.readInt(1, n, \"u\");\n    inf.readSpace();\n    int v = inf.readInt(1, n, \"v\");\n    inf.readEoln();\n  }\n\n  inf.readEof(); // (3)!\n}\n</code></pre> <ol> <li> <p>We read the number of vertices <code>N</code> and check that it is an integer between 2 and 1000.     Notice we also set a variable name <code>N</code>.</p> <p>This is used for testlib to print useful error messages when an issue is found.</p> </li> <li> <p>We read the number of edges <code>M</code> and check that it is between 1 and <code>N * (N - 1) / 2</code>.</p> <p>Notice how we re-use the variable <code>n</code> we read before.</p> </li> <li> <p>We read the end of the file.</p> </li> </ol> <p>Notice we're super strict about spaces, end-of-lines and end-of-file here. That's the purpose of the validator component.</p> <p>Of course, we still have to check that the graph is connected, but let's do this in a minute.</p> <p>Let's first talk about variables. As explained in the Variables section, we can use variables to refer to constraints in the input. </p> <p>At the moment, we're hard coding the lower and upper bounds for <code>N</code> in the validator. If we change the problem statement to, let's say, allow <code>N</code> between 3 and 500 instead, we'd have to remember to modify the validator. This is a dangerous practice, as it's super easy to forget to do so.</p> <p>Let's do the following modifications to our problem to make it safer:</p> validator.cppproblem.rbx.yml <pre><code>#include \"testlib.h\"\n#include \"rbx.h\"\n\nint main(int argc, char *argv[]) {\n  registerValidation(argc, argv);\n  int MIN_N = getVar&lt;int&gt;(\"N.min\");\n  int MAX_N = getVar&lt;int&gt;(\"N.max\");\n\n  int n = inf.readInt(MIN_N, MAX_N, \"N\");\n  // ...rest of the validator...\n}\n</code></pre> <pre><code># ...rest of the problem.rbx.yml...\nvars:\n  N:\n    min: 2\n    max: 1000\n</code></pre> <p>rbx will automatically generate an <code>rbx.h</code> header file for you, which will include the variables you defined in your <code>problem.rbx.yml</code> file, that you can access in your validator with the <code>getVar&lt;&gt;()</code> function.</p> <p>To read more about variables, check the Variables section.</p> <p>Now, let's finally check that the graph is connected.</p> validator.cpp<pre><code>#include \"testlib.h\"\n#include \"rbx.h\"\n\nbool checkConnected(const vector&lt;vector&lt;int&gt;&gt; &amp;adj, int n) {\n  vector&lt;bool&gt; visited(n + 1);\n  queue&lt;int&gt; q;\n  q.push(1);\n  visited[1] = true;\n\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n\n    for (int v : adj[u]) {\n      if (!visited[v]) {\n        visited[v] = true;\n        q.push(v);\n      }\n    }\n  }\n\n  for (int i = 1; i &lt;= n; i++) {\n    if (!visited[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nint main(int argc, char *argv[]) {\n  registerValidation(argc, argv);\n  int MIN_N = getVar&lt;int&gt;(\"N.min\");\n  int MAX_N = getVar&lt;int&gt;(\"N.max\");\n\n  int n = inf.readInt(MIN_N, MAX_N, \"N\");\n  inf.readSpace();\n  int m = inf.readInt(1, n * (n - 1) / 2, \"M\");\n  inf.readEoln();\n\n  vector&lt;vector&lt;int&gt;&gt; adj(n + 1);\n\n  // Read all the M edges of the graph.\n  for (int i = 0; i &lt; m; i++) {\n    int u = inf.readInt(1, n, \"u\");\n    inf.readSpace();\n    int v = inf.readInt(1, n, \"v\");\n    inf.readEoln();\n\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n\n  ensuref(checkConnected(adj, n), \"The graph is not connected.\");\n\n  inf.readEof();\n}\n</code></pre> <p>Tip</p> <p>You can always manually call a validator on a custom input with <code>rbx validate</code>.</p>"},{"location":"setters/verification/validators/#using-custom-validators","title":"Using custom validators","text":"<p>Let's say you want to build a custom Python3 validator. You can do that similarly by specifying a Python validator in the <code>validator</code> field.</p> problem.rbx.ymlvalidator.py <pre><code>validator:\n  path: 'validator.py'\n</code></pre> <pre><code># ... read the input ...\n\ndef check_connected(adj, n):\n    # ... check if the graph is connected ...\n\nassert check_connected(adj, n), \"The graph is not connected.\"\n\n# ...\n</code></pre> <p>Warning</p> <p>We strongly recommend using testlib validators.</p> <p>They're not only easier to write, but also provides a set of tested utilites to read and stricly check parts of the input, something you would've to do manually otherwise.</p>"},{"location":"setters/verification/validators/#defining-additional-validators","title":"Defining additional validators","text":"<p>rbx provides a couple ways of defining additional validators for a problem or testset.</p> <p>The first one is by using the <code>extraValidators</code> field in the <code>problem.rbx.yml</code> file.</p> <p>This allows you to, for instance, define validators that check for different properties of the input separately.</p> problem.rbx.yml<pre><code>validator:\n  path: 'validator.cpp'\nextraValidators:\n  - path: 'connected-validator.cpp'\n  - path: 'bipartite-validator.cpp'\n</code></pre> <p>Or define validators that check for common properties of the input file that you'd rather keep off of the main validator.</p> problem.rbx.yml<pre><code>validator:\n  path: 'validator.cpp'\nextraValidators:\n  - path: 'only-printable-ascii.py'\n  - path: 'no-tabs.py'\n  - path: 'no-consecutive-spaces.py'\n</code></pre> <p>Another way of additional validators it to specify validators (or extra validators) for a specific test group in your problem.</p> <p>This is often useful for problems that have multiple subtasks with different constraints, but can also be useful for ICPC-style contests where you use the grouping feature to separate tests you've generated with a specific purpose in mind.</p> <p>Considering the problem above one more time, let's say we have a specific testplan focused on tests that contain a straight path from 1 to <code>N</code>, because we know that this is the largest solution a participant can get. We might want to have a validator to ensure tests coming from this testplan really have this property.</p> problem.rbx.yml<pre><code># ... rest of the problem.rbx.yml ...\nvalidator:\n  path: 'validator.cpp'\ntestcases:\n  - name: samples\n    testcaseGlob: manual_tests/samples/*.in\n  - name: general\n    generatorScript:\n      path: testplan/general.txt\n  - name: straight\n    generatorScript:\n      path: testplan/straight.txt\n    extraValidators:\n      - path: 'straight-validator.cpp'\n</code></pre>"}]}