{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"cpp-on-macos/","title":"C/C++ on MacOS","text":""},{"location":"cpp-on-macos/#compiler-choice","title":"Compiler choice","text":"<p>Usually in MacOS, the default compiler is Clang. Even the <code>g++</code> command in the terminal is just a wrapper around Clang.</p> <p>Although Clang will work just fine for most of the time, sometimes it just misbehaves completely compared to GCC. Since online judges usually use GCC, it is a good idea to install GCC and tell rbx to use it.</p> <p>To use the GNU compiler, you need to install it separately.</p> <pre><code>brew install gcc\n</code></pre> <p>But, still after installing it, you need to tell rbx to use it. Find at the end of the <code>brew</code> command which version of <code>g++</code> was installed.</p> <p>For instance, if you see:</p> <pre><code>Installing gcc 14.2.0\n</code></pre> <p>This means that <code>g++-14</code> is probably available as a command to run in your terminal.</p> <p>To tell rbx to use it, you can run <code>rbx config edit</code> and add the following to the file (replace <code>g++-14</code> with whatever version you have installed):</p> <pre><code>command_substitutions:\n  g++: g++-14\n  gcc: gcc-14\n</code></pre> <p>This will tell rbx to use <code>gcc-14</code> and <code>g++-14</code> as the C and C++ compilers.</p> <p>A caveat to this is that GNU GCC sanitizers do not work on MacOS. If you need sanitizers in MacOS, you will need to tell rbx to fall back to Clang when sanitizing.</p> <pre><code>sanitizers:\n  command_substitutions:\n    g++: clang++\n    gcc: clang\n</code></pre>"},{"location":"cpp-on-macos/#floating-point-precision","title":"Floating-point precision","text":"<p>If you're on a Mac with Apple Sillicon (ARM), be aware you might run into floating-point precision issues. These two different architectures apply math optimizations differently. Whilst rbx tries its best to disable some of them in ARM, it's not always possible to completely match the behaviour of x86.</p> <p>Another important thing to notice is that <code>long double</code> is a 64-bit float in ARM, as opposed to the standard extended 80-bit float in x86. Thus, for all effects, <code>long double</code> == <code>double</code> in ARM. If you have solutions that are heavily dependent on the precision of <code>long double</code>, you might need to adjust them when running on ARM, or simply accept they might fail.</p>"},{"location":"stack-limit/","title":"Stack limit","text":"<p>When developing programming competition problems locally, it's often the case we hit the stack limit configured in our system.</p> <p>This is usually a problem because in modern online judges, the stack limit is configured to be as large as 256 MiB, but often the default configuration for Unix-like systems is way smaller than that.</p> <p>The disparity can usually cause some friction, because it's really hard to identify that a solution crashed because it exceeded the stack limit, and not because of some other reason. Thus, it's usually a good practice to increase the stack limit as much as possible to avoid the problem.</p> <p>You can check your current stack limit by running <code>ulimit -s</code> in your terminal. Also, you can check even more details about resource limits by running <code>sudo launchctl limit</code> on MacOS or <code>ulimit -a -S</code>/<code>ulimit -a -H</code> on Linux, which will show something like this:</p> <pre><code># Output of `ulimit -a` on Linux\n-t: cpu time (seconds)              unlimited\n-f: file size (blocks)              unlimited\n-d: data seg size (kbytes)          unlimited\n-s: stack size (kbytes)             8192\n-c: core file size (blocks)         0\n-v: address space (kbytes)          unlimited\n-l: locked-in-memory size (kbytes)  unlimited\n-u: processes                       2666\n-n: file descriptors                1048575\n</code></pre> <p>The values for <code>ulimit -a -S</code> indicates the soft limit -- in this example, 8 MiB --, and the values for <code>ulimit -a -H</code> indicates a hard limit. Usually, hard limits are a bit hard to configure, but soft limits can be easily increased to match the hard limit through the <code>ulimit</code> command.</p> <p>Note</p> <p>8 MiB is a really small and dangerous stack limit: it's not uncommon for a DFS with a handful of parameters in a big graph to exceed that limit. On the other hand, 64 MiB is usually enough for most problems.</p>"},{"location":"stack-limit/#increase-the-soft-stack-limit","title":"Increase the soft stack limit","text":"<p>To increase the stack limit to the maximum allowed (which will match the hard limit), you can run:</p> <pre><code>ulimit -s unlimited\n</code></pre> <p>To ensure you're not bitten by this issue so easily, rbx will complain if you try to run code while your soft stack limit is less than your hard stack limit.</p> <p>Do not worry, the fix -- which consists of adding some lines to your <code>.bashrc</code> (or the equivalent for other shells) -- is really simple and will be shown along the error message.</p> <p>Tip</p> <p>You should ensure the lines added to the file are definitely after the lines where <code>uv</code> and <code>pipx</code> paths are added to <code>$PATH$</code>, otherwise the <code>rbx</code> command will not be found.</p>"},{"location":"stack-limit/#increase-the-hard-stack-limit","title":"Increase the hard stack limit","text":"<p>Sometimes, the hard stack limit is also too small. In this case, you can increase the hard stack limit in different ways depending on your system.</p>"},{"location":"stack-limit/#on-linux","title":"On Linux","text":"<p>Open <code>/etc/security/limits.conf</code> and add the following lines:</p> <pre><code>* stack soft &lt;soft_limit_in_bytes&gt;\n* stack hard &lt;hard_limit_in_bytes&gt;\n</code></pre> <p>This configuration should persist after a reboot.</p>"},{"location":"stack-limit/#on-macos","title":"On MacOS","text":"<p>Run the following command in your terminal:</p> <pre><code>sudo launchctl limit stack &lt;soft_limit_in_bytes&gt; &lt;hard_limit_in_bytes&gt;\n</code></pre> <p>This configuration will NOT persist after a reboot, but will persist across terminals.</p>"},{"location":"intro/installation/","title":"Installation","text":"<p>You can install rbx with a single command, either using <code>pip</code>, <code>pipx</code> or <code>uv</code>. Prefer using <code>uv</code> or <code>pipx</code> to have a better isolation between the dependencies. Read more about how to install and use <code>uv</code> here.</p>"},{"location":"intro/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.9.1 or above (stable with Python 3.10).</li> <li>A C++ toolchain to compile testlib libraries (usually <code>g++</code>).</li> <li>(Optional):<ul> <li>Compilers/interpreters that you need to run your solutions on (e.g. <code>g++</code>, <code>java</code>).</li> <li>pdfLaTeX and other additional packages to convert TeX files into PDF (see https://www.latex-project.org/get/)</li> </ul> </li> </ul>"},{"location":"intro/installation/#from-pypi","title":"From PyPI","text":"<pre><code>$ uv tool install rbx.cp\n</code></pre>"},{"location":"intro/installation/#from-the-repository","title":"From the repository","text":"<pre><code>$ git clone https://github.com/rsalesc/rbx\n$ cd rbx\n$ uv tool install .\n</code></pre>"},{"location":"intro/installation/#verify-installation","title":"Verify installation","text":"rbx --help# rbx help string should show up here"},{"location":"intro/installation/#a-note-for-windows-users","title":"A note for Windows users","text":"<p>rbx is not supported on Windows. One of the main reasons (but not the only one) is that rbx heavily uses symlinks, which is inherently a POSIX feature, and even though it's been implemented in Windows recently, it's not yet perfectly supported.</p> <p>If you want to use rbx on Windows, you can do so by using the WSL (Windows Subsystem for Linux). Also, you'll have to make sure your packages are cloned within the WSL instance and filesystem. Cloning on a Windows folder using Git-on-Windows and mounting it into the WSL instance will not work by default since symlinks will not be preserved. See here for more information.</p> <p>Proceed to the First Steps section.</p>"},{"location":"intro/overview/","title":"Overview","text":""},{"location":"intro/overview/#introduction","title":"Introduction","text":"<p>Quick walkthroughs to get you started with rbx.</p> <ul> <li> <p> Get rbx running in a minute</p> <p>Install rbx with <code>uv</code> on Linux or macOS.</p> <p> Installation</p> </li> <li> <p> Edit a sample problem</p> <p>Start from a simple example problem and learn the basics of rbx.</p> <p> First steps</p> </li> </ul>"},{"location":"intro/overview/#feature-guide","title":"Feature Guide","text":"<p>Learn how to use the different features of rbx.</p> <ul> <li> <p> Build your own testset</p> <p>Learn how to set samples, use generators and stress tests.</p> <p> Testset</p> </li> <li> <p> Define your constraints</p> <p>Define variables and use them in validators, checkers and even in your statements.</p> <p> Variables</p> </li> <li> <p> Verify your problem</p> <p>Ensure the correctness of your problem with validators and unit tests.</p> <p> Verification</p> </li> <li> <p> Run your solutions</p> <p>Run your solutions and verify whether they're given the expected verdict or not.</p> <p> Running</p> </li> <li> <p> Grade with custom checkers</p> <p>Learn how to write a custom checker for a problem.</p> <p> Checkers</p> </li> <li> <p> Write an interactive problem</p> <p>Learn how to write an interactive problem from scratch.</p> <p> Interactors</p> </li> <li> <p> Write, format and translate</p> <p>Learn how to write multiple statements and build them.</p> <p>  Statements</p> </li> <li> <p> Package and ship</p> <p>Build, package and ship your problem to competitive programming platforms.</p> <p> Packaging</p> </li> </ul>"},{"location":"intro/overview/#reference","title":"Reference","text":"<p>Reference documentation for rbx.</p> <ul> <li> <p> Cheatsheet</p> <p>A one stop shop for all the commands and options available in rbx.</p> <p> Cheatsheet</p> </li> <li> <p> Problem configuration</p> <p>A summary of all the configuration options available in <code>problem.rbx.yml</code>.</p> <p> <code>problem.rbx.yml</code> </p> </li> </ul>"},{"location":"intro/windows-git/","title":"Windows and symlinks","text":"<p>If you are on Windows, you can use the WSL (Windows Subsystem for Linux) to run rbx. rbx make heavy use of symlinks under the hood to provide its functionalities.</p> <p>This page describes two different issues you can face while using this tool in Windows, and how to solve them.</p>"},{"location":"intro/windows-git/#enabling-symlinks-in-windows","title":"Enabling symlinks in Windows","text":"<p>If you cannot create symlinks in Windows, you should enable the \"Developer Mode\". You can find more information in their official documentation.</p>"},{"location":"intro/windows-git/#git-on-windows","title":"Git-on-Windows","text":"<p>If you end up using Git-on-Windows to clone your Git repository, and your repository have symlinks, by default symlinks will not be preserved. You should run the command below to enable symlinks in Git-on-Windows before cloning your repo. You might need to reclone everything if you missed this step.</p> <pre><code>$ git config --global core.symlinks true\n</code></pre>"},{"location":"plans/2026-02-20-contributor-workflow-design/","title":"Contributor Workflow Standardization \u2014 Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Standardize contributor development by consolidating commands in mise.toml, adding README guidelines, expanding pre-commit hooks, and adding CI lint check.</p> <p>Architecture: Config-only changes across 4 files. No application code changes.</p> <p>Tech Stack: mise, uv, ruff, pre-commit, GitHub Actions</p>"},{"location":"plans/2026-02-20-contributor-workflow-design/#task-1-consolidate-misetoml","title":"Task 1: Consolidate mise.toml","text":"<p>Files: - Modify: <code>mise.toml</code></p> <p>Add sync, lock, lint, format, check, bump, build, publish tasks to existing test tasks.</p> <p>Verify: <code>mise tasks</code> shows all tasks.</p>"},{"location":"plans/2026-02-20-contributor-workflow-design/#task-2-add-uvlock-pre-commit-hook","title":"Task 2: Add uv.lock pre-commit hook","text":"<p>Files: - Modify: <code>.pre-commit-config.yaml</code></p> <p>Add local hook running <code>uv lock --check</code> on pyproject.toml/uv.lock changes.</p> <p>Verify: <code>pre-commit run uv-lock-check --all-files</code> passes.</p>"},{"location":"plans/2026-02-20-contributor-workflow-design/#task-3-create-ci-lint-workflow","title":"Task 3: Create CI lint workflow","text":"<p>Files: - Create: <code>.github/workflows/lint.yml</code></p> <p>Runs <code>ruff check .</code> and <code>ruff format --check .</code> on PRs and pushes to main/master.</p>"},{"location":"plans/2026-02-20-contributor-workflow-design/#task-4-add-contributing-section-to-readme","title":"Task 4: Add Contributing section to README","text":"<p>Files: - Modify: <code>README.md</code></p> <p>Add Contributing section before License with prerequisites, setup, task table, code style, PR workflow.</p>"},{"location":"plans/2026-02-22-demacro-utils-design/","title":"Macro Syntax Error","text":"<p>File: <code>plans/2026-02-22-demacro-utils-design.md</code></p> <p>Line 50 in Markdown file: Missing end of comment tag <pre><code>For `\\newcommand{\\foo}[2]{#1 and #2}`:\n</code></pre></p>"},{"location":"plans/2026-02-22-demacro-utils/","title":"Macro Syntax Error","text":"<p>File: <code>plans/2026-02-22-demacro-utils.md</code></p> <p>Line 154 in Markdown file: Missing end of comment tag <pre><code>    tex = r'\\newcommand{\\add}[2]{#1 + #2}'\n</code></pre></p>"},{"location":"plans/2026-02-25-command-app-tabs-design/","title":"Command App Tabbed Commands Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Enhance <code>rbxCommandApp</code> so each tab maintains a queue of commands with independent terminals, a dropdown to navigate command history, and an input box to queue new commands.</p> <p>Architecture: Each tab tracks a list of sub-commands (initial argv + user-added). Each sub-command gets its own <code>CommandPane</code>. A <code>Select</code> dropdown switches between sub-command terminals. An <code>Input</code> widget at the bottom lets users type commands, with Enter queueing to the current tab and Shift+Enter queueing to all tabs. Each tab runs its queue sequentially. Toast notifications appear when commands are queued.</p> <p>Tech Stack: Textual (Select, Input, CommandPane), Python asyncio for queuing</p>"},{"location":"plans/2026-02-25-command-app-tabs-design/#task-1-add-prefix-field-to-commandentry-and-update-shell_command","title":"Task 1: Add <code>prefix</code> field to <code>CommandEntry</code> and update <code>shell_command</code>","text":"<p>Files: - Modify: <code>rbx/box/ui/command_app.py:30-45</code></p> <p>Step 1: Add <code>prefix</code> field and update shell_command logic</p> <p>In the <code>CommandEntry</code> dataclass, add <code>prefix: Optional[str] = None</code>. Update <code>shell_command</code> to prepend the prefix to the command. Add a helper <code>make_shell_command(argv)</code> that builds a shell command from an argv list, applying the cwd and prefix of this entry.</p> <pre><code>@dataclasses.dataclass\nclass CommandEntry:\n    argv: List[str]\n    name: Optional[str] = None\n    cwd: Optional[str] = None\n    prefix: Optional[str] = None\n\n    @property\n    def display_name(self) -&gt; str:\n        return self.name if self.name else ' '.join(self.argv)\n\n    def make_shell_command(self, argv: List[str]) -&gt; str:\n        cmd = shlex.join(argv)\n        if self.prefix is not None:\n            cmd = f'{self.prefix} {cmd}'\n        if self.cwd is not None:\n            cmd = f'cd {shlex.quote(self.cwd)} &amp;&amp; exec {cmd}'\n        return cmd\n\n    @property\n    def shell_command(self) -&gt; str:\n        return self.make_shell_command(self.argv)\n</code></pre> <p>Step 2: Verify nothing breaks</p> <p>Run: <code>uv run ruff check rbx/box/ui/command_app.py</code></p> <p>Step 3: Commit</p> <pre><code>feat(ui): add prefix field to CommandEntry\n</code></pre>"},{"location":"plans/2026-02-25-command-app-tabs-design/#task-2-introduce-tabstate-to-track-per-tab-sub-commands-and-queue","title":"Task 2: Introduce <code>TabState</code> to track per-tab sub-commands and queue","text":"<p>Files: - Modify: <code>rbx/box/ui/command_app.py</code></p> <p>Step 1: Create <code>SubCommand</code> dataclass and <code>TabState</code> class</p> <p><code>SubCommand</code> holds a display name, the shell command string, a status, and a reference to its <code>CommandPane</code> widget id. <code>TabState</code> holds the parent <code>CommandEntry</code>, a list of <code>SubCommand</code>s, and manages the queue.</p> <pre><code>@dataclasses.dataclass\nclass SubCommand:\n    name: str\n    shell_command: str\n    pane_id: str\n    status: CommandStatus = CommandStatus.PENDING\n\n\nclass TabState:\n    def __init__(self, entry: CommandEntry, tab_index: int):\n        self.entry = entry\n        self.tab_index = tab_index\n        self.sub_commands: List[SubCommand] = []\n        self._next_sub_id = 0\n        self._running_index: Optional[int] = -1\n\n    def add_sub_command(self, name: str, argv: List[str]) -&gt; SubCommand:\n        shell_command = self.entry.make_shell_command(argv)\n        pane_id = f'cmd-pane-{self.tab_index}-{self._next_sub_id}'\n        sub = SubCommand(\n            name=name,\n            shell_command=shell_command,\n            pane_id=pane_id,\n        )\n        self._next_sub_id += 1\n        self.sub_commands.append(sub)\n        return sub\n\n    @property\n    def is_idle(self) -&gt; bool:\n        return all(\n            s.status in (CommandStatus.SUCCESS, CommandStatus.FAILED)\n            for s in self.sub_commands\n        )\n\n    @property\n    def current_sub_index(self) -&gt; Optional[int]:\n        \"\"\"Index of the currently running sub-command, or None.\"\"\"\n        for i, s in enumerate(self.sub_commands):\n            if s.status == CommandStatus.RUNNING:\n                return i\n        return None\n\n    def next_pending(self) -&gt; Optional[int]:\n        for i, s in enumerate(self.sub_commands):\n            if s.status == CommandStatus.PENDING:\n                return i\n        return None\n</code></pre> <p>Step 2: Verify lint</p> <p>Run: <code>uv run ruff check rbx/box/ui/command_app.py</code></p> <p>Step 3: Commit</p> <pre><code>feat(ui): add TabState and SubCommand for per-tab command tracking\n</code></pre>"},{"location":"plans/2026-02-25-command-app-tabs-design/#task-3-rewrite-rbxcommandapp-compose-to-use-select-dropdown-input","title":"Task 3: Rewrite <code>rbxCommandApp</code> compose to use Select dropdown + Input","text":"<p>Files: - Modify: <code>rbx/box/ui/command_app.py</code></p> <p>Step 1: Update imports and CSS</p> <p>Add <code>Select</code>, <code>Input</code> to textual imports. Update <code>DEFAULT_CSS</code> to style the new layout: the dropdown at the top of the right panel, input box at the bottom, command panes filling the middle.</p> <pre><code>from textual.widgets import Footer, Header, Input, Label, ListItem, ListView, Select\n</code></pre> <p>New CSS additions:</p> <pre><code>#command-display-area {\n    height: 1fr;\n    width: 1fr;\n}\n#command-select {\n    width: 1fr;\n    margin: 0;\n}\n#command-pane-container {\n    height: 1fr;\n    width: 1fr;\n}\n#command-pane-container CommandPane {\n    height: 1fr;\n    border: solid $accent;\n    padding: 0 1;\n}\n#command-input {\n    dock: bottom;\n}\n</code></pre> <p>Step 2: Rewrite <code>compose()</code> method</p> <p>The new layout: left sidebar (tab list), right area with Select dropdown at top, CommandPane container in middle, Input at bottom.</p> <pre><code>def compose(self) -&gt; ComposeResult:\n    yield Header()\n    yield Footer()\n    with Horizontal(id='command-app'):\n        with Vertical(id='command-list-container'):\n            yield ListView(\n                *[\n                    ListItem(\n                        Label(self._make_tab_label(i), markup=True),\n                        id=f'cmd-item-{i}',\n                    )\n                    for i in range(len(self.commands))\n                ],\n                id='command-list',\n            )\n        with Vertical(id='command-display-area'):\n            yield Select(\n                [],\n                prompt='No commands yet',\n                id='command-select',\n                allow_blank=False,\n            )\n            with Vertical(id='command-pane-container'):\n                pass  # CommandPanes added dynamically\n            yield Input(\n                placeholder='Type a command and press Enter...',\n                id='command-input',\n            )\n</code></pre> <p>Step 3: Verify lint</p> <p>Run: <code>uv run ruff check rbx/box/ui/command_app.py</code></p> <p>Step 4: Commit</p> <pre><code>feat(ui): rewrite command app compose with Select dropdown and Input\n</code></pre>"},{"location":"plans/2026-02-25-command-app-tabs-design/#task-4-implement-tab-initialization-and-sub-command-lifecycle","title":"Task 4: Implement tab initialization and sub-command lifecycle","text":"<p>Files: - Modify: <code>rbx/box/ui/command_app.py</code></p> <p>Step 1: Rewrite <code>__init__</code> to create <code>TabState</code> objects</p> <pre><code>def __init__(self, commands: List[CommandEntry], parallel: bool = False):\n    super().__init__()\n    self.commands = commands\n    self.parallel = parallel\n    self._tabs: List[TabState] = []\n    self._active_tab: int = 0\n\n    for i, cmd in enumerate(commands):\n        tab = TabState(entry=cmd, tab_index=i)\n        tab.add_sub_command(cmd.display_name, cmd.argv)\n        self._tabs.append(tab)\n</code></pre> <p>Step 2: Implement <code>on_mount</code> to wire up watchers and start execution</p> <ul> <li>Set border title on the tab list.</li> <li>Mount the initial CommandPanes for each tab's first sub-command.</li> <li>Watch ListView index for tab switching.</li> <li>Start execution (parallel or sequential across tabs; within each tab, always sequential).</li> </ul> <pre><code>async def on_mount(self):\n    self.query_one('#command-list', ListView).border_title = 'Commands'\n\n    # Mount initial command panes for each tab\n    container = self.query_one('#command-pane-container')\n    for tab in self._tabs:\n        sub = tab.sub_commands[0]\n        pane = CommandPane(id=sub.pane_id)\n        await container.mount(pane)\n        pane.display = False\n\n    # Show first tab\n    self._switch_to_tab(0)\n\n    self.watch(\n        self.query_one('#command-list', ListView),\n        'index',\n        self._on_tab_selected,\n    )\n\n    # Start execution\n    if self.parallel:\n        for tab in self._tabs:\n            self._start_next_in_tab(tab)\n    else:\n        asyncio.create_task(self._run_tabs_sequential())\n</code></pre> <p>Step 3: Implement <code>_switch_to_tab</code> and <code>_show_sub_command</code></p> <p><code>_switch_to_tab(index)</code> updates <code>_active_tab</code>, rebuilds the Select dropdown options for that tab, and shows the currently selected sub-command's pane. <code>_show_sub_command(tab, sub_index)</code> hides all panes and shows only the selected one.</p> <pre><code>def _switch_to_tab(self, tab_index: int):\n    self._active_tab = tab_index\n    self._refresh_select()\n    tab = self._tabs[tab_index]\n    # Show the latest sub-command by default (or currently selected)\n    select = self.query_one('#command-select', Select)\n    if select.value is Select.BLANK:\n        self._show_sub_command(len(tab.sub_commands) - 1)\n    else:\n        self._show_sub_command(select.value)\n    # Update input placeholder with prefix\n    input_widget = self.query_one('#command-input', Input)\n    prefix = tab.entry.prefix\n    if prefix:\n        input_widget.placeholder = f'{prefix} &lt;command&gt;'\n    else:\n        input_widget.placeholder = 'Type a command and press Enter...'\n\ndef _refresh_select(self):\n    tab = self._tabs[self._active_tab]\n    select = self.query_one('#command-select', Select)\n    options = [\n        (f'{_STATUS_MARKUP[s.status]} {s.name}', i)\n        for i, s in enumerate(tab.sub_commands)\n    ]\n    select.set_options(options)\n    select.value = len(tab.sub_commands) - 1\n\ndef _show_sub_command(self, sub_index: int):\n    \"\"\"Show only the pane for the given sub-command index in the active tab.\"\"\"\n    container = self.query_one('#command-pane-container')\n    for pane in container.query(CommandPane):\n        pane.display = False\n    tab = self._tabs[self._active_tab]\n    if 0 &lt;= sub_index &lt; len(tab.sub_commands):\n        pane_id = tab.sub_commands[sub_index].pane_id\n        self.query_one(f'#{pane_id}', CommandPane).display = True\n</code></pre> <p>Step 4: Implement <code>_start_next_in_tab</code></p> <p>Finds the next pending sub-command in a tab and starts it.</p> <pre><code>def _start_next_in_tab(self, tab: TabState):\n    idx = tab.next_pending()\n    if idx is None:\n        return\n    sub = tab.sub_commands[idx]\n    sub.status = CommandStatus.RUNNING\n    self._refresh_tab_sidebar(tab.tab_index)\n    if self._active_tab == tab.tab_index:\n        self._refresh_select()\n    pane = self.query_one(f'#{sub.pane_id}', CommandPane)\n    pane.border_title = sub.name\n    pane.execute(sub.shell_command)\n</code></pre> <p>Step 5: Implement command completion handler</p> <p>When a <code>CommandPane.CommandComplete</code> fires, find which tab/sub-command it belongs to, update status, and start the next queued command.</p> <pre><code>def on_command_pane_command_complete(self, event: CommandPane.CommandComplete):\n    for tab in self._tabs:\n        for sub in tab.sub_commands:\n            if sub.status != CommandStatus.RUNNING:\n                continue\n            pane = self.query_one(f'#{sub.pane_id}', CommandPane)\n            if pane.return_code is None:\n                continue\n            if pane.return_code == 0:\n                sub.status = CommandStatus.SUCCESS\n                pane.border_subtitle = 'Done'\n            else:\n                sub.status = CommandStatus.FAILED\n                pane.border_subtitle = f'Exit code: {pane.return_code}'\n            self._refresh_tab_sidebar(tab.tab_index)\n            if self._active_tab == tab.tab_index:\n                self._refresh_select()\n            # Start next queued command in this tab\n            self._start_next_in_tab(tab)\n            if not self.parallel:\n                self._sequential_event.set()\n            return\n</code></pre> <p>Step 6: Implement sequential tab runner</p> <pre><code>async def _run_tabs_sequential(self):\n    self._sequential_event = asyncio.Event()\n    for tab in self._tabs:\n        self._sequential_event.clear()\n        self._start_next_in_tab(tab)\n        await self._sequential_event.wait()\n</code></pre> <p>Step 7: Implement tab sidebar helpers</p> <pre><code>def _make_tab_label(self, index: int) -&gt; str:\n    tab = self._tabs[index]\n    # Tab status: show worst status of sub-commands\n    if any(s.status == CommandStatus.FAILED for s in tab.sub_commands):\n        icon = _STATUS_MARKUP[CommandStatus.FAILED]\n    elif any(s.status == CommandStatus.RUNNING for s in tab.sub_commands):\n        icon = _STATUS_MARKUP[CommandStatus.RUNNING]\n    elif all(s.status == CommandStatus.SUCCESS for s in tab.sub_commands):\n        icon = _STATUS_MARKUP[CommandStatus.SUCCESS]\n    else:\n        icon = _STATUS_MARKUP[CommandStatus.PENDING]\n    return f'{icon} {tab.entry.display_name}'\n\ndef _refresh_tab_sidebar(self, tab_index: int):\n    item = self.query_one(f'#cmd-item-{tab_index}', ListItem)\n    label = item.query_one(Label)\n    label.update(self._make_tab_label(tab_index))\n</code></pre> <p>Step 8: Verify lint</p> <p>Run: <code>uv run ruff check rbx/box/ui/command_app.py</code></p> <p>Step 9: Commit</p> <pre><code>feat(ui): implement tab lifecycle and sub-command queue execution\n</code></pre>"},{"location":"plans/2026-02-25-command-app-tabs-design/#task-5-implement-input-handling-enter-and-shiftenter","title":"Task 5: Implement input handling (Enter and Shift+Enter)","text":"<p>Files: - Modify: <code>rbx/box/ui/command_app.py</code></p> <p>Step 1: Add <code>_queue_command</code> method</p> <p>This method adds a new sub-command to a tab, mounts a new CommandPane, and starts it if the tab is idle.</p> <pre><code>async def _queue_command(self, tab: TabState, user_input: str):\n    argv = shlex.split(user_input)\n    name = user_input\n    sub = tab.add_sub_command(name, argv)\n\n    # Mount the new pane\n    container = self.query_one('#command-pane-container')\n    pane = CommandPane(id=sub.pane_id)\n    await container.mount(pane)\n    pane.display = False\n\n    if tab.is_idle:\n        self._start_next_in_tab(tab)\n    else:\n        self.notify(\n            f'Command queued in {tab.entry.display_name}',\n            title='Queued',\n            timeout=3,\n        )\n\n    # Refresh UI if this is the active tab\n    if self._active_tab == tab.tab_index:\n        self._refresh_select()\n        # Switch view to the new sub-command\n        self._show_sub_command(len(tab.sub_commands) - 1)\n</code></pre> <p>Step 2: Handle Enter key on Input (current tab only)</p> <pre><code>async def on_input_submitted(self, event: Input.Submitted):\n    user_input = event.value.strip()\n    if not user_input:\n        return\n    event.input.value = ''\n    tab = self._tabs[self._active_tab]\n    await self._queue_command(tab, user_input)\n</code></pre> <p>Step 3: Handle Shift+Enter binding (all tabs)</p> <p>Add a binding for shift+enter and implement the handler.</p> <pre><code>BINDINGS = [\n    ('q', 'quit', 'Quit'),\n    ('shift+enter', 'submit_all', 'Run in all tabs'),\n]\n\nasync def action_submit_all(self):\n    input_widget = self.query_one('#command-input', Input)\n    user_input = input_widget.value.strip()\n    if not user_input:\n        return\n    input_widget.value = ''\n    for tab in self._tabs:\n        await self._queue_command(tab, user_input)\n</code></pre> <p>Step 4: Verify lint</p> <p>Run: <code>uv run ruff check rbx/box/ui/command_app.py</code></p> <p>Step 5: Commit</p> <pre><code>feat(ui): add input handling for Enter and Shift+Enter command queueing\n</code></pre>"},{"location":"plans/2026-02-25-command-app-tabs-design/#task-6-wire-up-select-dropdown-and-tab-switching","title":"Task 6: Wire up Select dropdown and tab switching","text":"<p>Files: - Modify: <code>rbx/box/ui/command_app.py</code></p> <p>Step 1: Handle Select.Changed to switch visible pane</p> <pre><code>def on_select_changed(self, event: Select.Changed):\n    if event.value is Select.BLANK:\n        return\n    self._show_sub_command(event.value)\n</code></pre> <p>Step 2: Handle ListView index change for tab switching</p> <pre><code>def _on_tab_selected(self, index: Optional[int]):\n    if index is None:\n        return\n    self._switch_to_tab(index)\n</code></pre> <p>Step 3: Verify lint</p> <p>Run: <code>uv run ruff check rbx/box/ui/command_app.py</code></p> <p>Step 4: Commit</p> <pre><code>feat(ui): wire up Select dropdown and tab switching\n</code></pre>"},{"location":"plans/2026-02-25-command-app-tabs-design/#task-7-manual-testing-and-polish","title":"Task 7: Manual testing and polish","text":"<p>Step 1: Test with the <code>__main__</code> block</p> <p>Update the <code>__main__</code> block to exercise multiple tabs, prefix, and cwd:</p> <pre><code>if __name__ == '__main__':\n    start_command_app([\n        CommandEntry(argv=['ls', '-l'], name='list', prefix='env'),\n        CommandEntry(argv=['echo', 'hello'], name='echo'),\n    ])\n</code></pre> <p>Run: <code>uv run python -m rbx.box.ui.command_app</code></p> <p>Verify: - Two tabs appear in sidebar - Each tab has a dropdown showing its initial command with status icon - Input box at the bottom accepts commands - Enter queues in current tab, Shift+Enter in all tabs - Toast notification appears when commands are queued - Dropdown updates with new commands as they are added - Selecting a dropdown entry switches the visible terminal</p> <p>Step 2: Verify existing callers still work</p> <p>Check <code>rbx/box/contest/main.py</code> \u2014 it only uses <code>CommandEntry(argv=..., name=..., cwd=...)</code> which is unchanged. The new <code>prefix</code> field defaults to <code>None</code>.</p> <p>Step 3: Final lint and format</p> <p>Run: <code>uv run ruff check rbx/box/ui/command_app.py &amp;&amp; uv run ruff format rbx/box/ui/command_app.py</code></p> <p>Step 4: Commit</p> <pre><code>feat(ui): finalize command app with tabbed command queuing\n</code></pre>"},{"location":"plans/2026-02-25-command-input-context-menu-design/","title":"Command Input Context Menu Design","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Replace the direct Enter-to-submit behavior in <code>rbxCommandApp</code> with a floating context menu that lets the user choose where to run the command: current tab, all tabs, or a custom selection of tabs.</p>"},{"location":"plans/2026-02-25-command-input-context-menu-design/#current-behavior","title":"Current Behavior","text":"<ul> <li>Enter in input box: submits command to the active tab</li> <li>Ctrl+O: submits command to all tabs</li> </ul>"},{"location":"plans/2026-02-25-command-input-context-menu-design/#new-behavior","title":"New Behavior","text":"<ul> <li>Enter in input box: shows a floating context menu above the input with 3 options:</li> <li>Run in this tab (pre-highlighted, so Enter+Enter = old behavior)</li> <li>Run in all tabs</li> <li>Run in selected tabs (opens a modal to pick tabs)</li> <li>Ctrl+O binding removed (functionality moved to menu option 2)</li> <li>Escape or blur dismisses the menu without running</li> </ul>"},{"location":"plans/2026-02-25-command-input-context-menu-design/#new-components","title":"New Components","text":""},{"location":"plans/2026-02-25-command-input-context-menu-design/#1-menu-widget-rbxboxuiwidgetsmenupy","title":"1. Menu Widget (<code>rbx/box/ui/widgets/menu.py</code>)","text":"<p>A floating overlay <code>ListView</code>, inspired by Toad's <code>Menu</code> widget.</p> <p>Data model: <pre><code>class MenuItem(NamedTuple):\n    description: str       # Display text (supports Textual markup)\n    action: str            # Action identifier\n    key: str | None = None # Optional single-char keyboard shortcut\n</code></pre></p> <p>Widget: - <code>Menu(ListView)</code> \u2014 takes <code>list[MenuItem]</code>, renders as absolute-positioned overlay - CSS: <code>position: absolute</code>, <code>overlay: screen</code>, <code>dock: bottom</code> (anchored above input) - First item pre-highlighted - Messages: <code>Menu.Selected(action: str)</code>, <code>Menu.Dismissed</code> - Dismiss on: Escape key, blur - Select on: Enter (highlighted item), single-char key shortcut, mouse click</p>"},{"location":"plans/2026-02-25-command-input-context-menu-design/#2-tab-selector-modal-rbxboxuiscreenstab_selectorpy","title":"2. Tab Selector Modal (<code>rbx/box/ui/screens/tab_selector.py</code>)","text":"<p>A Textual <code>ModalScreen</code> for choosing which tabs to run in.</p> <ul> <li>Displays a vertical list of tab names, each with a checkbox/toggle</li> <li>All unchecked by default</li> <li>Keyboard shortcuts: <code>a</code> = select all, <code>n</code> = deselect all</li> <li>Enter confirms selection, Escape cancels</li> <li>Returns <code>list[int]</code> of selected tab indices via screen dismiss callback</li> </ul>"},{"location":"plans/2026-02-25-command-input-context-menu-design/#3-changes-to-command_apppy","title":"3. Changes to <code>command_app.py</code>","text":"<ul> <li><code>on_input_submitted</code>: store raw command, mount <code>Menu</code> with 3 options above input</li> <li>Remove <code>ctrl+o</code> binding and <code>action_submit_all</code> method</li> <li>Handle <code>Menu.Selected</code>:</li> <li><code>\"run_this_tab\"</code> -&gt; <code>_submit_command(raw)</code></li> <li><code>\"run_all_tabs\"</code> -&gt; <code>_submit_command_all(raw)</code></li> <li><code>\"run_selected_tabs\"</code> -&gt; push <code>TabSelectorModal</code>, on callback call new <code>_submit_command_selected(raw, indices)</code></li> <li>Handle <code>Menu.Dismissed</code>: remove menu, refocus input</li> <li>New <code>_submit_command_selected(raw, indices)</code>: like <code>_submit_command_all</code> but only for given tab indices</li> </ul>"},{"location":"plans/2026-02-25-command-input-context-menu-design/#ux-flow","title":"UX Flow","text":"<pre><code>User types \"make test\" + Enter\n  -&gt; Menu appears above input:\n       [1] Run in this tab     (highlighted)\n       [2] Run in all tabs\n       [3] Run in selected tabs\n  -&gt; User presses Enter (or \"1\")\n       -&gt; command runs in current tab, menu dismissed\n  -&gt; User presses \"2\"\n       -&gt; command runs in all tabs, menu dismissed\n  -&gt; User presses \"3\"\n       -&gt; Modal appears with tab checkboxes\n       -&gt; User toggles tabs, presses Enter\n       -&gt; command runs in selected tabs, modal + menu dismissed\n  -&gt; User presses Escape\n       -&gt; Menu dismissed, command text restored to input\n</code></pre>"},{"location":"plans/2026-02-25-command-input-context-menu-design/#file-structure","title":"File Structure","text":"<pre><code>rbx/box/ui/\n  widgets/\n    menu.py              # Menu + MenuItem (NEW)\n  screens/\n    tab_selector.py      # TabSelectorModal (NEW)\n  command_app.py         # Modified wiring\n</code></pre>"},{"location":"plans/2026-02-25-command-input-context-menu/","title":"Command Input Context Menu Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Replace direct Enter-to-submit in <code>rbxCommandApp</code> with a floating context menu that lets the user choose to run the command in the current tab, all tabs, or a selected subset of tabs.</p> <p>Architecture: On Enter, a floating <code>Menu</code> widget (inspired by Toad's <code>Menu</code>) appears above the input with 3 options. \"Run in this tab\" is pre-highlighted so double-Enter preserves old quick workflow. \"Run in selected tabs\" opens a <code>TabSelectorModal</code> (using Textual's <code>SelectionList</code>). The Ctrl+O binding is removed.</p> <p>Tech Stack: Textual 8.0 (ListView, SelectionList, ModalScreen), Python dataclasses</p>"},{"location":"plans/2026-02-25-command-input-context-menu/#task-1-create-menu-widget","title":"Task 1: Create Menu widget","text":"<p>Files: - Create: <code>rbx/box/ui/widgets/menu.py</code></p> <p>Step 1: Create the Menu widget file</p> <p>This is a self-contained floating overlay menu inspired by <code>/private/tmp/toad/src/toad/widgets/menu.py</code>. Key differences from Toad: no <code>owner</code> parameter, no <code>_partition</code> (all items in order), simplified messages.</p> <pre><code>from __future__ import annotations\n\nfrom dataclasses import dataclass\nfrom typing import List, NamedTuple, Optional\n\nfrom textual import events, on\nfrom textual.app import ComposeResult\nfrom textual.binding import Binding\nfrom textual.message import Message\nfrom textual.widgets import Label, ListItem, ListView\n\n\nclass MenuItem(NamedTuple):\n    \"\"\"An entry in a Menu.\"\"\"\n\n    description: str\n    action: str\n    key: Optional[str] = None\n\n\nclass _MenuOptionLabel(Label):\n    ALLOW_SELECT = False\n\n\nclass MenuOption(ListItem):\n    ALLOW_SELECT = False\n\n    def __init__(\n        self, action: str, description: str, key: Optional[str]\n    ) -&gt; None:\n        self._action = action\n        self._description = description\n        self._key = key\n        super().__init__()\n\n    def compose(self) -&gt; ComposeResult:\n        yield _MenuOptionLabel(self._key or ' ', id='key')\n        yield _MenuOptionLabel(self._description, id='description')\n\n\nclass Menu(ListView, can_focus=True):\n    BINDINGS = [Binding('escape', 'dismiss', 'Dismiss')]\n\n    DEFAULT_CSS = \"\"\"\n    Menu {\n        width: auto;\n        height: auto;\n        max-width: 100%;\n        overlay: screen;\n        position: absolute;\n        color: $foreground;\n        background: $panel;\n        border: round $accent;\n        constrain: inside inside;\n        padding: 0;\n\n        &amp; &gt; MenuOption {\n            layout: horizontal;\n            width: 1fr;\n            padding: 0 1;\n            height: auto !important;\n            overflow: auto;\n            #description {\n                color: $text 80%;\n                width: 1fr;\n            }\n            #key {\n                padding-right: 1;\n                text-style: bold;\n            }\n        }\n\n        &amp;:blur {\n            background-tint: transparent;\n            &amp; &gt; ListItem.-highlight {\n                color: $block-cursor-blurred-foreground;\n                background: $block-cursor-blurred-background 30%;\n                text-style: $block-cursor-blurred-text-style;\n            }\n        }\n\n        &amp;:focus {\n            background-tint: transparent;\n            &amp; &gt; ListItem.-highlight {\n                color: $block-cursor-blurred-foreground;\n                background: $block-cursor-blurred-background;\n                text-style: $block-cursor-blurred-text-style;\n            }\n        }\n    }\n    \"\"\"\n\n    @dataclass\n    class Selected(Message):\n        menu: Menu\n        action: str\n\n    @dataclass\n    class Dismissed(Message):\n        menu: Menu\n\n    def __init__(self, options: List[MenuItem], *args, **kwargs) -&gt; None:\n        self._options = options\n        super().__init__(*args, **kwargs)\n\n    def on_mount(self) -&gt; None:\n        self.extend(\n            MenuOption(item.action, item.description, item.key)\n            for item in self._options\n        )\n\n    async def _activate_index(self, index: int) -&gt; None:\n        action = self._options[index].action\n        self.post_message(self.Selected(self, action))\n\n    async def action_dismiss(self) -&gt; None:\n        self.post_message(self.Dismissed(self))\n\n    async def on_blur(self) -&gt; None:\n        self.post_message(self.Dismissed(self))\n\n    @on(events.Key)\n    async def _on_key(self, event: events.Key) -&gt; None:\n        for index, option in enumerate(self._options):\n            if option.key is not None and event.key == option.key:\n                self.index = index\n                event.stop()\n                await self._activate_index(index)\n                break\n\n    @on(ListView.Selected)\n    async def _on_selected(self, event: ListView.Selected) -&gt; None:\n        event.stop()\n        if event.index is not None:\n            await self._activate_index(event.index)\n</code></pre> <p>Step 2: Verify lint</p> <p>Run: <code>uv run ruff check rbx/box/ui/widgets/menu.py &amp;&amp; uv run ruff format rbx/box/ui/widgets/menu.py</code></p> <p>Step 3: Commit</p> <pre><code>feat(ui): add Menu floating overlay widget\n</code></pre>"},{"location":"plans/2026-02-25-command-input-context-menu/#task-2-create-tabselectormodal-screen","title":"Task 2: Create TabSelectorModal screen","text":"<p>Files: - Create: <code>rbx/box/ui/screens/tab_selector.py</code> - Modify: <code>rbx/box/ui/css/app.tcss</code> (add styling for the modal)</p> <p>Step 1: Create the TabSelectorModal file</p> <p>Uses <code>SelectionList</code> (already used in <code>rbx/box/ui/screens/run.py</code>). Returns <code>list[int]</code> of selected tab indices on dismiss, or <code>None</code> on cancel.</p> <pre><code>from typing import List, Optional\n\nfrom textual.app import ComposeResult\nfrom textual.containers import Container, Horizontal\nfrom textual.screen import ModalScreen\nfrom textual.widgets import Button, SelectionList\nfrom textual.widgets.selection_list import Selection\n\n\nclass TabSelectorModal(ModalScreen[Optional[List[int]]]):\n    BINDINGS = [\n        ('escape', 'cancel', 'Cancel'),\n        ('a', 'select_all', 'Select all'),\n        ('n', 'deselect_all', 'Deselect all'),\n    ]\n\n    def __init__(self, tab_names: List[str]) -&gt; None:\n        super().__init__()\n        self._tab_names = tab_names\n\n    def compose(self) -&gt; ComposeResult:\n        with Container(id='tab-selector-dialog'):\n            selection_list = SelectionList[int](\n                *[\n                    Selection(name, index, False)\n                    for index, name in enumerate(self._tab_names)\n                ],\n                id='tab-selector-list',\n            )\n            selection_list.border_title = 'Select tabs'\n            yield selection_list\n            with Horizontal(id='tab-selector-buttons'):\n                yield Button('Run', variant='primary', id='tab-selector-run')\n                yield Button('Cancel', id='tab-selector-cancel')\n\n    def action_cancel(self) -&gt; None:\n        self.dismiss(None)\n\n    def action_select_all(self) -&gt; None:\n        self.query_one('#tab-selector-list', SelectionList).select_all()\n\n    def action_deselect_all(self) -&gt; None:\n        self.query_one('#tab-selector-list', SelectionList).deselect_all()\n\n    def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n        if event.button.id == 'tab-selector-run':\n            selected = list(\n                self.query_one('#tab-selector-list', SelectionList).selected\n            )\n            self.dismiss(selected)\n        elif event.button.id == 'tab-selector-cancel':\n            self.dismiss(None)\n</code></pre> <p>Step 2: Add CSS for the modal in <code>rbx/box/ui/css/app.tcss</code></p> <p>Append after the existing <code>#selector-dialog</code> block (after line 126):</p> <pre><code>#tab-selector-dialog {\n        max-width: 60;\n        height: auto;\n        max-height: 20;\n}\n\n#tab-selector-buttons {\n        height: auto;\n        width: 100%;\n}\n\n#tab-selector-buttons Button {\n        width: 1fr;\n}\n</code></pre> <p>Step 3: Verify lint</p> <p>Run: <code>uv run ruff check rbx/box/ui/screens/tab_selector.py &amp;&amp; uv run ruff format rbx/box/ui/screens/tab_selector.py</code></p> <p>Step 4: Commit</p> <pre><code>feat(ui): add TabSelectorModal screen for selecting tabs\n</code></pre>"},{"location":"plans/2026-02-25-command-input-context-menu/#task-3-wire-menu-and-tabselectormodal-into-command_apppy","title":"Task 3: Wire Menu and TabSelectorModal into command_app.py","text":"<p>Files: - Modify: <code>rbx/box/ui/command_app.py</code></p> <p>This is the main integration task. The changes are:</p> <p>Step 1: Update imports</p> <p>Add these imports at the top of <code>command_app.py</code>:</p> <pre><code>from textual import on\n\nfrom rbx.box.ui.screens.tab_selector import TabSelectorModal\nfrom rbx.box.ui.widgets.menu import Menu, MenuItem\n</code></pre> <p>Step 2: Remove Ctrl+O binding, add pending command state</p> <p>In <code>rbxCommandApp</code>: - Remove <code>('ctrl+o', 'submit_all', 'Run in all tabs')</code> from <code>BINDINGS</code> - Add <code>self._pending_command: Optional[str] = None</code> in <code>__init__</code></p> <p>The BINDINGS become:</p> <pre><code>BINDINGS = [\n    ('q', 'quit', 'Quit'),\n]\n</code></pre> <p>And in <code>__init__</code>, after <code>self._sequential_event</code>:</p> <pre><code>self._pending_command: Optional[str] = None\n</code></pre> <p>Step 3: Replace <code>on_input_submitted</code> to show Menu instead of direct submit</p> <p>Replace the existing <code>on_input_submitted</code> method with:</p> <pre><code>def _dismiss_menu(self) -&gt; None:\n    for menu in self.query(Menu):\n        menu.remove()\n\ndef on_input_submitted(self, event: Input.Submitted) -&gt; None:\n    if event.input.id != 'command-input':\n        return\n    raw = event.value.strip()\n    if not raw:\n        return\n    event.input.value = ''\n\n    # Dismiss any existing menu first.\n    self._dismiss_menu()\n\n    self._pending_command = raw\n    menu = Menu(\n        [\n            MenuItem('Run in this tab', 'run_this_tab', '1'),\n            MenuItem('Run in all tabs', 'run_all_tabs', '2'),\n            MenuItem('Run in selected tabs', 'run_selected_tabs', '3'),\n        ],\n    )\n    input_container = self.query_one('#command-input-container', Horizontal)\n    input_container.mount(menu)\n    menu.focus()\n</code></pre> <p>Step 4: Add Menu.Selected and Menu.Dismissed handlers</p> <pre><code>@on(Menu.Selected)\ndef _on_menu_selected(self, event: Menu.Selected) -&gt; None:\n    event.stop()\n    raw = self._pending_command\n    self._pending_command = None\n    event.menu.remove()\n\n    if raw is None:\n        return\n\n    if event.action == 'run_this_tab':\n        self._submit_command(raw)\n    elif event.action == 'run_all_tabs':\n        self._submit_command_all(raw)\n    elif event.action == 'run_selected_tabs':\n        tab_names = [tab.entry.display_name for tab in self._tabs]\n        self.push_screen(\n            TabSelectorModal(tab_names),\n            callback=lambda indices: self._on_tabs_selected(raw, indices),\n        )\n\n@on(Menu.Dismissed)\ndef _on_menu_dismissed(self, event: Menu.Dismissed) -&gt; None:\n    event.stop()\n    raw = self._pending_command\n    self._pending_command = None\n    event.menu.remove()\n\n    # Restore command text to input.\n    if raw is not None:\n        input_widget = self.query_one('#command-input', Input)\n        input_widget.value = raw\n    input_widget = self.query_one('#command-input', Input)\n    input_widget.focus()\n</code></pre> <p>Step 5: Add <code>_on_tabs_selected</code> and <code>_submit_command_selected</code> methods</p> <pre><code>def _on_tabs_selected(\n    self, raw: str, indices: Optional[List[int]]\n) -&gt; None:\n    if indices is None or not indices:\n        return\n    self._submit_command_selected(raw, indices)\n\ndef _submit_command_selected(self, raw_input: str, tab_indices: List[int]) -&gt; None:\n    for i in tab_indices:\n        tab = self._tabs[i]\n        sub = self._queue_command_in_tab(i, raw_input)\n        if sub.status == CommandStatus.PENDING:\n            self.notify(f'Command queued in {tab.entry.display_name}')\n\n    # Switch to the active tab's latest sub-command if it was selected.\n    if self._active_tab in tab_indices:\n        active_tab = self._tabs[self._active_tab]\n        self._refresh_select()\n        select = self.query_one('#command-select', Select)\n        if active_tab.sub_commands:\n            select.value = len(active_tab.sub_commands) - 1\n            self._show_pane(active_tab.sub_commands[-1].pane_id)\n</code></pre> <p>Step 6: Remove <code>action_submit_all</code> method</p> <p>Delete the entire <code>action_submit_all</code> method (lines 502-508 in current file).</p> <p>Step 7: Verify lint</p> <p>Run: <code>uv run ruff check rbx/box/ui/command_app.py &amp;&amp; uv run ruff format rbx/box/ui/command_app.py</code></p> <p>Step 8: Commit</p> <pre><code>feat(ui): wire context menu into command input submission\n</code></pre>"},{"location":"plans/2026-02-25-command-input-context-menu/#task-4-manual-testing-and-polish","title":"Task 4: Manual testing and polish","text":"<p>Step 1: Test with the <code>__main__</code> block</p> <p>Run: <code>uv run python -m rbx.box.ui.command_app</code></p> <p>Verify: - Type a command and press Enter -&gt; Menu appears above input with 3 options - \"Run in this tab\" is highlighted by default - Press Enter again -&gt; runs in current tab, menu disappears - Type command + Enter + \"2\" -&gt; runs in all tabs (only tab in this test, but no crash) - Type command + Enter + \"3\" -&gt; modal appears with tab checkboxes - In modal: <code>a</code> selects all, <code>n</code> deselects all - In modal: Enter confirms, Escape cancels - Press Escape on menu -&gt; menu dismissed, command text restored to input - Blur (click elsewhere) -&gt; menu dismissed</p> <p>Step 2: Test with multiple tabs</p> <p>Update <code>__main__</code> block:</p> <pre><code>if __name__ == '__main__':\n    start_command_app([\n        CommandEntry(argv=['echo', 'hello'], name='echo1'),\n        CommandEntry(argv=['echo', 'world'], name='echo2'),\n        CommandEntry(argv=['echo', 'foo'], name='echo3'),\n    ])\n</code></pre> <p>Verify: - \"Run in selected tabs\" -&gt; modal shows all 3 tab names - Toggle individual tabs, confirm -&gt; command only queued in selected tabs - \"Run in all tabs\" -&gt; command queued in all 3</p> <p>Step 3: Verify no regressions</p> <p>Run: <code>uv run ruff check rbx/box/ui/ &amp;&amp; uv run ruff format --check rbx/box/ui/</code></p> <p>Step 4: Commit</p> <pre><code>feat(ui): finalize command input context menu\n</code></pre>"},{"location":"plans/2026-02-26-task-queue-design/","title":"TaskQueue Design for command_app.py","text":"<p>Date: 2026-02-26</p>"},{"location":"plans/2026-02-26-task-queue-design/#problem","title":"Problem","text":"<p>The execution scheduling logic in <code>rbxCommandApp</code> is spread across multiple methods (<code>_start_next_in_tab</code>, <code>_start_next_sequentially</code>, <code>_run_initial_sequential</code>, <code>_queue_command_in_tab</code>, <code>on_command_pane_command_complete</code>) interleaved with UI concerns. The parallel vs sequential distinction is handled via ad-hoc branching throughout the app.</p>"},{"location":"plans/2026-02-26-task-queue-design/#solution","title":"Solution","text":"<p>Extract a pure <code>TaskQueue</code> class that owns the scheduling lifecycle: enqueue \u2192 drain eligible \u2192 signal ready \u2192 notify complete \u2192 drain again.</p>"},{"location":"plans/2026-02-26-task-queue-design/#data-model","title":"Data Model","text":"<pre><code>class TaskStatus(enum.Enum):\n    PENDING = 'pending'\n    RUNNING = 'running'\n    COMPLETED = 'completed'\n\n@dataclasses.dataclass\nclass Task:\n    task_id: int        # Auto-assigned by queue\n    command: str        # Shell command to execute\n    terminal_id: int    # Which terminal/tab this runs in\n    exclusive: bool     # If True, runs alone (all terminals idle)\n    status: TaskStatus  # PENDING \u2192 RUNNING \u2192 COMPLETED\n</code></pre>"},{"location":"plans/2026-02-26-task-queue-design/#taskqueue-class","title":"TaskQueue Class","text":"<pre><code>class TaskQueue:\n    def __init__(self, num_terminals, parallel, on_task_ready):\n        ...\n\n    def enqueue(self, command: str, terminal_id: int) -&gt; Task\n    def notify_complete(self, task_id: int) -&gt; None\n    def _is_exclusive(self, command: str, terminal_id: int) -&gt; bool\n    def _drain(self) -&gt; None\n</code></pre>"},{"location":"plans/2026-02-26-task-queue-design/#drain-rules","title":"Drain Rules","text":"<p>Iterates the queue in insertion order. A PENDING task can be popped if:</p> <ol> <li>No older PENDING task for the same terminal exists ahead of it</li> <li>The terminal is idle (no RUNNING task)</li> <li>If exclusive, ALL terminals must be idle</li> </ol> <p>When popped: mark RUNNING, update terminal state, fire <code>on_task_ready</code> callback.</p>"},{"location":"plans/2026-02-26-task-queue-design/#exclusivity","title":"Exclusivity","text":"<p><code>_is_exclusive(command, terminal_id)</code> is the override point. Current logic: returns <code>not self._parallel</code>. User will add more logic later.</p>"},{"location":"plans/2026-02-26-task-queue-design/#integration-with-rbxcommandapp","title":"Integration with rbxCommandApp","text":"<ol> <li> <p>Construction: <code>TaskQueue</code> created in <code>__init__</code> with    <code>on_task_ready=lambda t: self.post_message(TaskReady(t))</code></p> </li> <li> <p>TaskReady message: New Textual <code>Message</code> subclass carrying a <code>Task</code>.    Handler finds the pane, updates status markup, calls <code>pane.execute(task.command)</code>.</p> </li> <li> <p>Completion: <code>on_command_pane_command_complete</code> calls    <code>queue.notify_complete(task_id)</code> instead of manual scheduling logic.</p> </li> <li> <p>Enqueuing: <code>_queue_command_in_tab</code> calls <code>queue.enqueue()</code> instead of    manually checking idle state and parallel mode.</p> </li> <li> <p>Initial commands: <code>on_mount</code> enqueues all initial commands. The queue's    drain logic handles both parallel and sequential automatically.</p> </li> <li> <p>Removed methods: <code>_run_initial_sequential</code>, <code>_sequential_event</code>,    <code>_start_next_in_tab</code>, <code>_start_next_sequentially</code>, <code>_any_tab_running</code>.</p> </li> <li> <p>SubCommand linkage: <code>SubCommand</code> gains a <code>task_id</code> field to link UI    state to queue tasks for the completion handler.</p> </li> <li> <p>TabState/SubCommand: Remain for UI state (pane IDs, select widget,    sidebar labels). Queue only owns scheduling.</p> </li> </ol>"},{"location":"plans/2026-02-26-task-queue/","title":"TaskQueue Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Extract a pure <code>TaskQueue</code> class that owns command scheduling, replacing ad-hoc parallel/sequential logic in <code>rbxCommandApp</code>.</p> <p>Architecture: A standalone <code>TaskQueue</code> class manages an ordered queue of <code>Task</code> objects, tracks terminal idle state, and fires a callback when tasks become ready. The app wires the callback to a Textual <code>Message</code>, keeping scheduling logic fully separated from UI. <code>TabState</code>/<code>SubCommand</code> remain for UI state; <code>SubCommand</code> gains a <code>task_id</code> to bridge the two.</p> <p>Tech Stack: Python dataclasses, enum, Textual messages, pytest</p> <p>Design doc: <code>docs/plans/2026-02-26-task-queue-design.md</code></p>"},{"location":"plans/2026-02-26-task-queue/#task-1-add-taskqueue-class-with-tests","title":"Task 1: Add TaskQueue class with tests","text":"<p>Files: - Create: <code>rbx/box/ui/task_queue.py</code> - Create: <code>tests/rbx/box/ui/__init__.py</code> - Create: <code>tests/rbx/box/ui/test_task_queue.py</code></p> <p>Step 1: Create test directory and empty init</p> <p>Create <code>tests/rbx/box/ui/__init__.py</code> (empty file).</p> <p>Step 2: Write failing tests for TaskQueue</p> <p>Create <code>tests/rbx/box/ui/test_task_queue.py</code>:</p> <pre><code>from rbx.box.ui.task_queue import Task, TaskQueue, TaskStatus\n\n\nclass TestTaskQueue:\n    def _make_queue(self, num_terminals=3, parallel=True):\n        self.ready_tasks = []\n        return TaskQueue(\n            num_terminals=num_terminals,\n            parallel=parallel,\n            on_task_ready=lambda t: self.ready_tasks.append(t),\n        )\n\n    def test_enqueue_starts_immediately_when_idle(self):\n        q = self._make_queue()\n        task = q.enqueue('echo hello', terminal_id=0)\n        assert task.status == TaskStatus.RUNNING\n        assert len(self.ready_tasks) == 1\n        assert self.ready_tasks[0] is task\n\n    def test_enqueue_stays_pending_when_terminal_busy(self):\n        q = self._make_queue()\n        t1 = q.enqueue('echo first', terminal_id=0)\n        t2 = q.enqueue('echo second', terminal_id=0)\n        assert t1.status == TaskStatus.RUNNING\n        assert t2.status == TaskStatus.PENDING\n        assert len(self.ready_tasks) == 1\n\n    def test_notify_complete_starts_next_in_same_terminal(self):\n        q = self._make_queue()\n        t1 = q.enqueue('echo first', terminal_id=0)\n        t2 = q.enqueue('echo second', terminal_id=0)\n        q.notify_complete(t1.task_id)\n        assert t1.status == TaskStatus.COMPLETED\n        assert t2.status == TaskStatus.RUNNING\n        assert len(self.ready_tasks) == 2\n\n    def test_parallel_different_terminals_run_concurrently(self):\n        q = self._make_queue(parallel=True)\n        t1 = q.enqueue('echo a', terminal_id=0)\n        t2 = q.enqueue('echo b', terminal_id=1)\n        assert t1.status == TaskStatus.RUNNING\n        assert t2.status == TaskStatus.RUNNING\n        assert len(self.ready_tasks) == 2\n\n    def test_exclusive_waits_for_all_idle(self):\n        q = self._make_queue(parallel=False)\n        t1 = q.enqueue('echo a', terminal_id=0)\n        t2 = q.enqueue('echo b', terminal_id=1)\n        # Sequential mode: all exclusive. t1 runs, t2 waits.\n        assert t1.status == TaskStatus.RUNNING\n        assert t2.status == TaskStatus.PENDING\n        # Complete t1 -&gt; t2 starts.\n        q.notify_complete(t1.task_id)\n        assert t2.status == TaskStatus.RUNNING\n\n    def test_exclusive_blocks_behind_running_other_terminal(self):\n        \"\"\"An exclusive task must wait even if its own terminal is idle.\"\"\"\n        q = self._make_queue(parallel=True)\n        t1 = q.enqueue('echo a', terminal_id=0)\n        # Manually enqueue an exclusive task on terminal 1.\n        t2 = Task(\n            task_id=0, command='exclusive cmd', terminal_id=1,\n            exclusive=True, status=TaskStatus.PENDING,\n        )\n        # Use internal API to force an exclusive task in parallel mode.\n        q._queue.append(t2)\n        q._next_id = max(q._next_id, t2.task_id + 1)\n        q._drain()\n        # t1 is running on terminal 0, so exclusive t2 can't start.\n        assert t2.status == TaskStatus.PENDING\n        # Complete t1 -&gt; now all idle -&gt; t2 starts.\n        q.notify_complete(t1.task_id)\n        assert t2.status == TaskStatus.RUNNING\n\n    def test_ordering_same_terminal_preserved(self):\n        \"\"\"Tasks on the same terminal run in FIFO order.\"\"\"\n        q = self._make_queue()\n        t1 = q.enqueue('echo 1', terminal_id=0)\n        t2 = q.enqueue('echo 2', terminal_id=0)\n        t3 = q.enqueue('echo 3', terminal_id=0)\n        assert [t.status for t in [t1, t2, t3]] == [\n            TaskStatus.RUNNING, TaskStatus.PENDING, TaskStatus.PENDING,\n        ]\n        q.notify_complete(t1.task_id)\n        assert t2.status == TaskStatus.RUNNING\n        assert t3.status == TaskStatus.PENDING\n        q.notify_complete(t2.task_id)\n        assert t3.status == TaskStatus.RUNNING\n\n    def test_non_exclusive_skips_blocked_terminal(self):\n        \"\"\"A task on terminal 1 can start even if terminal 0 has a pending task blocked behind a running one.\"\"\"\n        q = self._make_queue()\n        t1 = q.enqueue('echo a', terminal_id=0)\n        t2 = q.enqueue('echo b', terminal_id=0)  # blocked behind t1\n        t3 = q.enqueue('echo c', terminal_id=1)\n        assert t1.status == TaskStatus.RUNNING\n        assert t2.status == TaskStatus.PENDING\n        assert t3.status == TaskStatus.RUNNING\n\n    def test_auto_increments_task_id(self):\n        q = self._make_queue()\n        t1 = q.enqueue('echo a', terminal_id=0)\n        t2 = q.enqueue('echo b', terminal_id=1)\n        assert t1.task_id == 0\n        assert t2.task_id == 1\n\n    def test_notify_complete_unknown_id_is_noop(self):\n        q = self._make_queue()\n        q.notify_complete(999)  # Should not raise.\n</code></pre> <p>Step 3: Run tests to verify they fail</p> <p>Run: <code>uv run pytest tests/rbx/box/ui/test_task_queue.py -v</code> Expected: ImportError \u2014 <code>rbx.box.ui.task_queue</code> does not exist.</p> <p>Step 4: Implement TaskQueue</p> <p>Create <code>rbx/box/ui/task_queue.py</code>:</p> <pre><code>import dataclasses\nimport enum\nfrom typing import Callable, List, Optional\n\n\nclass TaskStatus(enum.Enum):\n    PENDING = 'pending'\n    RUNNING = 'running'\n    COMPLETED = 'completed'\n\n\n@dataclasses.dataclass\nclass Task:\n    task_id: int\n    command: str\n    terminal_id: int\n    exclusive: bool\n    status: TaskStatus\n\n\nclass TaskQueue:\n    def __init__(\n        self,\n        num_terminals: int,\n        parallel: bool,\n        on_task_ready: Callable[[Task], None],\n    ):\n        self._num_terminals = num_terminals\n        self._parallel = parallel\n        self._on_task_ready = on_task_ready\n        self._queue: List[Task] = []\n        self._next_id: int = 0\n        self._terminal_running: List[bool] = [False] * num_terminals\n\n    def enqueue(self, command: str, terminal_id: int) -&gt; Task:\n        exclusive = self._is_exclusive(command, terminal_id)\n        task = Task(\n            task_id=self._next_id,\n            command=command,\n            terminal_id=terminal_id,\n            exclusive=exclusive,\n            status=TaskStatus.PENDING,\n        )\n        self._next_id += 1\n        self._queue.append(task)\n        self._drain()\n        return task\n\n    def notify_complete(self, task_id: int) -&gt; None:\n        task = self._find_task(task_id)\n        if task is None:\n            return\n        task.status = TaskStatus.COMPLETED\n        self._terminal_running[task.terminal_id] = False\n        self._drain()\n\n    def _is_exclusive(self, command: str, terminal_id: int) -&gt; bool:\n        return not self._parallel\n\n    def _find_task(self, task_id: int) -&gt; Optional[Task]:\n        for task in self._queue:\n            if task.task_id == task_id:\n                return task\n        return None\n\n    def _drain(self) -&gt; None:\n        # Track which terminals we've seen a PENDING task for\n        # (to enforce \"no older pending task for same terminal\" rule).\n        seen_pending: set[int] = set()\n\n        for task in self._queue:\n            if task.status != TaskStatus.PENDING:\n                continue\n\n            terminal = task.terminal_id\n            # Rule 1: no older pending task for same terminal.\n            if terminal in seen_pending:\n                continue\n            # Rule 2: terminal is idle.\n            if self._terminal_running[terminal]:\n                seen_pending.add(terminal)\n                continue\n            # Rule 3: if exclusive, all terminals must be idle.\n            if task.exclusive and any(self._terminal_running):\n                seen_pending.add(terminal)\n                continue\n\n            # Start this task.\n            task.status = TaskStatus.RUNNING\n            self._terminal_running[terminal] = True\n            self._on_task_ready(task)\n\n            seen_pending.add(terminal)\n</code></pre> <p>Step 5: Run tests to verify they pass</p> <p>Run: <code>uv run pytest tests/rbx/box/ui/test_task_queue.py -v</code> Expected: All 10 tests PASS.</p> <p>Step 6: Commit</p> <pre><code>feat(ui): add TaskQueue class for command scheduling\n</code></pre>"},{"location":"plans/2026-02-26-task-queue/#task-2-integrate-taskqueue-into-rbxcommandapp","title":"Task 2: Integrate TaskQueue into rbxCommandApp","text":"<p>Files: - Modify: <code>rbx/box/ui/command_app.py</code></p> <p>Step 1: Add TaskReady message and task_id to SubCommand</p> <p>In <code>command_app.py</code>, add import for <code>Task</code> and <code>TaskQueue</code> from <code>rbx.box.ui.task_queue</code>. Add <code>task_id: Optional[int] = None</code> field to the <code>SubCommand</code> dataclass. Add a <code>TaskReady</code> message class inside <code>rbxCommandApp</code>:</p> <pre><code>class TaskReady(Message):\n    def __init__(self, task: Task):\n        self.task = task\n        super().__init__()\n</code></pre> <p>Step 2: Create TaskQueue in init and remove old scheduling state</p> <p>In <code>rbxCommandApp.__init__</code>: - Remove <code>self._sequential_event</code> - Create <code>self._task_queue = TaskQueue(num_terminals=len(commands), parallel=parallel, on_task_ready=lambda t: self.post_message(self.TaskReady(t)))</code></p> <p>Step 3: Replace on_mount scheduling with queue.enqueue</p> <p>Replace the initial command starting logic at the end of <code>on_mount</code> (the <code>if self.parallel</code> / <code>else</code> block and <code>_run_initial_sequential</code>) with:</p> <pre><code>for i, tab in enumerate(self._tabs):\n    for sub in tab.sub_commands:\n        task = self._task_queue.enqueue(sub.shell_command, terminal_id=i)\n        sub.task_id = task.task_id\n</code></pre> <p>Remove the <code>_run_initial_sequential</code> method entirely.</p> <p>Step 4: Add TaskReady handler</p> <p>Add handler that starts the command in the pane:</p> <pre><code>def on_rbx_command_app_task_ready(self, event: TaskReady) -&gt; None:\n    task = event.task\n    tab = self._tabs[task.terminal_id]\n    # Find the sub-command linked to this task.\n    sub = next((s for s in tab.sub_commands if s.task_id == task.task_id), None)\n    if sub is None:\n        return\n    sub.status = CommandStatus.RUNNING\n    self._update_sidebar(task.terminal_id)\n    self._refresh_select_if_active(task.terminal_id)\n    pane = self.query_one(f'#{sub.pane_id}', CommandPane)\n    pane.execute(task.command)\n</code></pre> <p>Step 5: Simplify on_command_pane_command_complete</p> <p>Replace the scheduling logic in the completion handler. After finding the completed sub-command and updating its status, just call:</p> <pre><code>self._task_queue.notify_complete(sub.task_id)\n</code></pre> <p>Remove the <code>if self.parallel</code> / <code>else</code> branching and <code>_sequential_event</code> logic.</p> <p>Step 6: Simplify _queue_command_in_tab</p> <p>Replace the idle-check and start logic at the bottom of <code>_queue_command_in_tab</code> with:</p> <pre><code>task = self._task_queue.enqueue(sub.shell_command, terminal_id=tab_index)\nsub.task_id = task.task_id\n</code></pre> <p>Remove the <code>was_idle</code> check and <code>self.parallel or not self._any_tab_running()</code> logic.</p> <p>Step 7: Remove dead methods</p> <p>Delete these methods from <code>rbxCommandApp</code>: - <code>_start_next_in_tab</code> - <code>_start_next_sequentially</code> - <code>_run_initial_sequential</code> - <code>_any_tab_running</code></p> <p>Step 8: Remove unused imports/fields</p> <ul> <li>Remove <code>self._sequential_event</code> field</li> <li>Remove <code>asyncio</code> import if no longer used (check if anything else uses it)</li> </ul> <p>Step 9: Run the app manually to verify</p> <p>Run: <code>uv run python -m rbx.box.ui.command_app</code> Expected: Three echo commands run. In default (non-parallel) mode they should run sequentially.</p> <p>Step 10: Commit</p> <pre><code>refactor(ui): integrate TaskQueue into rbxCommandApp\n</code></pre>"},{"location":"plans/2026-02-26-task-queue/#task-3-verify-no-regressions","title":"Task 3: Verify no regressions","text":"<p>Files: None (verification only)</p> <p>Step 1: Run linter</p> <p>Run: <code>uv run ruff check rbx/box/ui/command_app.py rbx/box/ui/task_queue.py</code> Expected: No errors.</p> <p>Step 2: Run all unit tests</p> <p>Run: <code>uv run pytest tests/rbx/box/ui/test_task_queue.py -v</code> Expected: All pass.</p> <p>Step 3: Run full test suite (excluding CLI)</p> <p>Run: <code>uv run pytest --ignore=tests/rbx/box/cli -x</code> Expected: All pass, no import errors.</p> <p>Step 4: Commit if any fixes were needed</p> <pre><code>fix(ui): address linting issues from TaskQueue integration\n</code></pre>"},{"location":"plans/2026-02-28-limits-editor-design/","title":"Limits Editor UI Design","text":""},{"location":"plans/2026-02-28-limits-editor-design/#goal","title":"Goal","text":"<p>Add a Limits Editor screen to <code>rbx ui</code> for viewing and editing limits profiles (<code>.limits/*.yml</code>). Profiles control time/memory limits used by <code>rbx run</code>, <code>rbx time</code>, and statement generation.</p>"},{"location":"plans/2026-02-28-limits-editor-design/#layout","title":"Layout","text":"<p>Left sidebar (<code>ListView</code>) with profile names + \"+ New Profile\" entry. Right panel is a scrollable form for the selected profile.</p> <pre><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 Profiles     \u2502  Limits Editor: \"local\"              \u2502\n\u2502              \u2502                                      \u2502\n\u2502 &gt; local      \u2502  Inherit from package: [ ] No        \u2502\n\u2502   judge      \u2502                                      \u2502\n\u2502              \u2502  \u2500\u2500 Global Limits \u2500\u2500                  \u2502\n\u2502   + New      \u2502  Time Limit (ms):  [  2000  ]        \u2502\n\u2502              \u2502  Memory Limit (MB):[  256   ]         \u2502\n\u2502              \u2502                                      \u2502\n\u2502              \u2502  \u2500\u2500 Per-Language Overrides \u2500\u2500         \u2502\n\u2502              \u2502  cpp:                                \u2502\n\u2502              \u2502    Time (ms):       [  1500  ]        \u2502\n\u2502              \u2502    Time Multiplier: [       ]         \u2502\n\u2502              \u2502    Memory (MB):     [       ]         \u2502\n\u2502              \u2502                                      \u2502\n\u2502              \u2502  [+ Add Language]  [Save (Ctrl+S)]    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"plans/2026-02-28-limits-editor-design/#behavior","title":"Behavior","text":""},{"location":"plans/2026-02-28-limits-editor-design/#profile-selection","title":"Profile selection","text":"<ul> <li>Sidebar lists profiles from <code>.limits/*.yml</code> plus \"+ New Profile\"</li> <li>Selecting a profile loads its raw (unexpanded) data into the form</li> <li>\"+ New Profile\" prompts for a name, creates an empty profile</li> <li>Delete profile via keybinding (<code>d</code>/<code>delete</code>) with confirmation</li> </ul>"},{"location":"plans/2026-02-28-limits-editor-design/#inherit-toggle","title":"Inherit toggle","text":"<ul> <li>ON: global limits and per-language sections show package limits read-only</li> <li>OFF: form inputs become editable, package values shown as placeholders</li> </ul>"},{"location":"plans/2026-02-28-limits-editor-design/#per-language-modifiers","title":"Per-language modifiers","text":"<ul> <li>Languages from <code>environment.get_environment().languages</code> shown by default</li> <li>\"+ Add Language\" allows typing a custom language key</li> <li>Each language row: Time (ms), Time Multiplier, Memory (MB) -- all optional</li> <li>Empty fields = no override (excluded from YAML)</li> </ul>"},{"location":"plans/2026-02-28-limits-editor-design/#saving","title":"Saving","text":"<ul> <li><code>ctrl+s</code> or Save button writes to <code>.limits/{profile}.yml</code></li> <li>Uses <code>utils.model_to_yaml()</code> on a constructed <code>LimitsProfile</code></li> <li>Brief notification confirms save</li> </ul>"},{"location":"plans/2026-02-28-limits-editor-design/#validation","title":"Validation","text":"<ul> <li>TL/ML: positive integers or empty</li> <li>Time multiplier: positive float or empty</li> <li>Invalid values show inline error styling</li> </ul>"},{"location":"plans/2026-02-28-limits-editor-design/#data-flow","title":"Data flow","text":"<ol> <li>Load profile names: <code>limits_info.get_available_profile_names()</code></li> <li>Load raw profile: <code>limits_info.get_saved_limits_profile(name)</code></li> <li>Package limits: <code>package.find_problem_package_or_die()</code> for inherit display and placeholders</li> <li>Languages: <code>environment.get_environment().languages</code></li> <li>Save: construct <code>LimitsProfile</code> from form, serialize, write to <code>package.get_limits_file(profile)</code></li> </ol>"},{"location":"plans/2026-02-28-limits-editor-design/#files","title":"Files","text":"<ul> <li>New: <code>rbx/box/ui/screens/limits_editor.py</code></li> <li>Modified: <code>rbx/box/ui/css/app.tcss</code> (new screen styles)</li> <li>Modified: <code>rbx/box/ui/main.py</code> (add menu entry)</li> </ul>"},{"location":"plans/2026-02-28-limits-editor-design/#widgets","title":"Widgets","text":"<p><code>Input</code> (numeric fields), <code>Switch</code> (inherit toggle), <code>Button</code> (save, add language), <code>ListView</code> (sidebar), <code>Label</code>/<code>Static</code> (headers, read-only), <code>VerticalScroll</code> (right panel)</p>"},{"location":"plans/2026-02-28-limits-editor/","title":"Limits Editor UI Implementation Plan","text":"<p>For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.</p> <p>Goal: Add a Limits Editor screen to <code>rbx ui</code> for viewing, creating, and editing limits profiles (<code>.limits/*.yml</code>).</p> <p>Architecture: New <code>LimitsEditorScreen</code> added as third option in the main <code>rbxApp</code> menu. Left sidebar <code>ListView</code> lists profiles + \"New\" entry. Right panel is a scrollable form with <code>Switch</code> (inherit toggle), <code>Input</code> fields (TL, ML, per-language modifiers), and Save button. Data flows from <code>.limits/*.yml</code> files through <code>limits_info</code> helpers, and saves back via <code>utils.model_to_yaml()</code>.</p> <p>Tech Stack: Textual (&gt;=8.0), Pydantic v2 (<code>LimitsProfile</code>, <code>LimitModifiers</code>), <code>rbx.box.limits_info</code>, <code>rbx.box.environment</code></p>"},{"location":"plans/2026-02-28-limits-editor/#task-1-create-the-limitseditorscreen-skeleton-with-sidebar","title":"Task 1: Create the LimitsEditorScreen skeleton with sidebar","text":"<p>Files: - Create: <code>rbx/box/ui/screens/limits_editor.py</code> - Modify: <code>rbx/box/ui/main.py:17-20</code> (add menu entry) - Modify: <code>rbx/box/ui/css/app.tcss</code> (add styles)</p> <p>Step 1: Create the screen file with sidebar and empty detail pane</p> <p>Create <code>rbx/box/ui/screens/limits_editor.py</code>:</p> <pre><code>import pathlib\nfrom typing import Dict, List, Optional\n\nfrom textual.app import ComposeResult\nfrom textual.containers import Horizontal, Vertical, VerticalScroll\nfrom textual.screen import Screen\nfrom textual.widgets import Footer, Header, Label, ListItem, ListView, Static\n\nfrom rbx.box import limits_info, package\nfrom rbx.box.schema import LimitsProfile\n\n\nclass LimitsEditorScreen(Screen):\n    BINDINGS = [\n        ('q', 'app.pop_screen', 'Quit'),\n    ]\n\n    def __init__(self):\n        super().__init__()\n        self._profile_names: List[str] = []\n        self._selected_profile: Optional[str] = None\n\n    def compose(self) -&gt; ComposeResult:\n        yield Header()\n        yield Footer()\n        with Horizontal(id='limits-editor'):\n            with Vertical(id='limits-sidebar'):\n                yield ListView(id='limits-profile-list')\n            with VerticalScroll(id='limits-detail'):\n                yield Static('Select a profile', id='limits-placeholder')\n\n    async def on_mount(self):\n        self.query_one('#limits-profile-list').border_title = 'Profiles'\n        await self._load_profiles()\n        self.watch(\n            self.query_one('#limits-profile-list', ListView),\n            'index',\n            self._on_profile_selected,\n        )\n\n    async def _load_profiles(self):\n        self._profile_names = limits_info.get_available_profile_names()\n        lv = self.query_one('#limits-profile-list', ListView)\n        await lv.clear()\n        items = [ListItem(Label(name)) for name in self._profile_names]\n        items.append(ListItem(Label('[dim]+ New Profile[/dim]', markup=True)))\n        await lv.extend(items)\n\n    def _on_profile_selected(self, index: Optional[int]):\n        if index is None:\n            return\n        if index == len(self._profile_names):\n            # \"+ New Profile\" selected - will be handled in Task 4\n            return\n        self._selected_profile = self._profile_names[index]\n</code></pre> <p>Step 2: Add the menu entry in main.py</p> <p>In <code>rbx/box/ui/main.py</code>, add the import (line 15 area) and extend <code>SCREEN_OPTIONS</code> (line 17-20):</p> <pre><code># Add import:\nfrom rbx.box.ui.screens.limits_editor import LimitsEditorScreen\n\n# Extend SCREEN_OPTIONS:\nSCREEN_OPTIONS = [\n    ('Explore tests built by `rbx build`.', TestExplorerScreen),\n    ('Explore results of a past `rbx run`.', RunExplorerScreen),\n    ('Edit limits profiles.', LimitsEditorScreen),\n]\n</code></pre> <p>Step 3: Add CSS for the new screen</p> <p>Append to <code>rbx/box/ui/css/app.tcss</code>:</p> <pre><code>LimitsEditorScreen {\n    #limits-sidebar {\n        min-width: 20;\n        max-width: 30;\n        height: 1fr;\n    }\n    #limits-profile-list {\n        width: 1fr;\n    }\n    #limits-detail {\n        height: 1fr;\n        padding: 1 2;\n    }\n}\n</code></pre> <p>Step 4: Verify it runs</p> <p>Run: <code>uv run rbx ui</code> inside a problem directory. Verify: - Third menu option \"Edit limits profiles.\" appears - Selecting it pushes the screen with sidebar listing profile names - <code>q</code> returns to main menu</p> <p>Step 5: Commit</p> <pre><code>feat(ui): add limits editor screen skeleton with profile sidebar\n</code></pre>"},{"location":"plans/2026-02-28-limits-editor/#task-2-build-the-profile-detail-form-inherit-toggle-global-limits","title":"Task 2: Build the profile detail form (inherit toggle + global limits)","text":"<p>Files: - Modify: <code>rbx/box/ui/screens/limits_editor.py</code> - Modify: <code>rbx/box/ui/css/app.tcss</code></p> <p>Step 1: Add the form widgets to the detail pane</p> <p>Replace the placeholder <code>Static</code> with a proper form. Update <code>LimitsEditorScreen</code> to dynamically compose the detail pane when a profile is selected. Use <code>Switch</code> for inherit toggle and <code>Input</code> for TL/ML.</p> <p>Add these imports to <code>limits_editor.py</code>:</p> <pre><code>from textual.widgets import Button, Input, Switch, Rule\n</code></pre> <p>Add a method <code>_build_detail_form</code> that removes the current detail content and mounts form widgets:</p> <pre><code>async def _load_profile_detail(self):\n    \"\"\"Load the selected profile data into the form.\"\"\"\n    detail = self.query_one('#limits-detail', VerticalScroll)\n    await detail.remove_children()\n\n    if self._selected_profile is None:\n        await detail.mount(Static('Select a profile', id='limits-placeholder'))\n        return\n\n    raw_profile = limits_info.get_saved_limits_profile(self._selected_profile)\n    if raw_profile is None:\n        raw_profile = LimitsProfile()\n\n    pkg = package.find_problem_package_or_die()\n\n    # Title\n    await detail.mount(\n        Static(f'[b]Profile: {self._selected_profile}[/b]', markup=True, id='limits-title')\n    )\n\n    # Inherit toggle\n    await detail.mount(Static('Inherit from package:', id='inherit-label'))\n    inherit_switch = Switch(value=raw_profile.inheritFromPackage, id='inherit-switch')\n    await detail.mount(inherit_switch)\n\n    await detail.mount(Rule())\n\n    # Global limits section\n    await detail.mount(Static('[b]Global Limits[/b]', markup=True, id='global-limits-header'))\n\n    tl_value = str(raw_profile.timeLimit) if raw_profile.timeLimit is not None else ''\n    tl_placeholder = str(pkg.timeLimit)\n    await detail.mount(Static('Time Limit (ms):'))\n    await detail.mount(Input(value=tl_value, placeholder=tl_placeholder, id='input-tl', type='integer'))\n\n    ml_value = str(raw_profile.memoryLimit) if raw_profile.memoryLimit is not None else ''\n    ml_placeholder = str(pkg.memoryLimit)\n    await detail.mount(Static('Memory Limit (MB):'))\n    await detail.mount(Input(value=ml_value, placeholder=ml_placeholder, id='input-ml', type='integer'))\n</code></pre> <p>Update <code>_on_profile_selected</code> to call <code>_load_profile_detail</code>:</p> <pre><code>def _on_profile_selected(self, index: Optional[int]):\n    if index is None:\n        return\n    if index == len(self._profile_names):\n        return\n    self._selected_profile = self._profile_names[index]\n    self._load_profile_detail()\n</code></pre> <p>Step 2: Handle inherit toggle to disable/enable inputs</p> <p>Add a watcher for the switch. When inherit is ON, disable the global limit inputs and show package values read-only:</p> <pre><code>def on_switch_changed(self, event: Switch.Changed) -&gt; None:\n    if event.switch.id == 'inherit-switch':\n        is_inherited = event.value\n        tl_input = self.query_one('#input-tl', Input)\n        ml_input = self.query_one('#input-ml', Input)\n        tl_input.disabled = is_inherited\n        ml_input.disabled = is_inherited\n</code></pre> <p>Step 3: Add CSS for form styling</p> <p>Append to the <code>LimitsEditorScreen</code> CSS block:</p> <pre><code>LimitsEditorScreen {\n    /* ... existing sidebar styles ... */\n    #limits-title {\n        text-style: bold;\n        margin-bottom: 1;\n    }\n    Switch {\n        margin-bottom: 1;\n        height: auto;\n    }\n    #limits-detail Input {\n        margin-bottom: 1;\n    }\n    #limits-detail Static {\n        height: auto;\n    }\n    #limits-detail Rule {\n        margin: 1 0;\n    }\n}\n</code></pre> <p>Step 4: Verify the form renders</p> <p>Run <code>uv run rbx ui</code> in a problem with existing profiles. Selecting a profile should show the inherit toggle and TL/ML inputs. Toggling inherit should disable/enable the inputs.</p> <p>Step 5: Commit</p> <pre><code>feat(ui): add profile detail form with inherit toggle and global limits\n</code></pre>"},{"location":"plans/2026-02-28-limits-editor/#task-3-add-per-language-modifier-editing","title":"Task 3: Add per-language modifier editing","text":"<p>Files: - Modify: <code>rbx/box/ui/screens/limits_editor.py</code> - Modify: <code>rbx/box/ui/css/app.tcss</code></p> <p>Step 1: Add per-language modifier section to the form</p> <p>After the global limits, add a section for per-language modifiers. Load languages from the environment and show existing modifiers.</p> <p>Add import: <pre><code>from rbx.box import environment\nfrom rbx.box.schema import LimitModifiers\n</code></pre></p> <p>Add to <code>_load_profile_detail</code>, after the global limits section:</p> <pre><code>    await detail.mount(Rule())\n    await detail.mount(Static('[b]Per-Language Overrides[/b]', markup=True))\n\n    # Get languages from environment\n    env = environment.get_environment()\n    env_language_names = [lang.name for lang in env.languages]\n\n    # Merge with any languages already in the profile modifiers\n    all_languages = list(dict.fromkeys(env_language_names + list(raw_profile.modifiers.keys())))\n\n    self._modifier_languages = all_languages\n\n    for lang in all_languages:\n        modifier = raw_profile.modifiers.get(lang, LimitModifiers())\n        readable = lang\n        for env_lang in env.languages:\n            if env_lang.name == lang:\n                readable = env_lang.readableName or lang\n                break\n\n        await detail.mount(Static(f'[bold]{readable}[/bold] ({lang}):', markup=True))\n\n        time_val = str(modifier.time) if modifier.time is not None else ''\n        await detail.mount(Static('  Time (ms):'))\n        await detail.mount(Input(value=time_val, placeholder='', id=f'mod-time-{lang}', type='integer'))\n\n        mult_val = str(modifier.timeMultiplier) if modifier.timeMultiplier is not None else ''\n        await detail.mount(Static('  Time Multiplier:'))\n        await detail.mount(Input(value=mult_val, placeholder='', id=f'mod-mult-{lang}', type='number'))\n\n        mem_val = str(modifier.memory) if modifier.memory is not None else ''\n        await detail.mount(Static('  Memory (MB):'))\n        await detail.mount(Input(value=mem_val, placeholder='', id=f'mod-mem-{lang}', type='integer'))\n</code></pre> <p>Also update the inherit toggle handler to disable per-language inputs:</p> <pre><code>def on_switch_changed(self, event: Switch.Changed) -&gt; None:\n    if event.switch.id == 'inherit-switch':\n        is_inherited = event.value\n        # Disable all inputs in the detail pane\n        for inp in self.query_one('#limits-detail').query(Input):\n            inp.disabled = is_inherited\n</code></pre> <p>Step 2: Verify per-language section renders</p> <p>Run <code>uv run rbx ui</code>, select a profile. Verify language rows appear with correct pre-filled values. Toggling inherit should disable all inputs.</p> <p>Step 3: Commit</p> <pre><code>feat(ui): add per-language modifier editing to limits editor\n</code></pre>"},{"location":"plans/2026-02-28-limits-editor/#task-4-add-save-functionality","title":"Task 4: Add Save functionality","text":"<p>Files: - Modify: <code>rbx/box/ui/screens/limits_editor.py</code></p> <p>Step 1: Add save button and ctrl+s binding</p> <p>Add save button at the end of the form in <code>_load_profile_detail</code>:</p> <pre><code>    await detail.mount(Rule())\n    await detail.mount(Button('Save (Ctrl+S)', id='save-btn', variant='primary'))\n</code></pre> <p>Add binding: <pre><code>BINDINGS = [\n    ('q', 'app.pop_screen', 'Quit'),\n    ('ctrl+s', 'save_profile', 'Save'),\n]\n</code></pre></p> <p>Step 2: Implement the save action</p> <p>Add the <code>_build_profile_from_form</code> and <code>action_save_profile</code> methods:</p> <pre><code>def _build_profile_from_form(self) -&gt; LimitsProfile:\n    \"\"\"Construct a LimitsProfile from the current form state.\"\"\"\n    inherit = self.query_one('#inherit-switch', Switch).value\n\n    if inherit:\n        return LimitsProfile(inheritFromPackage=True)\n\n    tl_str = self.query_one('#input-tl', Input).value.strip()\n    ml_str = self.query_one('#input-ml', Input).value.strip()\n\n    time_limit = int(tl_str) if tl_str else None\n    memory_limit = int(ml_str) if ml_str else None\n\n    modifiers: Dict[str, LimitModifiers] = {}\n    for lang in self._modifier_languages:\n        time_str = self.query_one(f'#mod-time-{lang}', Input).value.strip()\n        mult_str = self.query_one(f'#mod-mult-{lang}', Input).value.strip()\n        mem_str = self.query_one(f'#mod-mem-{lang}', Input).value.strip()\n\n        time_val = int(time_str) if time_str else None\n        mult_val = float(mult_str) if mult_str else None\n        mem_val = int(mem_str) if mem_str else None\n\n        if time_val is not None or mult_val is not None or mem_val is not None:\n            modifiers[lang] = LimitModifiers(\n                time=time_val,\n                timeMultiplier=mult_val,\n                memory=mem_val,\n            )\n\n    return LimitsProfile(\n        inheritFromPackage=False,\n        timeLimit=time_limit,\n        memoryLimit=memory_limit,\n        modifiers=modifiers,\n    )\n\nasync def action_save_profile(self) -&gt; None:\n    if self._selected_profile is None:\n        self.app.notify('No profile selected', severity='error')\n        return\n\n    try:\n        profile = self._build_profile_from_form()\n    except (ValueError, TypeError) as e:\n        self.app.notify(f'Invalid input: {e}', severity='error')\n        return\n\n    limits_path = package.get_limits_file(self._selected_profile)\n    limits_path.parent.mkdir(parents=True, exist_ok=True)\n    limits_path.write_text(utils.model_to_yaml(profile))\n\n    self.app.notify(f'Saved profile \"{self._selected_profile}\"', severity='information')\n</code></pre> <p>Add the <code>utils</code> import: <pre><code>from rbx import utils\n</code></pre></p> <p>Wire up the button press: <pre><code>async def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n    if event.button.id == 'save-btn':\n        await self.action_save_profile()\n</code></pre></p> <p>Step 3: Verify save works</p> <p>Run <code>uv run rbx ui</code>, select a profile, modify a value, press Ctrl+S. Check that <code>.limits/{profile}.yml</code> is updated. Re-select the profile to confirm values persist.</p> <p>Step 4: Commit</p> <pre><code>feat(ui): add save functionality to limits editor\n</code></pre>"},{"location":"plans/2026-02-28-limits-editor/#task-5-add-new-profile-and-delete-profile-support","title":"Task 5: Add \"New Profile\" and \"Delete Profile\" support","text":"<p>Files: - Modify: <code>rbx/box/ui/screens/limits_editor.py</code></p> <p>Step 1: Implement new profile creation</p> <p>When the user selects \"+ New Profile\", show an <code>Input</code> for the profile name. On submit, create an empty profile and refresh the list.</p> <p>Add to <code>_on_profile_selected</code>:</p> <pre><code>def _on_profile_selected(self, index: Optional[int]):\n    if index is None:\n        return\n    if index == len(self._profile_names):\n        self._show_new_profile_input()\n        return\n    self._selected_profile = self._profile_names[index]\n    self._load_profile_detail()\n\nasync def _show_new_profile_input(self):\n    detail = self.query_one('#limits-detail', VerticalScroll)\n    await detail.remove_children()\n    await detail.mount(Static('Enter new profile name:'))\n    await detail.mount(Input(placeholder='e.g. local, judge', id='new-profile-name'))\n\nasync def on_input_submitted(self, event: Input.Submitted) -&gt; None:\n    if event.input.id == 'new-profile-name':\n        name = event.value.strip()\n        if not name:\n            self.app.notify('Profile name cannot be empty', severity='error')\n            return\n        if name in self._profile_names:\n            self.app.notify(f'Profile \"{name}\" already exists', severity='error')\n            return\n        # Create empty profile file\n        limits_path = package.get_limits_file(name)\n        limits_path.parent.mkdir(parents=True, exist_ok=True)\n        limits_path.write_text(utils.model_to_yaml(LimitsProfile()))\n        self._selected_profile = name\n        await self._load_profiles()\n        # Select the new profile in the list\n        new_index = self._profile_names.index(name)\n        self.query_one('#limits-profile-list', ListView).index = new_index\n        self._load_profile_detail()\n</code></pre> <p>Step 2: Implement profile deletion</p> <p>Add delete binding and action:</p> <pre><code>BINDINGS = [\n    ('q', 'app.pop_screen', 'Quit'),\n    ('ctrl+s', 'save_profile', 'Save'),\n    ('d', 'delete_profile', 'Delete profile'),\n]\n\nasync def action_delete_profile(self) -&gt; None:\n    if self._selected_profile is None:\n        self.app.notify('No profile selected', severity='error')\n        return\n    limits_path = package.get_limits_file(self._selected_profile)\n    if limits_path.exists():\n        limits_path.unlink()\n    self.app.notify(f'Deleted profile \"{self._selected_profile}\"', severity='information')\n    self._selected_profile = None\n    await self._load_profiles()\n    detail = self.query_one('#limits-detail', VerticalScroll)\n    await detail.remove_children()\n    await detail.mount(Static('Select a profile', id='limits-placeholder'))\n</code></pre> <p>Step 3: Verify new/delete work</p> <p>Run <code>uv run rbx ui</code>. Test: - Select \"+ New Profile\", type a name, press Enter. Verify the profile appears in the sidebar and opens in the form. - Select a profile, press <code>d</code>. Verify it's removed from the sidebar and the <code>.limits/</code> directory.</p> <p>Step 4: Commit</p> <pre><code>feat(ui): add new profile creation and deletion to limits editor\n</code></pre>"},{"location":"plans/2026-02-28-limits-editor/#task-6-add-custom-language-support","title":"Task 6: Add custom language support","text":"<p>Files: - Modify: <code>rbx/box/ui/screens/limits_editor.py</code></p> <p>Step 1: Add \"Add Language\" button and input</p> <p>After the per-language modifier rows, add a button. When clicked, show an input for the language key. On submit, add a new modifier row.</p> <p>In <code>_load_profile_detail</code>, after the language loop:</p> <pre><code>    await detail.mount(Button('+ Add Language', id='add-lang-btn', variant='default'))\n</code></pre> <p>Handle the button press:</p> <pre><code>async def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n    if event.button.id == 'save-btn':\n        await self.action_save_profile()\n    elif event.button.id == 'add-lang-btn':\n        await self._show_add_language_input()\n\nasync def _show_add_language_input(self):\n    detail = self.query_one('#limits-detail', VerticalScroll)\n    # Remove existing add-language input if present\n    for widget in detail.query('#add-lang-input'):\n        await widget.remove()\n    inp = Input(placeholder='Language key (e.g. cpp, java)', id='add-lang-input')\n    # Mount before the add-lang-btn\n    await detail.mount(inp, before=self.query_one('#add-lang-btn'))\n    inp.focus()\n</code></pre> <p>Handle submission of the language input:</p> <pre><code>async def on_input_submitted(self, event: Input.Submitted) -&gt; None:\n    if event.input.id == 'new-profile-name':\n        # ... existing handler ...\n    elif event.input.id == 'add-lang-input':\n        lang = event.value.strip()\n        if not lang:\n            return\n        if lang in self._modifier_languages:\n            self.app.notify(f'Language \"{lang}\" already exists', severity='error')\n            return\n        self._modifier_languages.append(lang)\n        # Reload form preserving current state\n        await self._reload_form_with_new_language(lang)\n</code></pre> <p>For simplicity, <code>_reload_form_with_new_language</code> should save current form state, add the language to <code>_modifier_languages</code>, and re-render the full form via <code>_load_profile_detail</code> \u2014 but using the form's current values instead of re-reading from disk. A pragmatic approach: just re-call <code>_load_profile_detail</code> after saving the current state to a temporary <code>LimitsProfile</code>:</p> <pre><code>async def _reload_form_with_new_language(self, new_lang: str):\n    \"\"\"Save current form state and reload with new language added.\"\"\"\n    try:\n        current = self._build_profile_from_form()\n    except (ValueError, TypeError):\n        current = LimitsProfile()\n    # Temporarily save, reload detail\n    self._pending_profile = current\n    self._pending_profile.modifiers.setdefault(new_lang, LimitModifiers())\n    await self._load_profile_detail_from(self._pending_profile)\n</code></pre> <p>This requires a small refactor: extract a <code>_load_profile_detail_from(profile)</code> method that takes a <code>LimitsProfile</code> directly, and have <code>_load_profile_detail</code> call it after loading from disk.</p> <p>Step 2: Verify adding a custom language</p> <p>Run <code>uv run rbx ui</code>, select a profile, click \"+ Add Language\", type \"kotlin\", press Enter. Verify a new kotlin modifier row appears. Save and verify the YAML contains the kotlin modifier.</p> <p>Step 3: Commit</p> <pre><code>feat(ui): add custom language support to limits editor\n</code></pre>"},{"location":"plans/2026-02-28-limits-editor/#task-7-polish-and-edge-cases","title":"Task 7: Polish and edge cases","text":"<p>Files: - Modify: <code>rbx/box/ui/screens/limits_editor.py</code> - Modify: <code>rbx/box/ui/css/app.tcss</code></p> <p>Step 1: Show package limits when inheriting</p> <p>When inherit is ON, instead of just disabling inputs, show the expanded package limits as read-only text so the user sees what they're inheriting:</p> <p>In the <code>on_switch_changed</code> handler, when inherit is toggled ON, call <code>_load_profile_detail</code> to re-render (it will display read-only package values). When toggled OFF, re-render with editable fields.</p> <p>Step 2: Input validation styling</p> <p>Add validation feedback: if the user types a non-numeric value in a TL/ML field, use Textual's built-in <code>Input</code> validation (<code>type='integer'</code> already handles this for Textual &gt;=0.40). Verify <code>type='integer'</code> is supported in Textual 8.0.</p> <p>Step 3: Prevent accidental deletion</p> <p>Before deleting, show a confirmation. Use <code>self.app.push_screen</code> with a simple yes/no modal, or just <code>self.app.notify</code> with a double-press pattern (e.g., track <code>_delete_requested</code> flag).</p> <p>Step 4: Final CSS polish</p> <p>Ensure consistent spacing, proper border styling matching the rest of the app. Test in both light and dark terminal themes.</p> <p>Step 5: Verify everything works end to end</p> <p>Full test scenario: 1. <code>rbx ui</code> -&gt; \"Edit limits profiles.\" 2. Select existing profile -&gt; verify TL/ML/modifiers load correctly 3. Toggle inherit ON -&gt; verify package values shown read-only 4. Toggle inherit OFF -&gt; verify inputs are editable 5. Modify TL, add a per-language modifier 6. Ctrl+S -&gt; verify saved to disk 7. \"+ New Profile\" -&gt; create \"test-profile\" -&gt; verify appears in sidebar 8. Delete \"test-profile\" -&gt; verify removed 9. \"q\" -&gt; verify returns to main menu</p> <p>Step 6: Commit</p> <pre><code>feat(ui): polish limits editor with validation and confirmation\n</code></pre>"},{"location":"setters/cheatsheet/","title":"Cheatsheet","text":""},{"location":"setters/cheatsheet/#cli","title":"CLI","text":"<p>Below you can find a list of common rbx commands. You can read more about each of them in the CLI reference.</p> Task Command Show help message <code>rbx --help</code> Open rbx configuration for editing <code>rbx config edit</code> Create a new package in folder <code>package</code> <code>rbx create</code> Compile a file given its path <code>rbx compile my/file.cpp</code> Open the problem configuration in a text editor <code>rbx edit</code> Generate all testcases <code>rbx build</code> Use dynamic timing to estimate time limits <code>rbx time</code> Run all solutions and check their tags <code>rbx run</code> Run all solutions with sanitizer <code>rbx run -s</code> Run all solutions with dynamic timing <code>rbx run -t</code> Run all solutions except the slow ones <code>rbx run -v2</code> Run all solutions without checking <code>rbx run --no-check</code> Run a single solution <code>rbx run sols/my-solution.cpp</code> Choose solutions and run <code>rbx run -c</code> Run all solutions interactively <code>rbx irun</code> Choose solutions and run interactively <code>rbx irun -c</code> Run solutions in a single testcase <code>rbx irun -t samples/0</code> Run solutions in a generator testcase <code>rbx irun -g gen 5 10</code> Interactively visualize outputs of a recent run <code>rbx ui</code> Run the validator interactively <code>rbx validate</code> Run a stress test with name <code>break</code> <code>rbx stress break</code> Run a stress test for a generator <code>rbx stress gen -g \"[1..10]\" -f \"[sols/main.cpp ~ INCORRECT]\"</code> Run unit tests for validator and checker <code>rbx unit</code> Download testlib to the current folder <code>rbx download testlib</code> Download jngen to the current folder <code>rbx download jngen</code> Download a built-in testlib checker <code>rbx download checker wcmp.cpp</code> Build all statements <code>rbx statements build</code> Build a specific statement <code>rbx statements build &lt;name&gt;</code> Build statements for English <code>rbx statements build -l en</code> Package problem for Polygon <code>rbx package polygon</code> Package problem for BOCA <code>rbx package boca</code> Package problem for BOCA but only validate <code>rbx package boca -v1</code> List all languages available in the environment <code>rbx languages</code> Format all YAML configuration files in the package <code>rbx fix</code> Clear cache <code>rbx clear</code>"},{"location":"setters/cheatsheet/#contest-cli","title":"Contest CLI","text":"Task Command Show help message <code>rbx contest --help</code> Create a new contest <code>rbx contest create</code> Add a new problem to the contest with letter A <code>rbx contest add</code> Remove a problem from the contest <code>rbx contest remove A</code> Remove a problem at a certain path <code>rbx contest remove path/to/problem</code> Open the contest configuration in a text editor <code>rbx contest edit</code> Build all statements <code>rbx contest statements build</code> Build a specific statement <code>rbx contest statements build &lt;name&gt;</code> Build statements for English <code>rbx contest statements build en</code> Package contest for Polygon <code>rbx contest package polygon</code> Build each problem in the contest <code>rbx contest each build</code> Package each problem in the contest <code>rbx contest each package boca</code> Build problem A in the contest <code>rbx contest on A build</code> Build problems A to C in the contest <code>rbx contest on A-C build</code>"},{"location":"setters/cheatsheet/#problemrbxyml","title":"<code>problem.rbx.yml</code>","text":""},{"location":"setters/cheatsheet/#change-problem-constraints","title":"Change problem constraints","text":"<pre><code>timeLimit: 1000  # In milliseconds\nmemoryLimit: 256  # In megabytes\nmodifiers:\n  java:\n    time: 5000  # Override time for Java\n</code></pre>"},{"location":"setters/cheatsheet/#add-testlib-assets","title":"Add testlib assets","text":""},{"location":"setters/cheatsheet/#set-a-built-in-testlib-checker","title":"Set a built-in testlib checker","text":"<pre><code>rbx download checker yesno.cpp\n</code></pre> <pre><code>checker:\n  path: \"yesno.cpp\"\n</code></pre> <p>Tip</p> <p>Find here a full list of existing built-in testlib checkers.</p>"},{"location":"setters/cheatsheet/#set-a-custom-checker","title":"Set a custom checker","text":"<pre><code>checker:\n  path: \"my-checker.cpp\"\n</code></pre> <p>See here how to write a custom testlib checker.</p>"},{"location":"setters/cheatsheet/#add-a-generator","title":"Add a generator","text":"<p>Add a new generator entry to the <code>generators</code> field.</p> <pre><code>generators:\n  # ...other generators\n  - name: \"my-gen\"\n    path: \"my-gen.cpp\"\n</code></pre> <p>See here how to write a testlib-based generator.</p> <p>Tip</p> <p>To actually generate tests with this new generator, you have to add testcase groups and call the generator.</p>"},{"location":"setters/cheatsheet/#set-a-validator","title":"Set a validator","text":"<pre><code>validator:\n  path: 'my-validator.cpp`\n</code></pre> <p>See here how to write a testlib-based validator.</p>"},{"location":"setters/cheatsheet/#set-an-interactor","title":"Set an interactor","text":"<pre><code>interactor:\n  path: 'my-interactor.cpp'\n</code></pre> <p>See here how to write a testlib-based interactor.</p>"},{"location":"setters/cheatsheet/#add-a-new-solution","title":"Add a new solution","text":"<p>Implement your solution (for instance, a wrong solution in <code>sols/my-wa-solution.cpp</code>) and add it to the <code>solutions</code> field.</p> <pre><code>solutions:\n  - path: 'sols/my-wa-solution.cpp'\n    outcome: WRONG_ANSWER\n</code></pre> <p>You can see the list of possible expected outcomes here.</p>"},{"location":"setters/cheatsheet/#add-testcases","title":"Add testcases","text":""},{"location":"setters/cheatsheet/#add-a-testcase-group-with-manually-defined-tests","title":"Add a testcase group with manually defined tests","text":"<pre><code>testcases:\n  # ...other testcase groups\n  - name: \"manual-tests\"\n    testcaseGlob: \"tests/manual/*.in\" # (1)!\n</code></pre> <ol> <li> <p>Import all tests in the <code>tests/manual/</code> folder in lexicographic order.</p> <p>The test input files must end in <code>.in</code>.</p> </li> </ol>"},{"location":"setters/cheatsheet/#add-a-testcase-group-with-a-list-of-generated-tests","title":"Add a testcase group with a list of generated tests","text":"<pre><code>testcases:\n  # ...other testcase groups\n  - name: \"single-generated\"\n    generators:\n      - name: \"gen\"\n        args: \"1000 123\" # (1)!\n      - name: \"gen\"\n        args: \"1000 456\" # (2)!\n</code></pre> <ol> <li>A generated test obtained from the output of the command <code>gen 1000 123</code>.</li> <li>A generated test obtained from the output of the command <code>gen 1000 456</code>.</li> </ol>"},{"location":"setters/cheatsheet/#add-a-testcase-group-with-a-list-of-generated-tests-from-a-generator-script","title":"Add a testcase group with a list of generated tests from a generator script","text":"problem.rbx.ymlscript.txt <pre><code>testcases:\n  # ...other testcase groups\n   - name: \"generated-from-text-script\"\n     generatorScript:\n        path: \"script.txt\"\n</code></pre> <pre><code>gen 1000 123\ngen 1000 456\ngen 1000 789\n# other tests...\n</code></pre>"},{"location":"setters/cheatsheet/#add-a-testcase-group-with-a-list-of-generated-tests-from-a-dynamic-generator-script","title":"Add a testcase group with a list of generated tests from a dynamic generator script","text":"problem.rbx.ymlscript.py <pre><code>testcases:\n  # ...other testcase groups\n   - name: \"generated-from-program-script\"\n     generatorScript:\n        path: \"script.py\"\n</code></pre> <pre><code>for i in range(50):\n  print(f'gen 1000 {i}') # (1)!\n</code></pre> <ol> <li>Generates 50 random tests.</li> </ol>"},{"location":"setters/cheatsheet/#add-testgroup-specific-validator","title":"Add testgroup-specific validator","text":"<pre><code>validator:\n  path: \"my-validator.cpp\"\ntestcases:\n  - name: \"small-group\"\n    # Define tests...\n    validator:\n      path: \"my-small-validator.cpp\" # (1)!\n  - name: \"large-group\"\n    # Define tests...\n</code></pre> <ol> <li>Add a specific validator to verify constraints of a smaller sub-task of the problem.</li> </ol>"},{"location":"setters/cheatsheet/#add-variables","title":"Add variables","text":"<p>The variables below can be reused across validators and statements.</p> <pre><code>vars:\n  N:\n    min: 1\n    max: 1000\n  V:\n    max: 100000\n  MOD: py`10**9+7` # Backticks force the var to be evaluated as a Python expression.\n</code></pre>"},{"location":"setters/cheatsheet/#use-variables","title":"Use variables","text":"In testlib componentsIn statements <pre><code>#include \"rbx.h\"\n\nint32_t main() {\n  registerValidation(argc, argv);\n\n  int MIN_N = getVar&lt;int&gt;(\"N.min\"); // Read from package vars.\n  int MAX_N = getVar&lt;int&gt;(\"N.max\"); // Read from package vars.\n\n  // Rest of the validator\n}\n</code></pre> <pre><code>The maximum value of N is \\VAR{N.max | sci} % (1)!\n</code></pre> <ol> <li>If <code>N.max</code> has lots of trailing zeroes, <code>sci</code> converts it to scientific notation.</li> </ol>"},{"location":"setters/cheatsheet/#add-statements","title":"Add statements","text":""},{"location":"setters/cheatsheet/#add-a-rbxtex-statement","title":"Add a rbxTeX statement","text":"<pre><code>statements:\n  # ...other statements\n  - name: 'statement-en'\n    title: \"My problem\"\n    path: \"statement/statement.rbx.tex\" # (1)!\n    type: rbxTeX\n    language: 'en'\n    configure:\n      - type: 'rbx-tex'\n        template: statement/template.rbx.tex' # (2)!\n    assets: ['statement/olymp.sty', 'statement/*.png'] # (3)!\n</code></pre> <ol> <li> <p>Defines the path to the rbxTeX file, where the building blocks of the statement    will be defined.</p> </li> <li> <p>Defines how a rbxTeX file will be converted to a normal TeX file. Here, we link      the template where our rbxTeX sections such as legend, input and output      will be inserted into.</p> </li> <li> <p>Defines assets that should be linked when the resulting statement is being compiled.</p> </li> </ol>"},{"location":"setters/cheatsheet/#extends-other-rbxtex-statements","title":"Extends other rbxTeX statements","text":"<pre><code>statements:\n  - name: 'statement'\n    title: 'My problem'\n    path: \"statement/statement.rbx.tex\"\n    type: rbxTeX\n    language: 'en'\n    configure:\n      - type: 'rbx-tex'\n        template: statement/template.rbx.tex'\n    assets: ['statement/olymp.sty', 'statement/*.png']\n  - name: 'statement-pt'\n    title: 'Meu problema'\n    extends: 'statement' # (1)!\n    language: 'pt'\n    path: 'statement/statement-pt.rbx.tex' # (2)!\n</code></pre> <ol> <li> <p>The <code>statement-pt</code> statement will inherit the properties of the <code>statement</code> statement, and override a subset of them.</p> </li> <li> <p>The <code>statement-pt</code> statement will use a different rbxTeX file, since we need to rewrite the building blocks    of the statement in another language.</p> </li> </ol>"},{"location":"setters/cheatsheet/#add-a-pdf-statement","title":"Add a PDF statement","text":"<pre><code>statements:\n  # ...other statements\n  - title: \"My problem\"\n    path: \"statement/statement.pdf\"\n    type: PDF\n    language: 'en'\n</code></pre>"},{"location":"setters/cheatsheet/#add-a-stress-test","title":"Add a stress test","text":""},{"location":"setters/cheatsheet/#add-a-stress-to-look-for-an-error-in-a-solution","title":"Add a stress to look for an error in a solution","text":"<pre><code>stresses:\n  - name: \"my-stress\"\n    generator:\n      name: 'gen'\n      args: '[1..&lt;N.max&gt;] @' # (1)!\n    finder: \"[sols/my-wa-solution.cpp] ~ INCORRECT\" # (2)!\n</code></pre> <ol> <li> <p>The <code>&lt;N.max&gt;</code> variable expands into the <code>vars.N.max</code> value that could be declared in     <code>problem.rbx.yml</code>.</p> <p>The <code>[1..&lt;N.max&gt;]</code> picks a random number in this interval before generating every test in the stress run.</p> <p>The <code>@</code> appends a few extra random characters to the end of the generator call to re-seed the generator.</p> </li> <li> <p>Expression that refers to solution <code>sols/my-wa-solution.cpp</code> and check whether it returns an incorrect outcome.</p> </li> </ol>"},{"location":"setters/cheatsheet/#add-a-stress-to-look-for-a-test-that-causes-tle-in-a-solution","title":"Add a stress to look for a test that causes TLE in a solution","text":"<pre><code>stresses:\n  - name: \"my-stress\"\n    generator:\n      name: 'gen'\n      args: '1000000 @' # (1)!\n    finder: \"[sols/my-potentially-slow-sol.cpp] ~ TLE\"\n</code></pre> <ol> <li>The <code>@</code> at the end of the <code>args</code> string appends a random string to it. This is necessary here because <code>gen 100000</code> would return the same testcase over and over, since testlib rng is seeded from its command line argc and argv.</li> </ol>"},{"location":"setters/cheatsheet/#add-unit-tests","title":"Add unit tests","text":"<pre><code>unitTests:\n  validator:\n    - glob: \"unit/validator/valid_*.in\"  # (1)!\n      outcome: VALID\n    - glob: \"unit/validator/invalid_*.in\"\n      outcome: INVALID\n  checker:\n    - glob: \"unit/checker/ac*\"  # (2)!\n      outcome: ACCEPTED\n    - glob: \"unit/checker/wa*\"\n      outcome: WRONG_ANSWER\n    # ...other checker unit tests\n</code></pre> <ol> <li> <p>Matches <code>.in</code> files relative to the problem root directory that when validated should be considered valid.</p> </li> <li> <p>Matches <code>.in</code>, <code>.out</code>, <code>.ans</code> files that when checked should be considered ACCEPTED.</p> </li> </ol>"},{"location":"setters/cheatsheet/#contestrbxyml","title":"<code>contest.rbx.yml</code>","text":""},{"location":"setters/cheatsheet/#add-a-new-problem","title":"Add a new problem","text":"<pre><code>problems:\n  - short_name: \"A\"  # Letter of the problem\n    path: \"problem_folder\"\n    color: \"ff0000\"  # Optional\n    aliases: [\"apple\", \"prob-a\"]  # Optional; use any of these or short_name in e.g. rbx on &lt;name&gt; run\n</code></pre>"},{"location":"setters/first-steps/","title":"First steps","text":"<p><code>rbx</code> is the CLI tool rbx provides for setters to prepare contests and problems.</p> <p>This document focus on a very specific and simple user journey to highlight the most common features of rbx. Feel free to explore the rest of the documentation on the sidebar to get more information about the other features.</p> <p>We'll focus on how to create a problem from a pre-initialized preset, how to write its main components and how to test it.</p> <p>You can start creating a new problem from a pre-initialized preset by running <code>rbx create</code>.</p> rbx create# This will prompt you for the name of the problem, and then create a new problem# in a folder with that name. <p>This is how the directory structure of the pre-initialized problem preset will look like:</p> <pre><code>test\n\u251c\u2500\u2500 sols  # (1)!\n\u2502   \u251c\u2500\u2500 main.cpp\n\u2502   \u251c\u2500\u2500 slow.cpp\n\u2502   \u2514\u2500\u2500 wa.cpp\n\u251c\u2500\u2500 statement  # (2)!\n\u2502   \u251c\u2500\u2500 olymp.sty\n\u2502   \u251c\u2500\u2500 projecao.png\n\u2502   \u251c\u2500\u2500 statement.rbx.tex\n\u2502   \u2514\u2500\u2500 template.rbx.tex\n\u251c\u2500\u2500 tests  # (3)!\n\u2502   \u2514\u2500\u2500 samples\n\u2502       \u251c\u2500\u2500 000.in\n\u2502       \u2514\u2500\u2500 001.in\n\u251c\u2500\u2500 gen.cpp # (4)!\n\u251c\u2500\u2500 problem.rbx.yml # (5)!\n\u251c\u2500\u2500 random.txt # (6)!\n\u251c\u2500\u2500 random.py # (7)!\n\u251c\u2500\u2500 validator.cpp # (8)!\n\u2514\u2500\u2500 wcmp.cpp # (9)!\n</code></pre> <ol> <li>All solutions for the problem: the correct and the incorrect ones.</li> <li>All statement-related assets, including the legend of the problem itself     but also the tex templates and imported graphics.</li> <li> <p>Manually defined tests of the problem.</p> <p>Note</p> <p>Automatically generated tests are not defined by explicit input and output files, but are rather defined by generator entries in the problem configuration.</p> </li> <li> <p>An example of a testlib generator. In this case, the generator is used to     generate testcases for two testgroups: <code>random</code> and <code>program-random</code>.</p> <p>Note</p> <p>A problem can have multiple generators. This one is just an example.</p> </li> <li> <p>The YAML configuration file for this problem.</p> </li> <li> <p>A generator script for the problem.</p> <p>Each line of a generator script describes one call to a generator, and a generator script groups all these calls together.</p> <p>Example:</p> <pre><code>gen 123\ngen 456\n</code></pre> <p>Calls the generator named <code>gen</code> (here in this problem, implemented through <code>gen.cpp</code>) twice, thus generating two testcases.</p> <p>In this problem, this script is used to generate the testcase group <code>random</code>.</p> </li> <li> <p>A program that outputs a generator script. Pretty similar to <code>random.txt</code>     above, except that this is a program that prints to the stdout a     generator script, and thus provides more flexibility to the setter.</p> <p>Example:</p> <pre><code>#! /usr/bin/python3\nfor i in range(10):\n    print(f'gen {i}')\n</code></pre> <p>This program outputs a generator script that creates 10 testcases with increasing parameter <code>i</code>.</p> <p>In this problem, this program is used to generate the testcase group <code>program-random</code>.</p> </li> <li> <p>A testlib validator that checks whether the generated tests are     in the correct format.</p> </li> <li> <p>A built-in testlib checker that compares tokens of the participant's output     and the judge's output.</p> </li> </ol>"},{"location":"setters/first-steps/#build","title":"Build","text":"<p>Let's skip the configuration of the problem for a second, and just build and run it. You can build a problem with <code>rbx build</code>. This will populate a <code>build</code> folder inside your problem's folder with all the testcases generated for the problem.</p> <pre><code>$ rbx build\n$ ls build\nbuild\n\u2502   \u2514\u2500\u2500 tests\n\u2502       \u251c\u2500\u2500 program-random\n\u2502       \u2502   \u2514\u2500\u2500 ...\n\u2502       \u251c\u2500\u2500 random\n\u2502       \u2502   \u2514\u2500\u2500 ...\n\u2502       \u2514\u2500\u2500 samples\n\u2502           \u2514\u2500\u2500 ...\n</code></pre> <p>You can notice it created several folders inside a <code>tests</code> directory, each of which contains the tests for a specific testgroup. For this preset in particular, we have three testsets: <code>random</code>, <code>program-random</code> and <code>samples</code>.</p> <p>If you want, you can explore these folders manually, but rbx also provides a TUI (terminal UI) to explore the testcases. You can run <code>rbx ui</code> and select the first option to explore the built testcases.</p>"},{"location":"setters/first-steps/#run","title":"Run","text":"<p>Now, let's execute <code>rbx run</code>. This command builds all testcases and executes each solution against them, evaluating whether each solution had the expected outcome.</p> <pre><code>$ rbx run\n</code></pre> <p>You can see this command prints a full run report: it shows for each testcase of each testgroup whether a certain solution passed or not. There are also links for the outputs of each problem.</p> <p>Tip</p> <p>You can notice when you call <code>rbx run</code> again, the testcases were built really fast. That's because rbx caches certain calls based on the hash tree of your package (similar to Makefile). You can explicitly clear this cache by calling <code>rbx clean</code>.</p>"},{"location":"setters/first-steps/#modifying-the-package","title":"Modifying the package","text":"<p>As you can see from the solutions and the statement, the pre-initialized preset simply implements a problem where you have to add up two numbers <code>A</code> and <code>B</code>. Let's modify the problem to compute the sum of N numbers.</p>"},{"location":"setters/first-steps/#rewrite-solutions","title":"Rewrite solutions","text":"<p>Let's start rewriting the solutions. We can probably drop the slow solution since we're just naively summing numbers anyway.</p> <p>We can develop the following accepted and wrong answer solutions.</p> sols/main.cppsols/wa.cpp <pre><code>#include &lt;bits/stdc++.h&gt;\n\nint32_t main() {\n    int n;\n    cin &gt;&gt; n;\n\n    int64_t ans = 0;\n    for(int i = 0; i &lt; n; i++) {\n        int x;\n        cin &gt;&gt; x;\n        ans += x;\n    }\n\n    cout &lt;&lt; ans &lt;&lt; endl;\n}\n</code></pre> <pre><code>#include &lt;bits/stdc++.h&gt;\n\nint32_t main() {\n    int n;\n    cin &gt;&gt; n;\n\n    int32_t ans = 0; // int32 overflows!!\n    for(int i = 0; i &lt; n; i++) {\n        int x;\n        cin &gt;&gt; x;\n        ans += x;\n    }\n\n    cout &lt;&lt; ans &lt;&lt; endl;\n}\n</code></pre> <p>To delete the <code>slow.cpp</code> solution from our package, we can just delete the file and the reference to it in <code>problem.rbx.yml</code>. The reference is located in the <code>solutions</code> section, which will look like this after the deletion:</p> <pre><code>solutions:\n  - path: 'sols/main.cpp'\n    outcome: ACCEPTED\n  - path: 'sols/wa.cpp'\n    outcome: WRONG_ANSWER\n</code></pre> <p>You can find the full list of expected outcomes here.</p>"},{"location":"setters/first-steps/#write-the-validator","title":"Write the validator","text":"<p>The testlib validator is implemented by <code>validator.cpp</code> and will look like this:</p> validator.cpp <pre><code>#include \"testlib.h\"\n#include \"rbx.h\"\n\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n\n    int MAX_N = getVar&lt;int&gt;(\"N.max\"); // (1)!\n    int MAX_A = getVar&lt;int&gt;(\"A.max\");\n\n    for (int i = 0; i &lt; n; i++) {\n        if (i) inf.readSpace();\n        inf.readInt(1, MAX_A, \"A_i\");\n    }\n    inf.readEoln();\n    inf.readEof();\n}\n</code></pre> <ol> <li><code>N.max</code> is a variable defined in <code>problem.rbx.yaml</code> that is accessible     in the validator. It allows you to change the constraints of the problem,     and instantly replicate the change in validators and statements.</li> </ol>"},{"location":"setters/first-steps/#generating-random-testcases","title":"Generating random testcases","text":"<p>Now, let's rewrite our random generator to generate <code>N</code> numbers instead of only two.</p> <p>We have to actually call this generator and generate testcases into some of the testgroups.</p> <p>Let's delete the existing test groups in <code>problem.rbx.yml</code>, except for the <code>samples</code> one, and create a new <code>main_tests</code> group. Let's generate 10 random tests for this group by using a generator script. We can either use a static generator script (represented in the example below as <code>random.txt</code>) or a dynamic generator script (represented in the example below as <code>random.py</code>).</p> gen.cpprandom.txt (static)random.py (dynamic)problem.rbx.yml <pre><code>#include \"testlib.h\"\n\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerGen(argc, argv, 1); // (1)!\n\n    int n = rnd.next(1, opt&lt;int&gt;(1));\n\n    for (int i = 0; i &lt; n; i++) {\n        if (i) cout &lt;&lt; \" \";\n        cout &lt;&lt; rnd.next(1, opt&lt;int&gt;(2));\n    }\n    cout &lt;&lt; endl;\n}\n</code></pre> <ol> <li>The generator now receive two parameters <code>N.max</code> (accessed through <code>opt&lt;int&gt;(1)</code>) and <code>A.max</code> (accessed through <code>opt&lt;int&gt;(2)</code>).</li> </ol> <pre><code>gen 1000 1000000000 1\ngen 1000 1000000000 2\ngen 1000 1000000000 3\ngen 1000 1000000000 4\ngen 1000 1000000000 5\ngen 1000 1000000000 6\ngen 1000 1000000000 7\ngen 1000 1000000000 8\ngen 1000 1000000000 9\ngen 1000 1000000000 10\n</code></pre> <pre><code>for i in range(10):\n    print(f'gen 1000 1000000000 {i}') # (1)!\n</code></pre> <ol> <li> <p>This line defines 10 random calls to the generator <code>gen</code>,      which will in turn generate testcases with <code>N</code> randomly varying     from 1 to 1000 and the numbers to be added varying from 1 to <code>1e9</code>.</p> <p>Tip</p> <p>Notice the trailing <code>{i}</code> being printed in every generator script line. That's because testlib rng seed is initialized from the <code>argv</code> given to the generator.</p> <p>Thus generators are reproducible: if we called <code>gen 1000 1000000000</code> 10 times, we would always get the same result. By appending an extra variable <code>{i}</code>, we introduce randomness to the tests.</p> </li> </ol> <pre><code># Testcases section would look like:\n\ntestcases:\n- name: 'samples'\n    testcaseGlob: 'tests/samples/*.in'\n- name: 'main_tests'  # (1)!\n    generatorScript:\n        path: 'random.txt'  # or 'random.py', in case you want to use a dynamic generator\n</code></pre> <ol> <li>Here, <code>main_tests</code> would contain the 10 tests defined in <code>random.txt</code> or <code>random.py</code>.</li> </ol> <p>Our newly defined generator <code>gen.cpp</code> will receive two positional arguments, <code>N</code> and <code>A</code>, and generate a list of <code>N</code> integers, each of which is at most <code>A</code>.</p> <p>Then, our generator script will can this generator 10 times to generate 10 different tests with <code>N</code> integers ranging from 1 to <code>A</code>.</p> <p>Now, if we run <code>rbx build</code>, we'd get our brand new generated tests.</p>"},{"location":"setters/first-steps/#update-the-statement","title":"Update the statement","text":"<p>Of course, last but not least, we have to update the statement of our problem. rbx has its own statement format, called rbxTeX. The format itself is simple, but the ecosystem behind it is complex and provides a lot of flexibility for setters.</p> <p>For now, you just need to know the body and meat of the statement is written at <code>statement/statement.rbx.tex</code>. If you open it, you will find something like the following:</p> statement/statement.rbx.tex <pre><code>%- block legend\nGiven two integers $A$ and $B$, determine the value of $A + B$.\n%- endblock\n\n%- block input\nThe input is a single line containing two integers $A$ and $B$\n($1 \\leq A, B \\leq \\VAR{N.max | sci}$). % (1)!\n%- endblock\n\n%- block output\nThe output must contain only one integer, the sum of $A$ and $B$.\n%- endblock\n\n%- block notes\nNo notes.\n%- endblock\n</code></pre> <ol> <li> <p>Notice the use of <code>\\VAR</code> here, which is a command rbxTeX exposes for     you to access variables defined in <code>problem.rbx.yml</code>, similar to how you     accessed these in the testlib validator.</p> <p>The template engine used to expand <code>\\VAR{...}</code> is Jinja2. This means we can also use filters. Here in particular, we're using a pre-defined filter implemented by rbxTeX called <code>sci</code>. This filter converts numbers with lots of zeroes (for instance, 100000), into their scientific notations (<code>10^5</code>).</p> </li> </ol> <p>As you can see, similar to Polygon, you write a few blocks of LaTeX. Here, the <code>%-</code> delimits those pre-defined blocks. Your statement needs at least a legend, an input and an output. When the time comes to build this statement, these blocks will be pieced together to form the final statement.</p> <p>Let's change each corresponding block to match our new problem description.</p> statement/statement.rbx.tex <pre><code>%- block legend\nGiven $N$ integers, print their sum.\n%- endblock\n\n%- block input\nThe input has a single line containing $N$ \n($1 \\leq N \\leq \\VAR{N.max | sci}$) numbers. \nThese numbers range from 1 to $\\VAR{A.max | sci}$.\n%- endblock\n\n%- block output\nPrint the sum of the integers.\n%- endblock\n\n%- block notes\nNo notes.\n%- endblock\n</code></pre>"},{"location":"setters/first-steps/#next-steps","title":"Next steps","text":"<p>If you want to customize the problem even more, you can continue reading our Reference section on the sidebar.</p> <ul> <li> <p> Add a custom checker</p> <p>Want to grade solutions without comparing tokens? Check out our guide on how to add a custom checker.</p> <p> Checkers</p> </li> <li> <p> Package and ship your problem</p> <p>Want to package your problem for a judge? Check out our guide on how to package your problem.</p> <p> Packaging</p> </li> <li> <p> Stress test</p> <p>Want to generate stronger testcases? Check out our guide on how to stress test your solutions.</p> <p> Stress testing</p> </li> <li> <p> Configure further</p> <p>Want to learn all you can do in <code>problem.rbx.yml</code>? Check out our reference on how to configure your problem.</p> <p> <code>problem.rbx.yml</code></p> </li> </ul>"},{"location":"setters/packaging-walkthrough/","title":"Packaging a problem","text":"<p>This walkthrough covers the full process of packaging a problem for a judge system, from profiling time limits all the way to uploading the final package. We'll use BOCA as our target judge, but the overall workflow applies to any supported format.</p> <p>We assume you already have a working problem -- tests build, solutions run, and expected outcomes match. If you're starting from scratch, follow the First steps walkthrough first.</p>"},{"location":"setters/packaging-walkthrough/#overview","title":"Overview","text":"<p>Packaging a problem involves three main stages:</p> <ol> <li>Profiling -- Measure solution timings and decide on a time limit appropriate    for the target judge's hardware.</li> <li>Packaging -- Build the problem into a format the judge system understands.</li> <li>Uploading -- Get the package into the judge, either manually or automatically.</li> </ol>"},{"location":"setters/packaging-walkthrough/#profiling","title":"Step 1: Profile the time limit","text":"<p>Different judge systems run on different hardware. A time limit that works on your laptop may be too tight -- or too generous -- on the actual judging machine. rbx solves this with limits profiles: named sets of time/memory limits stored in the <code>.limits/</code> directory of your problem.</p> <p>Info</p> <p>For a complete reference on profiling, formulas, and profiles, see the Profiling guide.</p>"},{"location":"setters/packaging-walkthrough/#create-a-profile-for-boca","title":"Create a profile for BOCA","text":"<p>The BOCA packager requires a limits profile named <code>boca</code> to exist. You create it with the <code>time</code> command. Preferrably, log in to your judge machine, clone your contest's repository and run the command there.</p> <pre><code>rbx time -p boca\n</code></pre> <p>This launches an interactive session that:</p> <ol> <li>Shows the current profile (if one already exists).</li> <li>Asks you to choose a strategy for deciding the time limit.</li> <li>Runs all accepted solutions with no time limit enforced, measuring their true    execution times.</li> <li>Applies a formula to the timings and writes the result to <code>.limits/boca.yml</code>.</li> </ol> <p>Tip</p> <p>If you want to skip the interactive prompts and use the default formula, add the <code>--auto</code> flag:</p> <pre><code>rbx time -p boca --auto\n</code></pre>"},{"location":"setters/packaging-walkthrough/#choose-a-strategy","title":"Choose a strategy","text":"<p>When prompted, you'll see four strategies:</p> Strategy When to use Estimate (recommended) Let rbx measure your solutions and apply a formula. Best default. Inherit from package Mirror whatever <code>timeLimit</code> and <code>memoryLimit</code> are set in <code>problem.rbx.yml</code>. Estimate with custom formula Like Estimate, but you provide your own formula. Custom time limit You already know the exact time limit you want. <p>The default formula is:</p> <pre><code>step_up(max(fastest * 3, slowest * 1.5), 100)\n</code></pre> <p>This takes the maximum of 3x the fastest accepted solution and 1.5x the slowest, then rounds up to the nearest 100 ms. You can customize this formula in <code>env.rbx.yml</code> -- see the Profiling docs for details.</p>"},{"location":"setters/packaging-walkthrough/#review-the-resulting-profile","title":"Review the resulting profile","text":"<p>After the estimation finishes, the profile is saved to <code>.limits/boca.yml</code>. It looks something like this:</p> <pre><code># .limits/boca.yml\ninheritFromPackage: false\ntimeLimit: 2000\nmemoryLimit: 256\nformula: \"step_up(max(fastest * 3, slowest * 1.5), 100)\"\n</code></pre> <p>You can also add per-language overrides if your contest accepts solutions in multiple languages with different performance characteristics:</p> <pre><code>modifiers:\n  py:\n    time: 6000          # Python gets a higher time limit (ms)\n  java:\n    timeMultiplier: 2.0 # Java gets 2x the base time limit\n</code></pre> <p>Tip</p> <p>When <code>rbx time</code> detects accepted solutions in multiple languages, it will automatically prompt you to set per-language limits. You can also edit the profile manually or through the TUI (<code>rbx ui</code> &gt; Edit limits profiles).</p>"},{"location":"setters/packaging-walkthrough/#verify-with-the-profile-active","title":"Verify with the profile active","text":"<p>Once your profile is ready, you can run your solutions under the BOCA limits to make sure everything still passes:</p> <pre><code>rbx -p boca run\n</code></pre> <p>The <code>-p</code> (or <code>--profile</code>) flag is a global flag that tells rbx to use the specified limits profile for the run.</p>"},{"location":"setters/packaging-walkthrough/#working-with-multiple-profiles","title":"Working with multiple profiles","text":"<p>You can create as many profiles as you need -- one per target judge:</p> <pre><code>rbx time -p boca\nrbx time -p polygon\nrbx time -p local    # the default profile\n</code></pre> <p>Each profile is independent, so you can tune limits for each judge's hardware separately.</p>"},{"location":"setters/packaging-walkthrough/#persisting-the-profile","title":"Persisting the profile","text":"<p>Now, since the profile is saved into <code>.limits</code>, you can push it into your contest's repository, and access it from any machine. Feel free to follow the next steps in any machine of your choice, as long as you've pushed the profile into the repository.</p>"},{"location":"setters/packaging-walkthrough/#packaging","title":"Step 2: Build the package","text":"<p>With the <code>boca</code> limits profile in place, you can now build the BOCA package:</p> <pre><code>rbx package boca\n</code></pre> <p>This command performs the following steps automatically:</p> <ol> <li>Loads the <code>boca</code> limits profile from <code>.limits/boca.yml</code>.</li> <li>Builds all testcases -- generators are run, inputs are validated, outputs are    generated using the main solution.</li> <li>Verifies all solutions -- every solution is run against the testcases and its    outcome is checked.</li> <li>Builds statements -- the problem statement is compiled into a PDF.</li> <li>Produces a <code>.zip</code> file in the BOCA format, ready for upload.</li> </ol> <p>The resulting <code>.zip</code> is saved in the problem's <code>build/</code> directory.</p>"},{"location":"setters/packaging-walkthrough/#verification-levels","title":"Verification levels","text":"<p>By default, packaging runs at verification level 4 (the maximum), which runs all solutions and checks their expected outcomes. You can lower this to speed things up during development:</p> <pre><code>rbx package boca -v0  # Only generate tests, no validation\nrbx package boca -v1  # Generate tests and validate inputs\nrbx package boca -v2  # Also run accepted solutions\nrbx package boca -v3  # Also run non-TLE solutions\nrbx package boca -v4  # Run all solutions (default)\n</code></pre> <p>See the Packaging overview for the full verification level table.</p>"},{"location":"setters/packaging-walkthrough/#packaging-an-entire-contest","title":"Packaging an entire contest","text":"<p>If you're working in a contest directory, you can package all problems at once:</p> <pre><code>rbx each package boca\n</code></pre> <p>Or target specific problems by letter:</p> <pre><code>rbx on A package boca       # Only problem A\nrbx on A-C package boca     # Problems A through C\nrbx on A,C package boca     # Problems A and C\n</code></pre>"},{"location":"setters/packaging-walkthrough/#uploading","title":"Step 3: Upload to BOCA","text":"<p>Once you have your <code>.zip</code> package, you need to get it into the BOCA server. There are two ways to do this: automated upload via rbx and manual upload through the BOCA web interface.</p>"},{"location":"setters/packaging-walkthrough/#automated-upload","title":"Option A: Automated upload with <code>-u</code>","text":"<p>The easiest approach is to use the <code>--upload</code> (or <code>-u</code>) flag, which builds the package and uploads it in a single step:</p> <pre><code>rbx package boca -u\n</code></pre>"},{"location":"setters/packaging-walkthrough/#set-up-boca-credentials","title":"Set up BOCA credentials","text":"<p>For the upload to work, rbx needs to know how to connect to your BOCA server. Set the following environment variables, either in your shell or in a <code>.env</code> / <code>.env.local</code> file at the root of your contest:</p> .env<pre><code>BOCA_BASE_URL=\"https://your.boca.com/boca\"\nBOCA_USERNAME=\"admin_username\"\nBOCA_PASSWORD=\"admin_password\"\n</code></pre> <p>If you're using a judge account instead of an admin account:</p> .env<pre><code>BOCA_BASE_URL=\"https://your.boca.com/boca\"\nBOCA_JUDGE_USERNAME=\"judge_username\"\nBOCA_JUDGE_PASSWORD=\"judge_password\"\n</code></pre> <p>Warning</p> <p>The configured user must be an admin of the contest in BOCA, otherwise the upload will fail. Also make sure the correct contest is activated on the BOCA server before running the command.</p>"},{"location":"setters/packaging-walkthrough/#upload-an-entire-contest","title":"Upload an entire contest","text":"<p>You can combine the upload flag with the contest-level commands:</p> <pre><code># Upload all problems\nrbx each package boca -u\n\n# Upload only problem A\nrbx on A package boca -u\n\n# Upload problems A through C\nrbx on A-C package boca -u\n</code></pre>"},{"location":"setters/packaging-walkthrough/#manual-upload","title":"Option B: Manual upload","text":"<p>If you prefer not to configure credentials, or if your BOCA instance isn't reachable from your machine, you can upload the package manually:</p> <ol> <li> <p>Build the package without the <code>-u</code> flag:</p> <pre><code>rbx package boca\n</code></pre> </li> <li> <p>Locate the <code>.zip</code> file in the <code>build/</code> directory of your problem.</p> </li> <li> <p>Log in to the BOCA web interface as a contest admin.</p> </li> <li> <p>Navigate to the Problems tab and upload the <code>.zip</code> file for the    corresponding problem letter.</p> </li> </ol> <p>Tip</p> <p>If you run into issues with BOCA packaging or uploading, check the BOCA troubleshooting section for common problems and solutions.</p>"},{"location":"setters/packaging-walkthrough/#next-steps","title":"Next steps","text":"<ul> <li> <p> Fine-tune your limits</p> <p>Learn about custom formulas, per-language modifiers, and the TUI limits editor.</p> <p> Profiling</p> </li> <li> <p> Explore other formats</p> <p>Package for Polygon, or other formats supported by rbx.</p> <p> Packaging</p> </li> <li> <p> Build statements</p> <p>Create PDF statements using rbxTeX, LaTeX, and Jinja.</p> <p> Statements</p> </li> <li> <p> Full CLI reference</p> <p>See all available flags and commands.</p> <p> CLI reference</p> </li> </ul>"},{"location":"setters/stress-testing/","title":"Stress testing","text":"<p>Stress testing is a technique used to verify the correctness of a solution by generating random inputs and checking if the solution behaves as expected.</p> <p>Although the technique is often employed to prove (or disprove) the correctness of a solution, it's also often used to find tests that break a known incorrect solution.</p> <p>Thus, it can be used both as a problem verification tool, but also as a testset construction tool. In this section, we'll go through the process of writing and running a stress test, and how to use this tool to improve our testset or the confidence in our solutions.</p>"},{"location":"setters/stress-testing/#defining-a-stress-test","title":"Defining a stress test","text":"<p>If you haven't read the Generators section yet, please do so before continuing as generators are an essential part of the stress testing framework.</p> <p>To run a stress test, we must define two expressions:</p> <ul> <li>A generator expression: a string in a special format that describes how to generate an   infinite random sequence of generator calls;</li> <li>A finder expression: a string in a special format that describes a condition for a testcase   to be considered a match for the stress test.</li> </ul>"},{"location":"setters/stress-testing/#generator-expression","title":"Generator expression","text":"<p>The generator expression is a special variation of a generator call. In fact, a generator call is a valid generator expression. Below, there are a few examples of valid generator expressions for a hypothetical generator named <code>gen</code> that generates a random integer between 1 and <code>N</code>, where <code>N</code> is a value passed on the generator call <code>gen N</code>.</p> <pre><code># A valid generator expression, but not super useful for a stress test.\n# Since generators are idempotent, the testcases will always have the same number.\ngen 100\n\n# The `@` operator is replaced by a random 8-character string when evaluated.\n# This will produce a different testcase each time, containing a random integer between 1 and 100.\ngen 100 @\n\n# Generates a number N between 1 and 100, and then generate a number between 1 and N.\ngen [1..100] @\n\n# Generates a number between 1 and N.max, where N.max is a variable defined for the problem.\ngen &lt;N.max&gt; @\n</code></pre> <p>Thus, a generator expression supports a set of operators and, when evaluated, produces a generator call. This generator call is used to produce a testcase for the stress test.</p> <p>In the table below, you can see the supported operators and their semantics.</p> <p>Operator</p> <p>Description</p> <p>Example</p> <p><code>@</code></p> <p>Random 8-char string</p> <p><code>gen 100 @</code></p> <p><code>&lt;var&gt;</code></p> <p>Variable defined for the problem</p> <p><code>gen &lt;N.max&gt; @</code></p> <p><code>[a..b]</code> </p> <p>Random integer between <code>a</code> and <code>b</code> </p> <p><code>gen [1..100] @</code> <code>gen [1..&lt;N.max&gt;] @</code></p> <p>(<code>a</code> | <code>b</code>)</p> <p>Random element <code>a</code> or <code>b</code></p> <p><code>gen (a</code> | <code>b) @</code></p>"},{"location":"setters/stress-testing/#finder-expressions","title":"Finder expressions","text":"<p>Finder expressions are domain-specific expressions evaluated by rbx that return a boolean value.</p> <p>Instead of formally defining the grammar for finder expressions, we list a few examples, with an explanation of what they do. They should give a rough understanding of how this feature works.</p> <pre><code># Find a test for which `sols/wa.cpp` returns any verdict considered incorrect.\n# Both versions are equivalent, the first one being a shorthand for the second.\nsols/wa.cpp\n[sols/wa.cpp] ~ INCORRECT\n\n# Find a test that fails one incorrect solution and a TLE solution at the same time.\n[sols/wa.cpp] ~ INCORRECT &amp;&amp; [sols/tle.cpp] ~ TLE\n\n# Find a test that fails one incorrect solution, but do not TLE other solution at the same time.\n[sols/wa.cpp] ~ INCORRECT &amp;&amp; [sols/tle.cpp] !~ TLE\n[sols/wa.cpp] ~ INCORRECT &amp;&amp; !([sols/tle.cpp] ~ TLE)\n\n# Find a test that fails one or the other.\n[sols/wa.cpp] ~ INCORRECT || [sols/wa2.cpp] ~ INCORRECT\n\n# Find a test where solutions give different verdicts.\n[sols/sol1.cpp] != [sols/sol2.cpp]\n\n# By using the ON syntax, specifies a custom checker to be used (instead of the main one).\n[sols/wa.cpp ON custom-checker.cpp] ~ INCORRECT\n\n# Use no checker whatsoever. Useful when you don't have a checker yet.\n[sols/tle.cpp ON :nil] ~ TLE\n\n# Use a 2-way checker. This checker will only require the input and the\n# output generated by the stressed program. In place of the output of the\n# main solution, an empty file will be passed.\n#\n# Useful if you don't have a main solution yet.\n[sols/wa.cpp ON 2:my_checker.cpp] ~ INCORRECT\n\n# Special operators:\n# Find a test that breaks the main solution (here, specified by a $).\n[$] ~ INCORRECT\n\n# Find a test that breaks the main solution, using the main checker in\n# a 2-way fashion.\n[$ ON 2:$] ~ INCORRECT\n</code></pre>"},{"location":"setters/stress-testing/#running-a-stress-test","title":"Running a stress test","text":"<p>rbx exposes an <code>rbx stress</code> command that can be used to run a stress test. The syntax is pretty straightforward.</p> <pre><code>rbx stress -g \"&lt;generator-expression&gt;\" -f \"&lt;finder-expression&gt;\"\n</code></pre> <p>By default, the stress test will be run for 10 seconds and will stop as soon as a match is found. You can tune these values with the <code>--findings / -n</code> and the <code>--timeout / -t</code> flags.</p> <pre><code># Runs for 2 minutes or stops after finding 3 matches.\nrbx stress -g \"&lt;generator-expression&gt;\" -f \"&lt;finder-expression&gt;\" -n 3 -t 120\nrbx stress -g \"gen 100 @\" -f sols/main.cpp\nrbx stress -g \"gen 100 @\" -f \"[sols/main.cpp] ~ INCORRECT\" -n 3 -t 120\n</code></pre> <p>The command will show a summary of what tests were found, and in case there's at least one match, it will prompt you to inform a testplan to add it to. If you skip this part, you can always copy the generator calls that were found and add them later.</p>"},{"location":"setters/stress-testing/#saving-a-stress-test","title":"Saving a stress test","text":"<p>You can save a stress test in your <code>problem.rbx.yml</code> file.</p> <pre><code>stresses:\n  - name: 'my-stress-test'\n    generator:\n      name: 'gen'\n      args: '100 @'\n    finder: '[sols/main.cpp] ~ INCORRECT'\n</code></pre> <p>You can then run the stress test with:</p> <pre><code>rbx stress my-stress-test\n</code></pre>"},{"location":"setters/stress-testing/#fuzzing-inputs","title":"Fuzzing inputs","text":"<p>You can also use the <code>--fuzz</code> flag to stress test using variations of the generator calls defined in your testset. This is useful to find corner cases around your existing tests.</p> <pre><code># Fuzz all testgroups against the main solution\nrbx stress --fuzz\n\n# Fuzz specific testgroups (e.g. only 'random' and 'max')\nrbx stress --fuzz-on random --fuzz-on max\n\nrbx stress --fuzz -f sols/some-solution.cpp\n</code></pre> <p>When fuzzing, rbx takes the generator calls from the selected groups and appends a random suffix to them. If no finder (<code>-f</code>) is specified, it defaults to checking if the main solution crashes or returns an incorrect verdict.</p>"},{"location":"setters/stress-testing/#finding-slowest-tests","title":"Finding slowest tests","text":"<p>You can use the <code>--slowest</code> flag to find strict time limit violations or simply the testcases that make your solution run the slowest. When this flag is enabled, the time limit for the solution is removed, and rbx will keep track of the slowest testcases found so far.</p> <pre><code># Find the slowest testcases for the main solution using the given generator\nrbx stress -g \"gen 100 @\" -f sols/main.cpp --slowest\n\n# Find the 5 slowest testcases\nrbx stress -g \"gen 100 @\" -f sols/main.cpp --slowest -n 5\n</code></pre>"},{"location":"setters/stress-testing/#other-applications-of-stress-tests","title":"Other applications of stress tests","text":"<p>Besides using stress tests for checking solution outcomes, you can be creative and use it to test other components of your problem.</p> <p>For example, you can use it to test your checkers.</p> <pre><code># Find a test where the checker returns something different than WA,\n# even though the given solution always WA.\n[sols/always-wa.cpp ON custom-checker.cpp] != WA\n\n# Compare two checkers to see if they're misbehaving.\n[sols/sol.cpp ON custom-checker.cpp] != [sols/sol.cpp ON brute-force-checker.cpp]\n</code></pre> <p>Or you can even use it to test your validator and your interactor by simply stressing them to the limit.</p>"},{"location":"setters/variables/","title":"Variables","text":"<p>Variables are a way to define the constraints of your problem in a single place and reference them everywhere else.</p> <p>The motivation for having variables are simple: imagine you've decided to change the constraints of your problem. Without variables, you'd have to change this constraint in the validator, (potentially) in the checker and in the statements. It's super easy to forget about these changes, increasing the likelihood of introducing a disastrous bug in your problem.</p>"},{"location":"setters/variables/#defining-variables","title":"Defining variables","text":"<p>Variables are defined in the <code>vars</code> section of your <code>problem.rbx.yml</code> file.</p> problem.rbx.yml<pre><code># ...\nvars:\n  N:\n    min: 1\n    max: 100000\n  M:\n    min: 1\n    max: 200000\n</code></pre> <p>They're defined as key-value pairs. The keys should be valid Python identifiers and the values should be a <code>bool</code>, a <code>string</code>, an <code>int</code> or a <code>float</code>, all conforming to the YAML specification.</p> <p>Besides that, it's possible to use Python expressions that evaluate to one of these types, using the <code>py`...`</code> syntax. </p> problem.rbx.yml<pre><code># ...\nvars:\n  N:\n    max: py`10**5`\n  M:\n    max: py`2*10**5`\n</code></pre>"},{"location":"setters/variables/#using-variables","title":"Using variables","text":"<p>Variables can be used within validators, checkers and statements.</p> <p>In this section, we go through the different ways to use variables in each of these.</p>"},{"location":"setters/variables/#validators-and-checkers-c","title":"Validators and checkers (C++)","text":"<p>rbx automatically generates a <code>rbx.h</code> header file that contains the variables that were defined in the <code>problem.rbx.yml</code> file, right at the root of your package.</p> <p>This header exposes a function <code>getVar&lt;T&gt;(name)</code> that can be used to get the value of a variable as a <code>T</code>-typed object. There are 4 overloads for this function: <code>getVar&lt;bool&gt;(name)</code>, <code>getVar&lt;int&gt;(name)</code>, <code>getVar&lt;float&gt;(name)</code> and <code>getVar&lt;std::string&gt;(name)</code>.</p> <p>This header can be directly included in your validator/checker files.</p> validator.cppchecker.cpp <pre><code>#include \"testlib.h\"\n#include \"rbx.h\"\n\nint main(int argc, char* argv[]) {\n    registerValidation(argc, argv);\n\n    int n = getVar&lt;int&gt;(\"N.max\");\n    int m = getVar&lt;int&gt;(\"M.max\");\n\n    // Single line with two numbers.\n    inf.readInt(1, n, \"n\");\n    inf.readSpace();\n    inf.readInt(1, m, \"m\");\n    inf.readEoln();\n    inf.readEof();\n}\n</code></pre> <pre><code>#include \"testlib.h\"\n#include \"rbx.h\"\n\nint main(int argc, char* argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int n = getVar&lt;int&gt;(\"N.max\");\n    int m = getVar&lt;int&gt;(\"M.max\");\n\n    // ...\n}\n</code></pre>"},{"location":"setters/variables/#validators-other-languages","title":"Validators (other languages)","text":"<p>Validators also receive the variables as command-line arguments. This means that for the <code>problem.rbx.yml</code> above, your validator would be called roughly as follows:</p> <pre><code>./validator.exe --N.max=100000 --M.max=200000\n</code></pre> <p>You can freely parse those arguments in your language of choice.</p> <p>Checkers</p> <p>Checkers do not receive the variables as command-line arguments, as doing so is not compatible with any judging platforms.</p> <p>If you want to use variables in your checkers, they must be in C++ and you have to follow the approach outlined in the previous section.</p>"},{"location":"setters/variables/#statements","title":"Statements","text":"<p>rbxTeX statements can also use variables. This is done by using the <code>\\VAR</code> command with the <code>vars.</code> prefix.</p> statement.rbx.tex<pre><code>% ...\nYou're given a graph with \\VAR{N.max} vertices and \\VAR{M.max} edges.\n% ...\n</code></pre> <p>Variables can also be used within any rbxTeX statements, including loops and conditionals.</p> statement.rbx.tex<pre><code>% ...\n%- if vars.N.max &lt; 1000:\nThis problem is easy.\n%- else:\nThis problem is hard.\n%- endif\n% ...\n</code></pre> <p>Also, rbx exposes a few transform builtins that can be used to change how a variable is rendered. One of them is the <code>sci</code> builtin, which formats a number with many trailing zeroes in scientific notation.</p> statement.rbx.tex<pre><code>% ...\nYou're given a graph with \\VAR{N.max | sci} vertices\nand \\VAR{M.max | sci} edges.\n% ...\n</code></pre> <p>The <code>sci</code> builtin will make <code>N.max</code> and <code>M.max</code> be rendered as something like <code>10^5</code> and <code>2 x 10^5</code> respectively.</p>"},{"location":"setters/variables/#stress-tests","title":"Stress tests","text":"<p>Variables can also be used in generator expressions in stress tests with the <code>&lt;variable&gt;</code> notation.</p> <pre><code>rbx stress -g \"gen [1..&lt;N.max&gt;]\" -f \"[sols/wa.cpp] ~ INCORRECT\"\n</code></pre>"},{"location":"setters/grading/","title":"Grading","text":"<p>In competitive programming, grading is the process of running and evaluating whether the participant's solution is correct for a given testcase (or a set of testcases).</p> <p>rbx provides control over the full grading process, which in the case of setting problems, is way simpler than in the case of running an actual contest.</p> <p>In contests, the judging system is usually much more complex, and has to:</p> <ol> <li>Give a fair verdict to the participant: TLE when the solution is too slow, WA when the solution is incorrect, etc.</li> <li>Protect the system: prevent participants from cheating, from crashing the server, doing prohibited   system calls, etc.</li> </ol> <p>Security</p> <p>In the case of setting problems, we can focus on the first point, and assume setters are trustful actors and ignore the second one. Thus, rbx does not provide any mechanism to protect the system against malicious code being run. Be aware of that, and only run code written by authors you trust!</p> <p>Solutions will be run as the same user that run the <code>rbx</code> command. If you want to be extra careful, you can run <code>rbx</code> inside a Docker container, or create an isolated user with limited permissions to run it.</p>"},{"location":"setters/grading/#running-solutions","title":"Running solutions","text":"<p>Solutions run through rbx are executed through a wrapper script. This script applies memory and output limit constraints to the program through a mixture of <code>ulimit</code> calls and realtime resource usage monitoring.</p> <p>Different from judging systems, where sandboxes are usually written in C/C++ and are run as privileged users, this wrapper script is written in Python for better portability.</p>"},{"location":"setters/grading/#outcomes","title":"Outcomes","text":"<p>Right after running the solution, we must give a verdict to it (or, as we call them in rbx, an outcome).</p> <p>You can find the full list of outcomes in the table below.</p> Outcome Short name Description <code>ACCEPTED</code> <code>AC</code> The solution passed all the testcases. <code>WRONG_ANSWER</code> <code>WA</code> The solution produced an incorrect output. <code>TIME_LIMIT_EXCEEDED</code> <code>TLE</code> The solution took too much time to execute. <code>MEMORY_LIMIT_EXCEEDED</code> <code>MLE</code> The solution used too much memory. <code>IDLENESS_LIMIT_EXCEEDED</code> <code>ILE</code> The solution was idle for too long. <code>RUNTIME_ERROR</code> <code>RTE</code> The solution crashed. <code>OUTPUT_LIMIT_EXCEEDED</code> <code>OLE</code> The solution produced too much output. <code>JUDGE_FAILED</code> <code>FL</code> The judge failed to execute or produced an incorrect answer. <code>INTERNAL_ERROR</code> <code>IE</code> An internal error occurred. <p>All outcomes, except for <code>JUDGE_FAILED</code>, <code>WRONG_ANSWER</code> and <code>ACCEPTED</code> are all defined right after the solution runs.</p> <p>There's a process that needs to be executed right after the solution runs, and it's called checking, and you can read more about it in the Checkers section.</p>"},{"location":"setters/grading/#limits","title":"Limits","text":"<p>All limits that are applied to a solution are defined in <code>problem.rbx.yml</code> under the <code>*limit</code> family of fields.</p> problem.rbx.yml<pre><code># ... rest of the problem.rbx.yml ...\ntimeLimit: 1000  # 1 second\nmemoryLimit: 256  # 256 MB\n</code></pre> <p>Time is always defined in milliseconds, and memory is defined in megabytes. These limits are all applied by the wrapper script, and checked further after the solution is executed.</p> <p>You can also control the maximum size of the participant's output (which defaults to 4096 KB).</p> problem.rbx.yml<pre><code># ... rest of the problem.rbx.yml ...\noutputLimit: 1024  # 1024 KB\n</code></pre> <p>And you can also provide language-specific limits.</p> problem.rbx.yml<pre><code># ... rest of the problem.rbx.yml ...\nmodifiers:\n  java:\n    time: 2000  # 2 second\n    memory: 1024  # 1024 MB\n</code></pre>"},{"location":"setters/grading/checkers/","title":"Checkers","text":"<p>Checker is a concept introduced by testlib to verify whether the participant's solution is correct for a given testcase.</p> <p>A checking algorithm can range from a very simple diff between two files, to a much more complex algorithm such as \"does the participant output contains a path between two specific vertices by using edges that are part of the input graph?\".</p> <p>We strongly recommend using testlib checkers for your problems, as they are battle-tested and will cover most of your needs. Also, they're usually lenient with extra spaces, newlines and such.</p> <p>Think of all the frustration you had in your life with presentation errors and problems that asked you to print the \"minimum lexicographically path in a graph\" just to force the solution to be unique. testlib checkers are here to solve that.</p> <p>Non-testlib checkers</p> <p>Please, use testlib checkers. rbx is seriously opinionated about this, and although it will most of the times work with non-testlib checkers, no guarantees are given.</p> <p>This document will intentionally not cover non-testlib checkers.</p>"},{"location":"setters/grading/checkers/#built-in-testlib-checkers","title":"Built-in testlib checkers","text":"<p>rbx provides out-of-the-box support for the built-in testlib checkers defined here.</p> <p>You can use them by specifying the <code>checker</code> field in your <code>problem.rbx.yml</code> file.</p> problem.rbx.yml<pre><code># ... rest of the problem.rbx.yml ...\nchecker:\n  - path: \"wcmp.cpp\"\n</code></pre> <p>rbx will automatically detect it is a built-in checker and will download it from the testlib repository.</p> <p>The most common built-in checkers are described in the table below, but you should feel free to explore the others. The <code>wcmp.cpp</code> checker is the default checker for rbx, since it's basically a space-tolerant diff.</p> <p>Checker</p> <p>Description</p> <p><code>wcmp.cpp</code> </p> <p>Compares the sequence of words of two files, as if they were a tuple. First, the files are tokenized, and then each token is compared.</p> <p><code>ncmp.cpp</code></p> <p>Same as <code>wcmp.cpp</code>, but compares 64-bit signed integers.</p> <p><code>uncmp.cpp</code></p> <p>Same as <code>ncmp.cpp</code>, but disregards the order of the numbers.</p> <p><code>yesno.cpp</code></p> <p>Compares a single word which must be \"YES\" or \"NO\" (case-insensitive).</p> <p><code>nyesno.cpp</code></p> <p>Same as to <code>wcmp.cpp</code>, but all tokens must be \"YES\" or \"NO\" (case-insensitive).</p> <p><code>dcmp.cpp</code></p> <p>Compares two doubles by ensuring their maximal absolute or relative error is at most <code>1e-6</code>.</p> <p><code>rcmp.cpp</code></p> <p>Same as <code>dcmp.cpp</code>, but uses an error of <code>1e-9</code> instead.</p>"},{"location":"setters/grading/checkers/#custom-testlib-checkers","title":"Custom testlib checkers","text":"<p>You can also write your own testlib checkers. Checkers in rbx are programs that receives three arguments:</p> <pre><code>./checker &lt;input_file&gt; &lt;output_file&gt; &lt;answer_file&gt;\n</code></pre> <p>The arguments are:</p> <ul> <li><code>&lt;input_file&gt;</code>: the input file for the testcase.</li> <li><code>&lt;output_file&gt;</code>: the output file produced by the participant.</li> <li><code>&lt;answer_file&gt;</code>: the answer file, i.e. the one that contains the output of the model solution.</li> </ul> <p>Some times, the <code>&lt;answer_file&gt;</code> is not needed. Let's see a simple case first, and then let's look at one where the <code>&lt;answer_file&gt;</code> is needed.</p>"},{"location":"setters/grading/checkers/#output-only-case","title":"Output-only case","text":"<p>Let's say we have a problem that asks you to find a path between two vertices 1 and <code>N</code> in a graph.</p> <p>In this case, we want to check whether:</p> <ul> <li>The participant's output contains a path between two vertices 1 and <code>N</code> in the input graph.</li> <li>The path is simple, i.e. it doesn't visit any vertex (or edge) more than once.</li> </ul> <p>Let's say the input is given in the following format:</p> Input format<pre><code>N M\nu_1 v_1\nu_2 v_2\n...\nu_M v_M\n</code></pre> <p>And the output is printed in the following format:</p> Output format<pre><code>K\np_1 p_2 ... p_K\n</code></pre> <p>Where <code>K</code> is the number of vertices in the path, and <code>p_1 p_2 ... p_K</code> is the sequence of vertices in the path.</p> <p>We can write a checker that does exactly that.</p> checker.cppproblem.rbx.yml <pre><code>#include \"testlib.h\"\n\nint main(int argc, char *argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // `inf` is a stream used to read the input file.\n    int N = inf.readInt();\n    int M = inf.readInt();\n\n    vector&lt;set&lt;int&gt;&gt; adj(N + 1);\n    for (int i = 0; i &lt; M; i++) {\n        int u = inf.readInt();\n        int v = inf.readInt();\n        adj[u].insert(v);\n        adj[v].insert(u);\n    }\n\n    // Read the participant's output\n    // `ouf` is a stream used to read the participant's output.\n    int K = ouf.readInt(1, N, \"path size\"); // (1)!\n    vector&lt;int&gt; path(K);\n    for (int i = 0; i &lt; K; i++) {\n        path[i] = ouf.readInt(1, N, \"path vertex\");\n    }\n\n    // Check if the path starts at 1 and ends at N.\n    ouf.quitif(path[0] != 1, _wa, \"path does not start at 1\");  // (2)!\n    ouf.quitif(path[K - 1] != N, _wa, \"path does not end at N\");\n\n    // Check if the path is simple\n    set&lt;int&gt; seen;\n    for (int i = 0; i &lt; K; i++) {\n        ouf.quitif(seen.count(path[i]), _wa, \"path is not simple\");\n        seen.insert(path[i]);\n    }\n\n    ouf.quitf(_ok, \"path with %d vertices found\", K);  // (3)!\n}\n</code></pre> <ol> <li> <p>Notice how we're strict with the bounds of the numbers we're reading from the user. If the user     provides an invalid number, we'll mark the participant's output as wrong.</p> <p>This is especially important here, not only for correctness, but also because we'll allocate a vector of size <code>N</code> in the next step, and we don't want the participant to provide an invalid number.</p> </li> <li> <p>We use <code>quitif</code> to immediately stop the program and mark the participant's output as wrong when     some condition is not met.</p> <p>One can also use the <code>quitf</code> variant to simply quit. This allows one to write an equivalent code:</p> <pre><code>if (condition_is_not_met) {\n  ouf.quitf(_wa, \"...\");\n}\n</code></pre> </li> <li> <p>We use <code>quitf(_ok, ...)</code> to mark the participant's output as correct, and notice we can use     format specifiers in the message.</p> </li> </ol> <pre><code># ... rest of the problem.rbx.yml ...\nchecker:\n  - path: \"checker.cpp\"\n</code></pre> <p>Notice checking only the participant's output here was more than enough. We don't need to consume the <code>&lt;answer_file&gt;</code> at all.</p> <p>You can learn more about testlib streams and all the functions available in their official documentation.</p>"},{"location":"setters/grading/checkers/#output-answer-case","title":"Output + answer case","text":"<p>Sometimes, it's also important to consider the jury's solution.</p> <p>Let's consider the following modification to the problem above: now, you have to find the shortest path between two vertices 1 and <code>N</code>. We can assume the input and output format stays the same.</p> <p>The only way to be sure the participant's solution is the shortest possible is to actually find the shortest path in the input graph. That is exactly what our model solution already does, right? We could proceed in two ways here:</p> <ol> <li> <p> We could simply read the answer from the <code>&lt;answer_file&gt;</code> and ensure the participant's path size is equals to the jury's path size, and otherwise mark the participant's output as wrong.</p> </li> <li> <p> We could compare the participant's path with the jury's path, and if they are different, mark the participant's output as wrong if it's longer than the jury's path, or mark the jury's output as wrong if it's longer than the participant's path.</p> </li> </ol> <p>(1) is very dangerous for obvious reasons: what if the jury's solution is wrong? Of course, for shortest paths we simply know the optimal solution is a BFS, and it's hard to get that wrong, right? But think of more complex problems which are totally new and that probably have never been solved before. It's very easy to get that wrong, and having a checker for that can help detecting an issue in setting time (or, in worst case, in contest time).</p> <p>(2) is the way to go here, as it ensures that the participant's solution is at least as good as the jury's solution. rbx has a special outcome called <code>JUDGE_FAILED</code>, which is used to convey a checking failure, when the jury's output is wrong.</p> checker.cppproblem.rbx.yml <pre><code>#include \"testlib.h\"\n// Reads a path from the given stream, ensures it's valid\n// according to `N` and `adj`, and returns its size.\n// (1)!\nint readPath(InStream &amp;stream,\n             int N,\n             const vector&lt;set&lt;int&gt;&gt; &amp;adj) {\n  int K = stream.readInt(1, N, \"path size\");\n  vector&lt;int&gt; path(K);\n  for (int i = 0; i &lt; K; i++) {\n    path[i] = stream.readInt(1, N, \"path vertex\");\n  }\n\n  // Check if the path starts at 1 and ends at N.\n  stream.quitif(path[0] != 1, _wa, \"path does not start at 1\");\n  stream.quitif(path[K - 1] != N, _wa, \"path does not end at N\");\n\n  // Check if the path is simple\n  set&lt;int&gt; seen;\n  for (int i = 0; i &lt; K; i++) {\n    stream.quitif(seen.count(path[i]), _wa, \"path is not simple\");\n    seen.insert(path[i]);\n  }\n\n  return K;\n}\n\nint main(int argc, char *argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    // `inf` is a stream used to read the input file.\n    int N = inf.readInt();\n    int M = inf.readInt();\n\n    vector&lt;set&lt;int&gt;&gt; adj(N + 1);\n    for (int i = 0; i &lt; M; i++) {\n        int u = inf.readInt();\n        int v = inf.readInt();\n        adj[u].insert(v);\n        adj[v].insert(u);\n    }\n\n    // Read the participant's output\n    // `ouf` is a stream used to read the participant's output.\n    int K = ouf.readInt(1, N);\n    vector&lt;int&gt; path(K);\n    for (int i = 0; i &lt; K; i++) {\n        path[i] = ouf.readInt(1, N);\n    }\n\n    int psize = readPath(ouf, N, adj); // participant's path size\n    int jsize = readPath(ans, N, adj); // jury's path size\n\n    // Compare sizes of the paths (2)\n    ouf.quitif(psize &gt; jsize, _wa,\n               \"participant's path is longer than the jury's path (size %d &gt; %d)\",\n               psize, jsize);\n    ans.quitif(psize &lt; jsize, _wa,\n               \"participant's path is shorter than the jury's path (size %d &lt; %d)\",\n               psize, jsize);\n\n    ouf.quitf(_ok, \"path with %d vertices found\", K);\n}\n</code></pre> <ol> <li> <p>Notice how we extract the common logic of reading a path from a stream into a function.</p> <p>testlib is smart: if quitf is called with <code>_wa</code>, it will mark the corresponding stream as wrong, resulting in a WA verdict if the participant's output is wrong, and in a JUDGE_FAILED verdict if the jury's output is wrong.</p> </li> <li> <p>We use <code>_wa</code> to mark the jury's output (represented by the <code>ans</code> stream) as wrong and cause a JUDGE_FAILED verdict.</p> <p>We could as well use <code>quitif(..., _fail, ...)</code>, which would have the same effect.</p> <p>Note</p> <p><code>_fail</code> conveys a checking failure, regardless of the stream it was applied to.</p> <p><code>_wa</code> conveys a wrong answer, and is applied to the stream that was being checked.</p> </li> </ol> <pre><code># ... rest of the problem.rbx.yml ...\nchecker:\n  - path: \"checker.cpp\"\n</code></pre> <p>Notice how we read from both outputs, validating each of them individually, and compare their sizes at the end, giving an appropriate verdict for each of them, and avoiding assuming the jury's output is 100% correct.</p> <p>You can learn more about testlib streams and all the functions available in their official documentation.</p>"},{"location":"setters/grading/interactors/","title":"Interactors","text":"<p>Interactor is a concept introduced by testlib to play the role of an agent that communicates with the participant's solution through the pair <code>stdin</code>/<code>stdout</code> in interactive problems.</p> <p>You can read more about what is an interactive problem in this thorough Codeforces blog post written by Mike Mirzayanov.</p> <p>In this section, we will see how to write an interactive problem and how to define an interactor for it in rbx.</p>"},{"location":"setters/grading/interactors/#motivational-problem","title":"Motivational problem","text":"<p>Let's assume we have a problem that asks you to find a number between 1 and <code>N</code>, where <code>N</code> is between 2 and 1000. You should find it with at most 10 guesses to the interactor. A guess is a line in the format <code>? X</code>, where <code>X</code> is a number between 1 and <code>N</code>.</p> <p>The interactor will first give you the value of <code>N</code>, and then respond each guess with <code>&lt;</code>, <code>&gt;</code> or <code>=</code> if the guess is less than, greater than or equal to the secret number, respectively. When responding with <code>=</code>, the game ends and the solution should finish execution.</p> <p>Let's assume the secret number is 7. A possible interaction between the solution and the interactor is the following:</p> Agent Line Description Interactor <code>10</code> Tells participant that <code>N = 10</code> Participant <code>? 5</code> The participant guesses 5 Interactor <code>&lt;</code> 5 is less than the secret number Participant <code>? 7</code> The participant guesses 7 Interactor <code>=</code> 7 is equal to the secret number - Both agents finish execution"},{"location":"setters/grading/interactors/#preliminary-definitions","title":"Preliminary definitions","text":"<p>Let's first of all define an interactor for the problem. In most cases, the interactor should be the very first component to be written in an interactive problem, because it is particularly hard to write solutions and test them before having one defined.</p> <p>Tip</p> <p>Of course, you can always interactively run your solution.</p> <p>Feel free to use the <code>rbx compile &lt;solution&gt;</code> command to compile them, and run them by executing <code>build/exe</code> from your project's root directory.</p> <p>In this case, you will interactively write to the solution's <code>stdin</code>, essentially playing the role of the interactor.</p> <p>A testlib interactor consists of an executable that receives two arguments:</p> <pre><code>./interactor &lt;input_file&gt; &lt;output_file&gt;\n</code></pre> <p>Besides these two files, the interactor also communicates with the solution through the <code>stdin</code>/<code>stdout</code> files.</p> <p>The interactor:</p> <ul> <li>Receives the test input from the <code>input_file</code> (the participant can't see this file);</li> <li>Writes some logging output to the <code>output_file</code> (the participant can't see this file);</li> <li>Reads the participant's output from <code>stdin</code>;</li> <li>Writes the participant's input into <code>stdout</code>.</li> </ul> <p>This structure is depicted in the following diagram:</p> <p></p> <p>Thus, even though the communication between the two agents is done through <code>stdin</code>/<code>stdout</code>, the interactor still has its own input and output files that can have a similar purpose to the inputs and outputs of an usual batch problem.</p> <p>For this problem, let's assume we have a testset containing some input files containing two numbers: <code>N</code> and the secret number <code>S</code>, with <code>1 &lt;= S &lt;= N &lt;= 1000</code>. We can also assume we've written a validator for this file.</p> <p>Note</p> <p>Notice validators will receive the input file the interactor reads from, not the <code>stdin</code> of the participant's solution.</p>"},{"location":"setters/grading/interactors/#the-interactor","title":"The interactor","text":"<p>You can read more about testlib interactors in the official testlib documentation.</p> <p>Now that we have our input formally defined, let's write a testlib interactor and set it up in our problem.</p> <p>You can see in the commented code below how to read from each of the files available to the interactor.</p> interactor.cppproblem.rbx.yml <pre><code>#include \"testlib.h\"\n#include \"rbx.h\"\n\nusing namespace std;\n\n// Testlib interactors have a non-conventional stream setup:\n// - inf: for reading the input file\n// - ouf: for reading the participant's output\n// And two C++ IO streams for writing:\n// - cout: for writing to the participant's input\n// - tout: for writing the output file\nint main(int argc, char *argv[]) {\n    registerInteraction(argc, argv);\n\n    int N = inf.readInt(); // (1)!\n    int S = inf.readInt();\n\n    int MAX_Q = getVar&lt;int&gt;(\"Q.max\"); // (2)!\n\n    for(int i = 0; i &lt; MAX_Q; i++) {\n      int X = ouf.readInt(1, N); // (3)!\n\n      if(X &lt; S) { // (4)!\n        cout &lt;&lt; \"&lt;\" &lt;&lt; endl;\n      } else if(X &gt; S) {\n        cout &lt;&lt; \"&gt;\" &lt;&lt; endl;\n      } else {\n        cout &lt;&lt; \"=\" &lt;&lt; endl;\n        tout &lt;&lt; i+1 &lt;&lt; endl; // (5)!\n        quitf(_ok, \"found the secret number in %d guesses\", i + 1);\n      }\n    }\n\n    quitf(_wa, \"exceeded the maximum number of guesses\");\n}\n</code></pre> <ol> <li> <p>Reads the two input numbers from the input file.</p> <p>This was either provided by a generator or manually by you.</p> </li> <li> <p>Reads the maximum number of guesses allowed from the rbx variables.</p> <p>We defined this would be 10 in the statement above, but let's define this as a variable as a good practice.</p> </li> <li> <p>Reads the participant's guess from the <code>stdin</code> of the interactor / <code>stdout</code> of the solution.</p> <p>Notice we also check it is within bounds.</p> </li> <li> <p>Writes back the response to the guess to the <code>stdout</code> of the interactor / <code>stdin</code> of the solution.</p> <p>We use the common C++ <code>std::cout</code> stream for that.</p> </li> <li> <p>In case the solution is correct, writes the number of guesses to the output file for logging purposes (in some judging systems, you can inspect this file, for instance).</p> <p>We use the C++ <code>tout</code> stream for that.</p> </li> </ol> <pre><code># ... rest of the problem.rbx.yml ...\n# We have to set these for the problem to be considered interactive\ntype: COMMUNICATION\ninteractor:\n  path: 'interactor.cpp'\n# ...\nvars:\n  Q:\n    max: 10\n</code></pre>"},{"location":"setters/grading/interactors/#executing-solutions-against-the-interactor","title":"Executing solutions against the interactor","text":"<p>Solutions for interactive problems can be executed normally, similar to batch problems, with the <code>rbx run</code> and <code>rbx irun</code> commands.</p> <p>Read more about them in the Running solutions section.</p> <p>Warning</p> <p>When providing a custom input for <code>rbx irun</code>, you're actually providing the input to the interactor, NOT the solution.</p> <p>The results of the run can also be inspected using the <code>rbx ui</code> command.</p> <p>If you want to compile the solution, and interactively communicate with it as if you were the interactor agent, you can compile your solution with the <code>rbx compile</code> command and then run it manually with <code>./build/exe</code>.</p> <pre><code>rbx compile solution.cpp\n./build/exe\n# ... start interacting with the solution as the interactor ...\n</code></pre>"},{"location":"setters/grading/interactors/#do-i-need-to-write-a-checker","title":"Do I need to write a checker?","text":"<p>Short answer: no, you don't need to write a checker. In fact, the ICPC package format doesn't support one.</p> <p>Instead, this format expects the interactor to both communicate with the solution and judge it. Other judging systems do support specifying a checker, and some even require one (e.g., Polygon). However, this practice is not encouraged by rbx, as it is not part of the ICPC package format.</p> <p>Tip</p> <p>rbx will automatically generate a dummy/no-op checker when you generate a package for a judging system that requires one. You should not worry about this!</p> <p>rbx does give you the flexibility to specify a checker by setting an extra bit in the <code>problem.rbx.yml</code> file. This is put there as a guard so you don't mistakenly set a checker for your interactive problem without realizing it.</p> problem.rbx.yml<pre><code># ...\ntype: COMMUNICATION\ninteractor:\n  path: 'interactor.cpp'\n  legacy: true\nchecker:\n  path: 'checker.cpp'\n</code></pre> <p>The newly defined checker will read as the outputs for the participant's and the jury's solutions the <code>output_files</code> produced by their interactor runs (whatever was written into <code>tout</code>).</p> <p></p> <p>Then, you could split the previously defined interactor into two files as such:</p> interactor.cppchecker.cpp <pre><code>#include \"testlib.h\"\n\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerInteraction(argc, argv);\n\n    int N = inf.readInt();\n    int S = inf.readInt();\n\n    while (true) {\n      int X = ouf.readInt(1, N);\n\n      if(X &lt; S) {\n        cout &lt;&lt; \"&lt;\" &lt;&lt; endl;\n      } else if(X &gt; S) {\n        cout &lt;&lt; \"&gt;\" &lt;&lt; endl;\n      } else {\n        cout &lt;&lt; \"=\" &lt;&lt; endl;\n        tout &lt;&lt; i+1 &lt;&lt; endl;\n      }\n    }\n\n    quitf(_ok, \"ok\"); // leave the query limit to the checker\n}\n</code></pre> <pre><code>#include \"testlib.h\"\n#include \"rbx.h\"\n\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerTestlibCmd(argc, argv);\n\n    int N = inf.readInt();\n    int S = inf.readInt();\n\n    int MAX_Q = getVar&lt;int&gt;(\"Q.max\");\n\n    int p_guesses = ouf.readInt();\n\n    if (p_guesses &gt; MAX_Q) {\n        quitf(_wa, \"participant exceeded the maximum number of guesses (%d &gt; %d)\", p_guesses, MAX_Q);\n    }\n\n    quitf(_ok, \"found the secret number in %d guesses\", p_guesses);\n}\n</code></pre> <p>Incompatible with ICPC</p> <p>This is not part of the ICPC package format, and thus rbx will throw an error if you try to generate an ICPC package for an interactive problem that has a checker.</p> <p>The solution will be to migrate the checker into the interactor.</p>"},{"location":"setters/packaging/","title":"Packaging","text":"<p>rbx supports exporting problem/contest packages into a few formats. You can see in the table below which formats are supported, and what are its supported features and limitations:</p> <p>Format</p> <p>Target Systems</p> <p>Supports</p> <p>ICPC (coming soon) </p> <p>DOMjudge, Kattis </p> <p> Interactive problems (without checker)  Batch problems  Test grouping  Limits per language  Solution verification  Package upload</p> <p>BOCA </p> <p>BOCA </p> <p> Interactive problems (with checker)  Batch problems  Limits per language  Package upload  Test grouping  Solution verification</p> <p>Polygon </p> <p>Codeforces, Polygon </p> <p> Interactive problems (with checker)  Batch problems  Limits per language  Package upload (with limitations)  Solution verification  Test grouping</p>"},{"location":"setters/packaging/#rbx-package","title":"<code>rbx package</code>","text":"<p>rbx provides an umbrella <code>rbx package &lt;format&gt;</code> command group that contains commands for each of the formats supported by it.</p> <p>All these formats support a <code>-v</code> flag, that sets the verification level for building the package.</p> <p>By default, packages will be built with the <code>-v</code> flag set to <code>4</code> (the maximum value), which means that tests will be built, validated and all solutions will be run against them, and their expected outcomes will be verified.</p> <p>You can change this by setting the <code>-v</code> flag to a different value, with the following meanings:</p> <ul> <li><code>0</code>: Tests will be built, no validation will be done.</li> <li><code>1</code>: Tests will be built and validated.</li> <li><code>2</code>: Tests will be built, validated and accepted solutions will be run against them, and their expected outcomes will be verified.</li> <li><code>3</code>: Tests will be built, validated and non-TLE solutions will be run against them, and their expected outcomes will be verified.</li> <li><code>4</code>: Tests will be built, validated and all solutions will be run against them, and their expected outcomes will be verified.</li> </ul> <p>The example below shows how to build an ICPC package by only generating tests and validating them.</p> <pre><code>rbx package icpc -v1\n</code></pre> <p>See each one of the sections dedicated to each of the avilable formats on the sidebar.</p>"},{"location":"setters/packaging/boca/","title":"Packaging: BOCA","text":"<p>rbx provides a command to build packages for BOCA.</p> <pre><code>rbx package boca\n</code></pre> <p>Or, if you want to build the package for all problems in your contest:</p> <pre><code>rbx each package boca\n</code></pre> <p>Both batch problems and interactive problems are supported.</p>"},{"location":"setters/packaging/boca/#interactive-problems","title":"Interactive problems","text":"<p>Interactive problems can be easily packaged for BOCA with rbx. There are some limitations to it, though:</p> <ul> <li>The BOCA package needs a checker. In case you don't provide one, the tool will automatically generate a dummy one,   one that returns AC for all inputs, as long as the interactor finishes successfully.</li> <li>The messages exchanged between the interactor and the solution will not be captured, and thus will not be visible   in the BOCA UI. If you want to inspect the interaction between them, you have to download the participant's   solution and run it locally.</li> </ul>"},{"location":"setters/packaging/boca/#uploading-to-boca","title":"Uploading to BOCA","text":"<p>You can upload the package to BOCA by setting the <code>--upload</code> / <code>-u</code> flag.</p> <pre><code>rbx package boca -u\n</code></pre> <p>Or you can use the contest-level commands below.</p> <pre><code># Will upload all problems in the contest\nrbx each package boca -u\n\n# Will upload only problem A\nrbx on A package boca -u\n\n# Will upload problems A to C\nrbx on A-C package boca -u\n\n# Will upload problems A and C\nrbx on A,C package boca -u\n</code></pre> <p>For that to work, you have to instruct rbx on how to connect to the BOCA server.</p> <p>rbx expects you to have set three environment variables. You can either set these variables in your shell, or in a <code>.env</code>/<code>.env.local</code> file in the root of your contest.</p> .env<pre><code>BOCA_BASE_URL=\"https://your.boca.com/boca\"\nBOCA_USERNAME=\"admin_username\"\nBOCA_PASSWORD=\"admin_password\"\n\n# Or, in case you provide a judge account instead of an admin account:\nBOCA_JUDGE_USERNAME=\"judge_username\"\nBOCA_JUDGE_PASSWORD=\"judge_password\"\n</code></pre> <p>Notice the configured user must correspond to an admin of your contest, so rbx will have permissions to upload the package. Also, make sure the correct contest is activated in the BOCA server before running the command.</p>"},{"location":"setters/packaging/boca/#troubleshooting","title":"Troubleshooting","text":""},{"location":"setters/packaging/boca/#upload-is-taking-too-long-or-an-error-is-being-reported","title":"Upload is taking too long, or an error is being reported","text":"<p>BOCA packages are uploaded to the server via HTTP. By default, BOCA servers (actually, PHP servers) are configured with a really tight limit for uploaded file sizes. If you are running into this issue, you can try to increase the limit by setting the <code>upload_max_filesize</code> and the <code>post_max_size</code> directives in your <code>php.ini</code> file.</p> <p>For BOCA installations done through the official Maratona Ubuntu PPA, you can find the configuration file in <code>/etc/php/8.1/fpm/php.ini</code>, and then restart the PHP service with <code>sudo service php8.1-fpm restart</code>.</p> <p>If you want to give a shot at fixing this with a bash script, try running:</p> <pre><code>sudo sed -i 's/upload_max_filesize = .*/upload_max_filesize = 200M/' /etc/php/8.1/fpm/php.ini\nsudo sed -i 's/post_max_size = .*/post_max_size = 200M/' /etc/php/8.1/fpm/php.ini\nsudo sed -i 's/memory_limit = .*/memory_limit = 256M/' /etc/php/8.1/fpm/php.ini\nsudo service php8.1-fpm restart\n</code></pre> <p>Danger</p> <p>These limits are there for a reason, and you should only change them if you know what you're doing. Allowing big post sizes can open the door for malicious users to take advantage of that.</p> <p>Try setting it to the smallest value you need to be able to upload your packages.</p> <p>Warning</p> <p>Another option, often easier but sometimes undesirable, is to make sure your packages are not too big. Big packages will usually pose a problem if you're trying to fix a package during the contest with a slow connection.</p>"},{"location":"setters/packaging/boca/#i-removed-a-problem-from-the-contest-but-it-still-appears-in-boca","title":"I removed a problem from the contest, but it still appears in BOCA","text":"<p>rbx does not remove problems from BOCA automatically, as this is a disruptive change. You will have to remove the problem manually from BOCA.</p> <p>Also notice that, when you rearrange problems in the contest (for instance, add a problem C, and move all problems after C one position ahead), rbx will override the old C problem with the new one.</p>"},{"location":"setters/packaging/boca/#im-seeing-a-different-verdict-in-boca-than-the-one-i-got-in-rbx","title":"I'm seeing a different verdict in BOCA than the one I got in rbx","text":"<p>It's expected that some verdicts are different in BOCA, especially because the sandboxes used by both platforms are not exactly the same.</p> <p>For instance, you can see runtime errors vs. memory limit exceeded, or differences like this.</p> <p>If you see a difference that you think is not justifiable, please let us know by opening an issue on our GitHub repository.</p>"},{"location":"setters/packaging/polygon/","title":"Packaging: Polygon","text":"<p>rbx provides a command to build packages for Polygon. The Polygon format supports two types of packages: problem packages and contest packages.</p>"},{"location":"setters/packaging/polygon/#problem-packages","title":"Problem packages","text":"<p>Problem packages are built by running the following command:</p> <pre><code>rbx package polygon\n</code></pre> <p>You can also specify the main language of the problem (in case you have multiple statements) using the <code>-l</code> or <code>--language</code> flag:</p> <pre><code>rbx package polygon -l en\n</code></pre> <p>Or, if you want to build a problem package for each problem in your contest:</p> <pre><code>rbx contest each package polygon\n</code></pre>"},{"location":"setters/packaging/polygon/#contest-packages","title":"Contest packages","text":"<p>There's also a contest-level command for building a contest package:</p> <pre><code>rbx contest package polygon\n</code></pre> <p>This command will build a single <code>.zip</code> file with all problems in the contest.</p>"},{"location":"setters/packaging/polygon/#uploading-to-codeforces-gym","title":"Uploading to Codeforces Gym","text":"<p>There are two totally different ways of uploading Polygon packages to Codeforces Gym.</p>"},{"location":"setters/packaging/polygon/#using-the-polygon-api","title":"Using the Polygon API","text":"<p>You can also upload your problem packages to Polygon, gather them into a Polygon contest, and import them in the Gym.</p> <p>This is a process that is a bit more complicated, and has a few limitations, but that usually gives you a better result. The pros of using this method are:</p> <ul> <li>You'll get a Polygon problem instance for each problem in your contest. This means you can access the problem in Polygon,   run some custom invocations, and even tune the time limit of each problem to Codeforces' machines.</li> <li>You can get HTML statements which render natively in Codeforces.</li> <li>Does not depend on the flaky Taskbook FTP.</li> </ul> <p>Follow the step-by-step guide below to get your contest up in the Gym.</p>"},{"location":"setters/packaging/polygon/#step-1-get-a-polygon-api-key","title":"Step 1: Get a Polygon API key","text":"<p>Log in to Polygon and go to the Settings page. In the API Keys section, create a new API key and save the generated pair.</p>"},{"location":"setters/packaging/polygon/#step-2-upload-all-your-problems-to-polygon-using-the-api","title":"Step 2: Upload all your problems to Polygon using the API","text":"<p>You can upload all problems to the contest by defining the environment variables below and running the rbx command:</p> <pre><code>export POLYGON_API_KEY=&lt;your-api-key&gt;\nexport POLYGON_API_SECRET=&lt;your-api-secret&gt;\nrbx contest each package polygon -u\n</code></pre> <p>You can also use the <code>--upload-as-english</code> flag to force the main statement to be uploaded as the English statement in Polygon, regardless of its actual language. This is useful because Codeforces uses a different -- not so good -- LaTeX renderer for statements in languages other than English. Thus, it's often useful to use the English renderer regardless of the actual statement language.</p> <pre><code>rbx contest each package polygon -u --upload-as-english\n</code></pre>"},{"location":"setters/packaging/polygon/#step-3-optional-tune-your-time-limits-and-statements-to-polygon","title":"Step 3: (Optional) Tune your time limits and statements to Polygon","text":"<p>This is the optional part that we highly recommend following. There are two components in Polygon that might not work right out of the box when you upload your problem, and it's worth checking them and tuning them if necessary.</p> <ol> <li> <p>Time limits: The time limits might not work well in the Polygon machines. We recommend you to    fire up a custom invocation in the Invocations section, and tune your time limit based on that    in the General info section.</p> </li> <li> <p>Statements: Polygon only supports rendering in HTML a subset of LaTeX commands. You might have to do some manual adjustments if you really want HTML statements in your contest. With some trial and error, it is easy to get a sense of which commands work and which don't.</p> </li> </ol>"},{"location":"setters/packaging/polygon/#step-4-create-a-new-polygon-contest-with-all-the-problems","title":"Step 4: Create a new Polygon contest with all the problems","text":"<p>Now that you have all your problems in Polygon, you can create a new contest and import all problems into it.</p> <p>Click New contest in the top-right corner, and fill in the form. Then, enter the contest and add all problems you uploaded to it. Finally, click Manage problem access and give <code>read</code> access to <code>codeforces</code> to all problems, and to the contest itself.</p> <p>After that, click Build standard packages to ensure the packages for all problems are built.</p>"},{"location":"setters/packaging/polygon/#step-5-create-a-contest-in-the-gym-and-import-the-polygon-contest","title":"Step 5: Create a contest in the Gym and import the Polygon contest","text":"<p>Enable coach mode, create a new contest and hit the Add problems from contest link.</p> <p></p> <p>In the following page, paste the contest UID in Polygon, and click the button. You can obtain the contest UID like in the picture below:</p> <p></p>"},{"location":"setters/packaging/polygon/#iterating-on-the-polygon-problem","title":"Iterating on the Polygon problem","text":"<p>You can always follow step (2) again in to update the problem in Polygon after doing modifications to it. Sometimes, though, this process is too slow, and you might want to use faster methods.</p>"},{"location":"setters/packaging/polygon/#partial-uploads","title":"Partial Uploads","text":"<p>If you want to upload only specific parts of the problem (e.g. only statements, or only source files), you can use the <code>--upload-only</code> flag. Conversely, if you want to skip certain parts, you can use <code>--upload-skip</code> (or <code>--dont-upload</code> internally, but exposed as skip).</p> <p>Supported values are: <code>statements</code>, <code>solutions</code>, <code>tests</code>, <code>files</code>.</p> <pre><code># Upload only statements and files (checker/interactor/validator/headers)\nrbx contest each package polygon -u --upload-only statements --upload-only files\n\n# Upload everything EXCEPT tests\nrbx contest each package polygon -u --upload-skip tests\n</code></pre> <p>Feel free to keep those variables in your <code>.bashrc</code> (or equivalent in other shells) file if you want.</p> <p>This will create a Polygon problem for each problem in your contest following the pattern <code>&lt;contest-name&gt;-&lt;problem-shortname&gt;-&lt;problem-name&gt;</code> (example: <code>my-contest-a-my-problem</code> for a contest named <code>my-contest</code> with a problem named <code>my-problem</code> which has the letter <code>A</code>).</p> <p>This problem will contain the validator, checker, interactor, and any other files you added to the problem. The time and memory limits will also be synced with Polygon, but often it's a good idea to tune them manually in the Polygon interface.</p> <p>The statement blocks will also be uploaded to Polygon, along with all model solutions. Solutions that are no longer present in the package will be removed from Polygon (marked as deleted).</p> <p>Testcases are also uploaded. If your package uses generators, the generators are uploaded and the script is updated in Polygon to generate the tests. Manual tests (without generators) are uploaded as files.</p>"},{"location":"setters/packaging/polygon/#using-the-taskbook-ftp-flaky","title":"Using the Taskbook FTP (flaky)","text":"<p>You can upload a contest package to Codeforces Gym by first building it with the command above, and then using the Codeforces Taskbook FTP (taskbook.codeforces.com) to upload your zip file to your contest.</p> <p>You can read more about the Taskbook by enabling coach mode, creating a new contest in the Gym, and looking at the \"Coach mode on\" section on the right side of the contest page. It will look like the image below:</p> <p></p> <p>Follow the instructions to upload your contest ZIP.</p> <p>Note</p> <p>By uploading through the Taskbook, you'll only get PDF statements. That is not a limitation of rbx, but rather the way Codeforces Gym and Taskbook work (probably for safety reasons as otherwise people could inject arbitrary HTML code into Codeforces).</p> <p>If you prefer HTML statements, you can use the option above.</p> <p>Danger</p> <p>Quite often the Taskbook FTP will be down. It seems this endpoint is not very reliable anymore. Refer to the option below, which is a bit more complicated but more reliable.</p>"},{"location":"setters/packaging/polygon/#caveats","title":"Caveats","text":"<p>Warning</p> <p>The caveats in this section are probably the main reason you should consider using Polygon directly if your main goal is to hold a Gym contest.</p> <p>The Polygon API has a few limitations. The main two, which have huge implications on how rbx uploads your problems, are:</p> <ul> <li>The API doesn't allow you to remove solutions from a problem;</li> <li>The API doesn't allow you to remove manual tests from a problem.</li> </ul> <p>This means that, whenever you remove a few manual tests from a problem, or a solution, and re-upload, you have to manually get rid of them. rbx will successfully replace every test index that still exists, and also the solutions that exist, but it won't do anything to remove old ones.</p> <p>Instead, rbx will just mark the removed solutions as deleted and ensure they're not run, but they'll still show in Polygon.</p> <p>Also notice that whenever you tune your time limits or statements in Polygon and re-issue an upload, those modifications you did will be overridden. You have to be extra careful with that. Preferrably, you should replicate all your statement changes in rbx before uploading to Polygon.</p>"},{"location":"setters/presets/","title":"Presets","text":"<p>Note</p> <p>This documentation is mainly targeted at head setters trying to create a contest from scratch.</p> <p>If you're just a setter that wants to contribute to an already existing contest, you can probably just clone the repository the head setters shared with you and skip this documentation altogether.</p> <p>Presets is a feature that allows head setters to create a contest template that can be reused across multiple contests.</p> <p>A preset consists of four different pieces:</p> <ul> <li>A contest template: simply, a contest folder with some sensible defaults set that will   be used to bootstrap a contest based on this preset</li> <li>A problem template: a problem folder with some sensible defaults set that will   be used to bootstrap each problem based on this preset</li> <li>An environment: a configuration file that will be inherited by contests and problems   created from this preset, and that rbx will use to configure its execution environment</li> <li>A preset definition: a <code>preset.rbx.yml</code> file that will be used to define the preset   and its dependencies.</li> </ul>"},{"location":"setters/presets/#why-a-preset","title":"Why a preset?","text":"<p>Presets strongly encourage code reuse across different contests. Besides that, it provides a way to standardize the contest environment across different contests, making it easier for setters to focus on creating the contest instead of configuring the environment.</p> <p>Also, it makes it easier for setters to create new problems in a contest, offering a way for the head setter to define a starting point for the problem.</p> <p>Also, if the head setter wants to change the preset at some point, presets offer a way to synchronize the changes across all the problems and contests that use the preset.</p>"},{"location":"setters/presets/#creating-a-preset","title":"Creating a preset","text":"<p>Creating a preset is a multi-step process that starts when the head setter runs the <code>rbx preset create</code> command. By default, the command will create a new preset based on rbx default preset.</p> <pre><code>rbx presets create\n</code></pre> <p>The command will prompt you for the name of the preset, and a GitHub repository URI that can be used to reference to it.</p> <pre><code>\u2514\u2500\u2500 your-preset-name\n    \u251c\u2500\u2500 contest # (1)!\n    \u251c\u2500\u2500 problem # (2)!\n    \u251c\u2500\u2500 env.rbx.yml # (3)!\n    \u2514\u2500\u2500 preset.rbx.yml # (4)!\n</code></pre> <ol> <li>The contest template. This folder will be used to bootstrap each contest created from    this preset.</li> <li>A problem template. This folder will be used to bootstrap each problem created from    this preset.</li> <li>An environment file. This file will be used to configure the execution environment    of rbx to be used in the contest.</li> <li>A preset definition. This file will be used to define the preset and its dependencies.</li> </ol> <p>The GitHub URI will be an unique identifier of your preset, and can be used by other rbx users to fetch your preset from there if you decide to share it publicly.</p> <p>You can start from a preset of your own by specifying the <code>-p</code> flag.</p> <p>Tip</p> <p>If you want to start from a preset of your own, you can do so by specifying the <code>-p</code> flag.</p> <pre><code>rbx presets create -p your-base-preset\n</code></pre>"},{"location":"setters/presets/#setting-up-the-problem-template","title":"Setting up the problem template","text":"<p>You can go to the problem template and modify it to your liking: package structure, the <code>problem.rbx.yml</code> file, default testlib components, statement templates, etc. Everything can be customized to fulfill your requirements.</p> <p>Every problem created from this preset will be a clone of this folder, except for the folder name and the <code>name</code> field of the <code>problem.rbx.yml</code> file, which will be changed to match your problem name.</p> <p>Tip</p> <p>You can run rbx commands freely inside the problem template folder to test your template: any rbx internal folders will be ignored when inheriting from the preset.</p>"},{"location":"setters/presets/#setting-up-the-contest-template","title":"Setting up the contest template","text":"<p>You can go to the contest template and modify it to your liking: statement templates, <code>contest.rbx.yml</code> file, etc. Everything can be customized to fulfill your requirements.</p> <p>Usually, the contest template should have no problems initially. One should add problems with <code>rbx contest add</code> after the contest has been created.</p> <p>Every contest created from this preset will be a clone of this folder, except for the folder name and the <code>name</code> field of the <code>contest.rbx.yml</code> file, which will be changed to match your contest name.</p> <p>Tip</p> <p>You can run rbx commands freely inside the contest template folder to test your template: any rbx internal folders will be ignored when inheriting from the preset.</p>"},{"location":"setters/presets/#setting-up-the-environment","title":"Setting up the environment","text":"<p>The environment file will be used to configure the execution environment of rbx to be used in the contest.</p> <p>This file is rather complex, and its full reference documentation can be found here.</p> <p>You can usually get away with the environment used by the <code>default</code> preset, which is a good starting point for most contests. You can check its code here.</p>"},{"location":"setters/presets/#setting-up-the-preset-definition","title":"Setting up the preset definition","text":"<p>The preset definition file is a <code>preset.rbx.yml</code> file that will be used to define the preset and its dependencies.</p> <p>It can usually be broken down into a few sections, documented below for the default preset:</p> preset.rbx.yml<pre><code># The name of the preset.\nname: \"default\"\n\n# The URI of the preset. Usually, refers to a GitHub repository.\n# Here, refers to the \"rbx/resources/presets/default\" folder inside\n# the \"rsalesc/rbx\" repository.\nuri: \"rsalesc/rbx/rbx/resources/presets/default\"\n\n# The template to use for creating problems from this preset.\n# Refers to the `problem` folder in the preset definition.\nproblem: \"problem\"\n\n# The template to use for creating contests from this preset.\n# Refers to the `contest` folder in the preset definition.\ncontest: \"contest\"\n\n# The environment to use for the contest and problems created from this preset.\nenv: \"env.rbx.yml\"\n\n# Assets to be tracked and synced with the preset.\ntracking:\n  problem:\n    - path: \".gitignore\"\n    - path: \"statement/icpc.sty\"\n    - path: \"statement/template.rbx.tex\"\n  contest:\n    - path: \".gitignore\"\n    - path: \"statement/icpc.sty\"\n    - path: \"statement/template.rbx.tex\"\n    - path: \"statement/contest.rbx.tex\"\n      symlink: true\n</code></pre> <p>The first few sections are pretty self-explanatory. Let's focus on the <code>tracking</code> section.</p> <p>The <code>tracking</code> section describes a set of files that should be tracked by rbx when a problem or contest is created from this preset.</p> <p>If a file is tracked, it means that -- in theory -- it should be automatically synced with the preset. Let's say you have a <code>.tex</code> file that is imported by all the problems in your contest. Let's say your contest has 10 problems, but just now you realized you have to modify this <code>.tex</code> file to fix a typo.</p> <p>Usually, this would mean you have to repeat the same change in all 10 problems. With presets, you can just modify the <code>.tex</code> file in the preset definition, and run <code>rbx presets sync</code> inside your contest folder, as long as the file is tracked.</p> <p>This will sync all packages that use this preset with its newest changes, based on the set of tracked files. Files that are not tracked will not be synced.</p> <p>Tracked files can be specified both explicitly, or through Python-compliant glob patterns: <code>*.png</code>, <code>**/*.tex</code>, etc.</p>"},{"location":"setters/presets/#symlink-tracking","title":"Symlink tracking","text":""},{"location":"setters/presets/#flag-based-symlink-tracking","title":"Flag-based symlink tracking","text":"<p>When you know for sure that a file should always be kept in sync (without manual intervention), you can also create them as symlinks. Just mark the tracked file with the <code>symlink: true</code> flag, and rbx will create a symlink to the file in the package instead of copying it. Then, every modification you do to it will be instantly reflected in all other packages that use the preset.</p>"},{"location":"setters/presets/#soft-symlink-tracking","title":"Soft symlink tracking","text":"<p>An alternative way to create symlinks is to track files that are symlinks themselves. Let's suppose you have the following structure:</p> <pre><code>contest/\n\u251c\u2500\u2500 statement/\n\u2502   \u2514\u2500\u2500 icpc.sty -&gt; ../../common_icpc.sty\nproblem/\n\u2514\u2500\u2500 statement/\n    \u2514\u2500\u2500 icpc.sty -&gt; ../../common_icpc.sty\n\u2514\u2500\u2500 common_icpc.sty\n</code></pre> <p>In this case, you can track both <code>contest/statement/icpc.sty</code> and <code>problem/statement/icpc.sty</code> (no need for the <code>symlink: true</code> flag), and rbx will make sure to create a symlink to <code>common_icpc.sty</code> automagically for you.</p> <p>This approach is particularly useful when you want to share a common file between the contest and the problem packages.</p>"},{"location":"setters/presets/#using-a-preset","title":"Using a preset","text":"<p>Presets can be used both when creating a contest or when creating a problem. Below we detail all the commands where it can be used.</p> <pre><code># Create a contest from a preset.\nrbx contest create -p your-preset\n\n# Initialize a contest (in the current directory) from a preset.\nrbx contest init -p your-preset\n\n# Add a problem to a contest (that already has its own preset), using the very same preset.\nrbx contest add\n\n# Create a standalone problem from a preset.\nrbx create -p your-preset\n</code></pre> <p>In all variants above, a <code>.local.rbx</code> folder will be created at the root of the package. This folder stores a copy of the preset, snapshotted at the moment the package was created. This way, your package has its own copy of the preset, and you can either</p> <ol> <li>Modify it at will, and those changes will not be reflected in the original preset;</li> <li>Sync it to the original preset whenever you want.</li> </ol> <p>If you modify your <code>.local.rbx</code> folder, but has already created some problems inside your contest that you want to sync with the preset, you can do so by running <code>rbx presets sync</code> inside your contest folder.</p> <p>This will sync all packages that use this preset with its newest changes. In other words, it will create missing symlinks, and ask you if normal tracked files should be overridden or not.</p>"},{"location":"setters/presets/#sharing-a-preset-publicly","title":"Sharing a preset publicly","text":"<p>You can share your preset publicly by uploading it to a GitHub repository. If your repository is <code>&lt;your-organization&gt;/&lt;your-preset-name&gt;</code>, other uses can create a package from it by using</p> <pre><code>rbx contest create -p &lt;your-organization&gt;/&lt;your-preset-name&gt;\n</code></pre> <p>The preset will be cloned automatically, and then used as normal.</p>"},{"location":"setters/presets/#sharing-a-preset-privately","title":"Sharing a preset privately","text":"<p>You can share your preset privately, either through Git repositories or through other means. To initialize a contest from a private preset, you can do the following:</p> <pre><code>mkdir my-new-contest\ncd my-new-contest\n\n# Clone the preset into .local.rbx\ngit clone https://github.com/my-organization/my-preset .local.rbx\n\n# Initialize the contest\nrbx contest init\n</code></pre> <p>This will initialize the contest from the <code>.local.rbx</code> preset, which you can initialize from a private data source of your own.</p>"},{"location":"setters/profiling/","title":"Profiling","text":"<p>In rbx, profiling is the process of measuring the execution time of solutions and coming up with time limits for the problem. Time limits are stored in limits profiles, which can be created and managed through the CLI or the TUI.</p>"},{"location":"setters/profiling/#why-profile","title":"Why profile?","text":"<p>Different judge systems (BOCA, Polygon, etc.) may run on different hardware with different performance characteristics. A time limit that works well on your local machine may be too tight or too generous on the actual judge. By creating separate profiles for each target system, you can fine-tune limits independently.</p> <p>Even if you only target a single judge, profiling automates the tedious process of choosing a time limit that is generous enough for intended solutions but tight enough to reject slow ones.</p>"},{"location":"setters/profiling/#quick-start","title":"Quick start","text":"<pre><code># Estimate a time limit using the default formula (interactive)\nrbx time\n\n# Estimate automatically (no prompts)\nrbx time --auto\n\n# Create a profile for BOCA packaging\nrbx time -p boca\n\n# Write the estimated limits back into problem.rbx.yml\nrbx time --integrate\n</code></pre>"},{"location":"setters/profiling/#the-rbx-time-command","title":"The <code>rbx time</code> command","text":"<p>The <code>rbx time</code> command (alias: <code>rbx t</code>) estimates a time limit for the problem by running all accepted solutions and applying a formula to their timings.</p>"},{"location":"setters/profiling/#how-it-works","title":"How it works","text":"<ol> <li>Displays current profile -- If a profile already exists for the given name, its current limits are shown.</li> <li>Strategy selection -- You are prompted to choose how to define the time limit (unless <code>--auto</code> or <code>--strategy</code> is used).</li> <li>Solution execution -- For formula-based strategies, all accepted solutions are run against all testcases with no time limit enforced, so that the true execution times can be measured.</li> <li>Time report -- The fastest and slowest solution times are shown, along with per-language breakdowns if solutions in multiple languages exist.</li> <li>Formula evaluation -- The formula is applied to compute the estimated time limit.</li> <li>Per-language limits -- If solutions exist in multiple languages and their estimated limits differ, you are prompted to select which languages should have language-specific time limits.</li> <li>Profile persistence -- The result is written to <code>.limits/&lt;profile&gt;.yml</code>.</li> </ol>"},{"location":"setters/profiling/#strategies","title":"Strategies","text":"<p>When you run <code>rbx time</code>, you are prompted to choose a strategy:</p> Strategy Description Estimate (recommended) Runs all accepted solutions and applies the default formula to estimate the time limit. Inherit from package Creates a profile that inherits all limits directly from <code>problem.rbx.yml</code>. Estimate with custom formula Same as Estimate, but prompts you for a custom formula. Custom time limit Prompts you for an explicit time limit in milliseconds. <p>You can skip the interactive prompt by using <code>--strategy</code> or <code>--auto</code>:</p> <pre><code># Use the default formula without prompts\nrbx time --auto\n\n# Directly select a strategy\nrbx time --strategy=estimate\nrbx time --strategy=inherit\nrbx time --strategy=custom\nrbx time --strategy=estimate_custom\n</code></pre>"},{"location":"setters/profiling/#flags","title":"Flags","text":"Flag Short Default Description <code>--profile</code> <code>-p</code> <code>local</code> Name of the profile to create or update. <code>--auto</code> <code>-a</code> <code>false</code> Automatically estimate using the default formula (no prompts). <code>--strategy</code> <code>-s</code> (interactive) Strategy to use: <code>estimate</code>, <code>inherit</code>, <code>estimate_custom</code>, or <code>custom</code>. <code>--integrate</code> <code>-i</code> <code>false</code> Write the profile's limits back into <code>problem.rbx.yml</code> (see Integrating profiles). <code>--runs</code> <code>-r</code> <code>0</code> Number of runs per solution. <code>0</code> uses the environment default. <code>--detailed</code> <code>-d</code> <code>false</code> Print a detailed table view of per-testcase results. <code>--check</code> <code>true</code> Build outputs and run checker during estimation. <code>--validate</code> <code>true</code> Validate inputs and outputs during estimation."},{"location":"setters/profiling/#multiple-runs","title":"Multiple runs","text":"<p>By default, each solution is run once per testcase. If you want more stable timing measurements (e.g., to reduce variance from system load), use <code>--runs</code> to run each solution multiple times:</p> <pre><code>rbx time --runs=3\n</code></pre> <p>The maximum time across all runs for each testcase is used as the timing for that testcase.</p>"},{"location":"setters/profiling/#time-limit-formulas","title":"Time limit formulas","text":"<p>Formula-based estimation is the recommended approach. A formula is a mathematical expression that takes the timing data from accepted solutions and produces a time limit.</p>"},{"location":"setters/profiling/#default-formula","title":"Default formula","text":"<p>The default formula is:</p> <pre><code>step_up(max(fastest * 3, slowest * 1.5), 100)\n</code></pre> <p>This means: take the maximum of 3x the fastest solution time and 1.5x the slowest solution time, then round up to the nearest multiple of 100 ms.</p>"},{"location":"setters/profiling/#variables","title":"Variables","text":"Variable Description <code>fastest</code> Maximum time (in ms) of the fastest accepted solution across all testcases. <code>slowest</code> Maximum time (in ms) of the slowest accepted solution across all testcases. <p>Note</p> <p><code>fastest</code> and <code>slowest</code> refer to the maximum time across testcases for the fastest/slowest solution, not the fastest/slowest individual testcase. In other words, <code>fastest</code> is the worst-case time of the best solution.</p>"},{"location":"setters/profiling/#functions","title":"Functions","text":"Function Description <code>step_up(value, step)</code> Round <code>value</code> up to the nearest multiple of <code>step</code>. E.g., <code>step_up(250, 100)</code> = <code>300</code>. <code>step_down(value, step)</code> Round <code>value</code> down to the nearest multiple of <code>step</code>. E.g., <code>step_down(250, 100)</code> = <code>200</code>. <code>step_closest(value, step)</code> Round <code>value</code> to the closest multiple of <code>step</code>. <code>max(a, b)</code> Maximum of two values. <code>min(a, b)</code> Minimum of two values. <code>int(x)</code> Convert to integer. <code>float(x)</code> Convert to float. <code>ceil(x)</code> Ceiling function. <code>floor(x)</code> Floor function. <code>abs(x)</code> Absolute value. <p>Standard math operators are also available: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>**</code>, <code>%</code>.</p>"},{"location":"setters/profiling/#providing-a-custom-formula","title":"Providing a custom formula","text":"<p>You can provide a custom formula in three ways:</p> CLI flagEnvironment file <pre><code>rbx time --strategy=estimate_custom\n# You will be prompted to enter the formula interactively\n</code></pre> <p>Set the default formula in your <code>env.rbx.yml</code>:</p> <pre><code>timing:\n  formula: \"step_up(max(fastest * 2, slowest * 1.5), 100)\"\n</code></pre> <p>Read more in the Environment reference.</p>"},{"location":"setters/profiling/#formula-examples","title":"Formula examples","text":"<pre><code># Conservative: 2x fastest, 1.5x slowest, round to 500ms\nstep_up(max(fastest * 2, slowest * 1.5), 500)\n\n# Tight: 1.5x slowest, round to 100ms\nstep_up(slowest * 1.5, 100)\n\n# Fixed multiplier on fastest\nstep_up(fastest * 4, 100)\n</code></pre>"},{"location":"setters/profiling/#limits-profiles","title":"Limits profiles","text":"<p>Profiles are the mechanism rbx uses to store and manage time/memory limits independently of the problem package itself. Each profile is a YAML file stored in the <code>.limits/</code> directory of your problem.</p>"},{"location":"setters/profiling/#file-structure","title":"File structure","text":"<pre><code>my-problem/\n\u251c\u2500\u2500 problem.rbx.yml\n\u251c\u2500\u2500 .limits/\n\u2502   \u251c\u2500\u2500 local.yml        # Default profile\n\u2502   \u251c\u2500\u2500 boca.yml         # Profile for BOCA packaging\n\u2502   \u2514\u2500\u2500 polygon.yml      # Profile for Polygon packaging\n</code></pre>"},{"location":"setters/profiling/#profile-schema","title":"Profile schema","text":"<p>A profile file follows the <code>LimitsProfile</code> schema:</p> <pre><code># .limits/local.yml\n\n# Inherit all limits from problem.rbx.yml instead of specifying them here.\n# When true, the fields below are ignored.\ninheritFromPackage: false\n\n# Global limits\ntimeLimit: 2000       # Time limit in milliseconds\nmemoryLimit: 256      # Memory limit in MB\noutputLimit: 65536    # Output limit in KB\n\n# Per-language overrides\nmodifiers:\n  py:\n    time: 6000        # Python gets a higher time limit (ms)\n  java:\n    timeMultiplier: 2.0  # Java gets 2x the base time limit\n\n# The formula that was used to estimate the time limit (informational)\nformula: \"step_up(max(fastest * 3, slowest * 1.5), 100)\"\n</code></pre>"},{"location":"setters/profiling/#per-language-modifiers","title":"Per-language modifiers","text":"<p>The <code>modifiers</code> section allows you to override limits for specific languages. This is useful when your problem accepts solutions in multiple languages with very different performance characteristics.</p> Field Description <code>time</code> Override the time limit for this language (in ms). Replaces the global <code>timeLimit</code>. <code>timeMultiplier</code> Multiply the effective time limit by this factor. Applied after <code>time</code> if both are set. <code>memory</code> Override the memory limit for this language (in MB). <p>The effective time limit for a language is computed as:</p> <ol> <li>Start with the global <code>timeLimit</code>.</li> <li>If the language has a <code>time</code> modifier, use that instead.</li> <li>If the language has a <code>timeMultiplier</code>, multiply the result by it.</li> </ol> <p>Tip</p> <p>When <code>rbx time</code> detects that your accepted solutions are written in multiple languages with different performance characteristics, it will prompt you to set per-language time limits automatically.</p>"},{"location":"setters/profiling/#the-local-profile","title":"The <code>local</code> profile","text":"<p>By default, <code>rbx time</code> writes to a profile named <code>local</code>. This profile is used when you run solutions with <code>rbx run</code> without specifying a profile.</p>"},{"location":"setters/profiling/#using-profiles-when-running-solutions","title":"Using profiles when running solutions","text":"<p>You can tell rbx to use a specific limits profile when running solutions with the global <code>--profile</code> flag:</p> <pre><code>rbx --profile=boca run\nrbx -p polygon run\n</code></pre> <p>This applies the limits from the specified profile instead of the package defaults.</p>"},{"location":"setters/profiling/#profiles-and-packaging","title":"Profiles and packaging","text":"<p>When you package a problem, rbx automatically uses the profile that matches the packager name. For example, the BOCA packager looks for a profile named <code>boca</code>:</p> <pre><code># First, create the boca profile\nrbx time -p boca\n\n# Then package for BOCA\nrbx package boca\n</code></pre> <p>Warning</p> <p>The BOCA packager requires a profile named <code>boca</code> to exist. If it doesn't, the packager will fail and ask you to run <code>rbx time -p boca</code> first.</p>"},{"location":"setters/profiling/#inheriting-from-the-package","title":"Inheriting from the package","text":"<p>If you want a profile to simply mirror the limits defined in <code>problem.rbx.yml</code>, you can create an inheriting profile:</p> <pre><code>rbx time --strategy=inherit -p polygon\n</code></pre> <p>This creates a <code>.limits/polygon.yml</code> with <code>inheritFromPackage: true</code>. The profile will always reflect whatever limits are set in <code>problem.rbx.yml</code>.</p>"},{"location":"setters/profiling/#integrating-profiles-into-the-package","title":"Integrating profiles into the package","text":"<p>If you've estimated limits in a profile and want to write them back into <code>problem.rbx.yml</code> (for example, to make them the new defaults), use the <code>--integrate</code> flag:</p> <pre><code>rbx time --integrate -p local\n</code></pre> <p>This copies <code>timeLimit</code>, <code>memoryLimit</code>, <code>outputLimit</code>, and any <code>modifiers</code> from the profile into your <code>problem.rbx.yml</code>. It is useful when you've fine-tuned limits in a profile and want to persist them as the package defaults.</p>"},{"location":"setters/profiling/#editing-profiles-in-the-tui","title":"Editing profiles in the TUI","text":"<p>You can also create and edit limits profiles visually using the rbx TUI:</p> <pre><code>rbx ui\n</code></pre> <p>Select \"Edit limits profiles\" from the main menu to open the limits editor. The editor provides:</p> <ul> <li>Profile sidebar -- Browse and select from all existing profiles in <code>.limits/</code>.</li> <li>Create new profile -- Type a name and press Enter to create a new profile.</li> <li>Inherit toggle -- Switch between inheriting from the package or setting custom limits.</li> <li>Global limits -- Edit <code>timeLimit</code> and <code>memoryLimit</code> directly.</li> <li>Per-language modifiers -- Add or edit <code>time</code>, <code>timeMultiplier</code>, and <code>memory</code> overrides for specific languages.</li> <li>Save (Ctrl+S) -- Write changes to disk.</li> <li>Delete (d twice) -- Delete the selected profile.</li> </ul> <p>Tip</p> <p>The TUI is especially handy for quickly tweaking per-language modifiers after an initial <code>rbx time</code> estimation.</p>"},{"location":"setters/profiling/#manually-editing-profiles","title":"Manually editing profiles","text":"<p>Since profiles are plain YAML files in the <code>.limits/</code> directory, you can also edit them directly with any text editor. The schema is available at <code>LimitsProfile</code>.</p> <p>You can add the following YAML language server directive at the top of your profile file for editor autocompletion and validation:</p> <pre><code># yaml-language-server: $schema=https://rsalesc.github.io/rbx/schemas/LimitsProfile.json\n</code></pre>"},{"location":"setters/profiling/#environment-variable-override","title":"Environment variable override","text":"<p>You can globally scale all time limits by setting the <code>RBX_TIME_MULTIPLIER</code> environment variable:</p> <pre><code>RBX_TIME_MULTIPLIER=1.5 rbx run\n</code></pre> <p>This multiplies all effective time limits by the given factor, which can be useful for running on slower hardware without changing any profile.</p>"},{"location":"setters/reference/cli/","title":"rbx","text":"<p>The <code>rbx</code> CLI is the main entry point for all operations. It provides a set of commands to manage problems, contests, and the environment.</p> <p>Usage: <pre><code>rbx [OPTIONS]\n</code></pre></p> Name Type Description Default <code>-c</code>, <code>--cache</code> CacheLevel Which degree of caching to use. <code>CACHE_ALL</code> <code>--sanitized</code>, <code>-s</code> BOOLEAN Whether to compile and run testlib components with sanitizers enabled. If you want to run the solutions with sanitizers enabled, use the \"-s\" flag in the corresponding run command. <code>False</code> <code>--nocapture</code> BOOLEAN Whether to save extra logs and outputs from interactive solutions. <code>True</code> <code>-p</code>, <code>--profile</code> TEXT Which timing profile to use when running solutions. - <code>--profiling</code> BOOLEAN Whether to profile (capture performance statistics) of the execution. <code>False</code> <code>--version</code>, <code>-v</code> BOOLEAN - <code>False</code>"},{"location":"setters/reference/cli/#ui","title":"ui","text":"<p>Show an UI for exploring testcases of the current problem.</p> <p>Usage: <pre><code>rbx ui [OPTIONS]\n</code></pre></p>"},{"location":"setters/reference/cli/#on","title":"on","text":"<p>Run a command in the context of a problem (or a set of problems) of a contest.</p> <p>Usage: <pre><code>rbx on &lt;PROBLEMS&gt; [OPTIONS]\n</code></pre></p> <p>Arguments:</p> Name Description Required <code>PROBLEMS</code> - Yes"},{"location":"setters/reference/cli/#each","title":"each","text":"<p>Run a command for each problem in the contest.</p> <p>Usage: <pre><code>rbx each [OPTIONS]\n</code></pre></p>"},{"location":"setters/reference/cli/#edit-e","title":"edit (e)","text":"<p>Open problem.rbx.yml in your default editor.</p> <p>Usage: <pre><code>rbx edit [OPTIONS]\n</code></pre></p>"},{"location":"setters/reference/cli/#build-b","title":"build (b)","text":"<p>Builds the problem package.</p> <p>This command compiles all generators, validators, and checkers. Then it generates inputs using the generator script and validates them with the validator. Finally, it generates the outputs using the main solution.</p> <p>It is recommended to run this command before packaging the problem to ensure everything is up-to-date.</p> <p>Usage: <pre><code>rbx build [OPTIONS]\n</code></pre></p> Name Type Description Default <code>--verification-level</code>, <code>--verification</code>, <code>-v</code> INTEGER of VerificationLevel Verification level to use when building package. <code>4</code> <code>--validate</code> BOOLEAN Whether to validate outputs for tests. <code>True</code> <code>--visualize</code> BOOLEAN Whether to build visualizations for inputs/outputs of tests. <code>False</code>"},{"location":"setters/reference/cli/#run-r","title":"run (r)","text":"<p>Runs solutions against the testcases.</p> <p>This is the primary way to test your solutions. You can run all solutions, a specific set of solutions, or only accepted solutions.</p> <p>You can also filter which testcases to run against, by using the <code>--outcome</code> flag to only confirm that solutions match a certain expected outcome (e.g. TLE, WA).</p> <p>Usage: <pre><code>rbx run &lt;SOLUTIONS&gt; [OPTIONS]\n</code></pre></p> <p>Arguments:</p> Name Description Required <code>SOLUTIONS</code> Path to solutions to run. If not specified, will run all solutions. No Name Type Description Default <code>--verification-level</code>, <code>--verification</code>, <code>-v</code> INTEGER of VerificationLevel Verification level to use when building package. <code>4</code> <code>--outcome</code>, <code>-o</code> TEXT Include only solutions whose expected outcomes intersect with this. - <code>--tag</code>, <code>-t</code> TEXT Include only solutions whose tags intersect with this. - <code>--check</code> BOOLEAN Whether to not build outputs for tests and run checker. <code>True</code> <code>--validate</code> BOOLEAN Whether to not validate outputs for tests. <code>True</code> <code>--detailed</code>, <code>-d</code> BOOLEAN Whether to print a detailed view of the tests using tables. <code>False</code> <code>--sanitized</code>, <code>-s</code> BOOLEAN Whether to compile the solutions with sanitizers enabled. <code>False</code> <code>--choice</code>, <code>--choose</code>, <code>-c</code> BOOLEAN Whether to pick solutions interactively. <code>False</code>"},{"location":"setters/reference/cli/#summary-sum","title":"summary (sum)","text":"<p>Print a summary of the problem.</p> <p>Usage: <pre><code>rbx summary [OPTIONS]\n</code></pre></p> Name Type Description Default <code>--detailed</code>, <code>-d</code> BOOLEAN Whether to print a detailed view of the tests using tables. <code>False</code>"},{"location":"setters/reference/cli/#time-t","title":"time (t)","text":"<p>Estimate a time limit for the problem based on a time limit formula and timings of accepted solutions.</p> <p>Usage: <pre><code>rbx time [OPTIONS]\n</code></pre></p> Name Type Description Default <code>--check</code> BOOLEAN Whether to not build outputs for tests and run checker. <code>True</code> <code>--validate</code> BOOLEAN Whether to not validate outputs for tests. <code>True</code> <code>--detailed</code>, <code>-d</code> BOOLEAN Whether to print a detailed view of the tests using tables. <code>False</code> <code>--strategy</code>, <code>-s</code> TEXT Strategy to use for time limit estimation (estimate, inherit). - <code>--auto</code>, <code>-a</code> BOOLEAN Whether to automatically estimate the time limit. <code>False</code> <code>--runs</code>, <code>-r</code> INTEGER Number of runs to perform for each solution. Zero means the config default. <code>0</code> <code>--profile</code>, <code>-p</code> TEXT Profile to use for time limit estimation. <code>local</code> <code>--integrate</code>, <code>-i</code> BOOLEAN Integrate the given limits profile into the package. <code>False</code>"},{"location":"setters/reference/cli/#irun-ir","title":"irun (ir)","text":"<p>Build and run solution(s) by passing testcases in the CLI.</p> <p>Usage: <pre><code>rbx irun &lt;SOLUTIONS&gt; [OPTIONS]\n</code></pre></p> <p>Arguments:</p> Name Description Required <code>SOLUTIONS</code> Path to solutions to run. If not specified, will run all solutions. No Name Type Description Default <code>--verification-level</code>, <code>--verification</code>, <code>-v</code> INTEGER of VerificationLevel Verification level to use when building package. <code>4</code> <code>--outcome</code>, <code>-o</code> TEXT Include only solutions whose expected outcomes intersect with this. - <code>--tag</code>, <code>-t</code> TEXT Include only solutions whose tags intersect with this. - <code>--check</code> BOOLEAN Whether to not build outputs for tests and run checker. <code>True</code> <code>--validate</code> BOOLEAN Whether to validate inputs. <code>True</code> <code>--generator</code>, <code>-g</code> TEXT Generator call to use to generate a single test for execution. - <code>--testcase</code>, <code>--test</code>, <code>-tc</code>, <code>-t</code> TEXT Testcase to run, in the format \"[group]/[index]\". If not specified, will run interactively. - <code>--output</code>, <code>-O</code> BOOLEAN Whether to ask user for custom output. <code>False</code> <code>--visualize</code> BOOLEAN Whether to generate visualizations for inputs and outputs. <code>False</code> <code>--print</code>, <code>-p</code> BOOLEAN Whether to print outputs to terminal. <code>False</code> <code>--sanitized</code>, <code>-s</code> BOOLEAN Whether to compile the solutions with sanitizers enabled. <code>False</code> <code>--choice</code>, <code>--choose</code>, <code>-c</code> BOOLEAN Whether to pick solutions interactively. <code>False</code>"},{"location":"setters/reference/cli/#create-c","title":"create (c)","text":"<p>Create a new problem package.</p> <p>Usage: <pre><code>rbx create [OPTIONS]\n</code></pre></p> Name Type Description Default <code>--name</code> TEXT Name of the problem to create, which will be used as the name of the new folder. - <code>--preset</code> TEXT Preset to use when creating the problem. -"},{"location":"setters/reference/cli/#stress","title":"stress","text":"<p>Runs stress testing on the current problem.</p> <p>Stress testing allows you to find counter-examples where your solution fails (or where two solutions differ).</p> <p>You usually provide a generator command (with random seed) and a reference solution (or validator/checker).</p> <p>Usage: <pre><code>rbx stress &lt;NAME&gt; [OPTIONS]\n</code></pre></p> <p>Arguments:</p> Name Description Required <code>NAME</code> Name of the stress test to run (specified in problem.rbx.yml). No Name Type Description Default <code>--generator</code>, <code>-g</code> TEXT Generator call to use to generate a single test for execution. - <code>--finder</code>, <code>-f</code> TEXT Run a stress with this finder expression. - <code>--timeout</code>, <code>--time</code>, <code>-t</code> INTEGER For how many seconds to run the stress test. <code>10</code> <code>--findings</code>, <code>-n</code> INTEGER How many breaking tests to look for. <code>1</code> <code>-v</code>, <code>--verbose</code> BOOLEAN Whether to print verbose output for checkers and finders. <code>False</code> <code>--sanitized</code>, <code>-s</code> BOOLEAN Whether to compile the solutions with sanitizers enabled. <code>False</code> <code>--description</code>, <code>-d</code> TEXT Optional description of the stress test. - <code>--descriptors</code>, <code>-D</code> BOOLEAN Whether to print descriptors of the stress test. <code>False</code> <code>--skip-invalid</code>, <code>--skip</code> BOOLEAN Whether to skip invalid testcases. <code>False</code> <code>--timelimit</code>, <code>-T</code> INTEGER Custom timelimit for the stress test. - <code>--double-tl</code> BOOLEAN Whether to use 2*TL as the timelimit for the stress test. <code>False</code> <code>--slowest</code> BOOLEAN Whether to find the slowest testcases. This removes the time limit of the solution executions and focus on finding the testcases that make them the slowest. <code>False</code> <code>--fuzz</code> BOOLEAN Whether to fuzz generator calls from all testgroups. <code>False</code> <code>--fuzz-on</code> TEXT Testgroups to fuzz generator calls from. - <code>--validate</code> BOOLEAN Whether to validate inputs. <code>True</code>"},{"location":"setters/reference/cli/#compile","title":"compile","text":"<p>Compile an asset given its path.</p> <p>Usage: <pre><code>rbx compile &lt;PATH&gt; [OPTIONS]\n</code></pre></p> <p>Arguments:</p> Name Description Required <code>PATH</code> Path to the asset to compile. No Name Type Description Default <code>--sanitized</code>, <code>-s</code> BOOLEAN Whether to compile the asset with sanitizers enabled. <code>False</code> <code>--warnings</code>, <code>-w</code> BOOLEAN Whether to compile the asset with warnings enabled. <code>False</code> <code>--all</code>, <code>-a</code> BOOLEAN Whether to compile all assets. <code>False</code>"},{"location":"setters/reference/cli/#validate","title":"validate","text":"<p>Run the validator in a one-off fashion, interactively.</p> <p>Usage: <pre><code>rbx validate [OPTIONS]\n</code></pre></p> Name Type Description Default <code>--path</code>, <code>-p</code> TEXT Path to the testcase to validate. -"},{"location":"setters/reference/cli/#unit","title":"unit","text":"<p>Run unit tests for the validator and checker.</p> <p>Usage: <pre><code>rbx unit [OPTIONS]\n</code></pre></p>"},{"location":"setters/reference/cli/#header","title":"header","text":"<p>Generate the rbx.h header file.</p> <p>Usage: <pre><code>rbx header [OPTIONS]\n</code></pre></p>"},{"location":"setters/reference/cli/#environment-env","title":"environment (env)","text":"<p>Set or show the current box environment.</p> <p>Usage: <pre><code>rbx environment &lt;ENV&gt; [OPTIONS]\n</code></pre></p> <p>Arguments:</p> Name Description Required <code>ENV</code> - No Name Type Description Default <code>--install</code>, <code>-i</code> TEXT Whether to install this environment from the given file. -"},{"location":"setters/reference/cli/#languages","title":"languages","text":"<p>List the languages available in this environment</p> <p>Usage: <pre><code>rbx languages [OPTIONS]\n</code></pre></p>"},{"location":"setters/reference/cli/#stats","title":"stats","text":"<p>Show stats about current and related packages.</p> <p>Usage: <pre><code>rbx stats [OPTIONS]\n</code></pre></p> Name Type Description Default <code>--transitive</code>, <code>-t</code> BOOLEAN Show stats about all reachable packages. <code>False</code>"},{"location":"setters/reference/cli/#fix","title":"fix","text":"<p>Format files of the current package.</p> <p>Usage: <pre><code>rbx fix [OPTIONS]\n</code></pre></p> Name Type Description Default <code>--print-diff</code>, <code>-p</code> BOOLEAN - <code>False</code>"},{"location":"setters/reference/cli/#wizard","title":"wizard","text":"<p>Run the wizard.</p> <p>Usage: <pre><code>rbx wizard [OPTIONS]\n</code></pre></p>"},{"location":"setters/reference/cli/#clear-clean","title":"clear (clean)","text":"<p>Clears cache and build directories.</p> <p>Usage: <pre><code>rbx clear [OPTIONS]\n</code></pre></p> Name Type Description Default <code>--global</code>, <code>-g</code> BOOLEAN - <code>False</code>"},{"location":"setters/reference/cli/#config-cfg","title":"config (cfg)","text":"<p>Manage setter configuration (sub-command).</p> <p>Usage: <pre><code>rbx config [OPTIONS]\n</code></pre></p>"},{"location":"setters/reference/cli/#path","title":"path","text":"<p>Show the path to the setter config.</p> <p>Usage: <pre><code>rbx config path [OPTIONS]\n</code></pre></p>"},{"location":"setters/reference/cli/#list-ls","title":"list (ls)","text":"<p>Pretty print the config file.</p> <p>Usage: <pre><code>rbx config list [OPTIONS]\n</code></pre></p>"},{"location":"setters/reference/cli/#edit","title":"edit","text":"<p>Open the setter config in an editor.</p> <p>Usage: <pre><code>rbx config edit [OPTIONS]\n</code></pre></p>"},{"location":"setters/reference/cli/#reset","title":"reset","text":"<p>Reset the config file to the default one.</p> <p>Usage: <pre><code>rbx config reset [OPTIONS]\n</code></pre></p>"},{"location":"setters/reference/cli/#statements-st","title":"statements (st)","text":"<p>Manage statements (sub-command).</p> <p>Usage: <pre><code>rbx statements [OPTIONS]\n</code></pre></p>"},{"location":"setters/reference/cli/#build-b_1","title":"build (b)","text":"<p>Build statements.</p> <p>Usage: <pre><code>rbx statements build &lt;NAMES&gt; [OPTIONS]\n</code></pre></p> <p>Arguments:</p> Name Description Required <code>NAMES</code> Names of statements to build. No Name Type Description Default <code>--verification-level</code>, <code>--verification</code>, <code>-v</code> INTEGER of VerificationLevel Verification level to use when building package. <code>4</code> <code>--languages</code> TEXT Languages to build statements for. If not specified, build statements for all available languages. - <code>--output</code> StatementType Output type to be generated. If not specified, will infer from the conversion steps specified in the package. <code>PDF</code> <code>--samples</code> BOOLEAN Whether to build the statement with samples or not. <code>True</code> <code>--vars</code> TEXT Variables to be used in the statements. - <code>--validate</code> BOOLEAN Whether to validate outputs for testcases or not. <code>True</code>"},{"location":"setters/reference/cli/#download-down","title":"download (down)","text":"<p>Download an asset from supported repositories (sub-command).</p> <p>Usage: <pre><code>rbx download [OPTIONS]\n</code></pre></p>"},{"location":"setters/reference/cli/#testlib","title":"testlib","text":"<p>Download testlib.h</p> <p>Usage: <pre><code>rbx download testlib [OPTIONS]\n</code></pre></p>"},{"location":"setters/reference/cli/#jngen","title":"jngen","text":"<p>Download jngen.h</p> <p>Usage: <pre><code>rbx download jngen [OPTIONS]\n</code></pre></p>"},{"location":"setters/reference/cli/#checker","title":"checker","text":"<p>Download a built-in checker from testlib GH repo.</p> <p>Usage: <pre><code>rbx download checker &lt;NAME&gt; [OPTIONS]\n</code></pre></p> <p>Arguments:</p> Name Description Required <code>NAME</code> - Yes"},{"location":"setters/reference/cli/#remote-r","title":"remote (r)","text":"<p>Download a remote code.</p> <p>Usage: <pre><code>rbx download remote &lt;NAME&gt; [OPTIONS]\n</code></pre></p> <p>Arguments:</p> Name Description Required <code>NAME</code> - Yes Name Type Description Default <code>-o</code>, <code>--output</code> TEXT Whether to not build outputs for tests and run checker. -"},{"location":"setters/reference/cli/#presets","title":"presets","text":"<p>Manage presets (sub-command).</p> <p>Usage: <pre><code>rbx presets [OPTIONS]\n</code></pre></p>"},{"location":"setters/reference/cli/#create","title":"create","text":"<p>Create a new preset.</p> <p>Usage: <pre><code>rbx presets create [OPTIONS]\n</code></pre></p> Name Type Description Default <code>--name</code> TEXT The name of the preset to create. This will also be the name of the folder. - <code>--uri</code> TEXT The URI of the new preset. - <code>--preset</code>, <code>-p</code> TEXT The URI of the preset to init the new preset from. -"},{"location":"setters/reference/cli/#update","title":"update","text":"<p>Update preset of current package</p> <p>Usage: <pre><code>rbx presets update [OPTIONS]\n</code></pre></p>"},{"location":"setters/reference/cli/#sync","title":"sync","text":"<p>Sync current package assets with those provided by the installed preset.</p> <p>Usage: <pre><code>rbx presets sync [OPTIONS]\n</code></pre></p> Name Type Description Default <code>--update</code>, <code>-u</code> BOOLEAN Whether to fetch an up-to-date version of the installed preset from remote, if available. <code>False</code> <code>--force</code>, <code>-f</code> BOOLEAN Whether to forcefully overwrite the local assets with the preset assets, even if they have been modified. <code>False</code> <code>--symlinks</code>, <code>-s</code> BOOLEAN Whether to update all symlinks in the preset to point to their right targets. <code>False</code>"},{"location":"setters/reference/cli/#ls","title":"ls","text":"<p>List details about the active preset.</p> <p>Usage: <pre><code>rbx presets ls [OPTIONS]\n</code></pre></p>"},{"location":"setters/reference/cli/#package-pkg","title":"package (pkg)","text":"<p>Build problem packages (sub-command).</p> <p>Usage: <pre><code>rbx package [OPTIONS]\n</code></pre></p>"},{"location":"setters/reference/cli/#polygon","title":"polygon","text":"<p>Build a package for Polygon.</p> <p>Usage: <pre><code>rbx package polygon [OPTIONS]\n</code></pre></p> Name Type Description Default <code>--verification-level</code>, <code>--verification</code>, <code>-v</code> INTEGER of VerificationLevel Verification level to use when building package. <code>4</code> <code>--upload</code>, <code>-u</code> BOOLEAN If set, will upload the package to Polygon. <code>False</code> <code>--language</code>, <code>-l</code> TEXT If set, will use the given language as the main language. Leave unset if your problem has no statements. - <code>--upload-as-english</code> BOOLEAN If set, will force the main statement to be uploaded in English. <code>False</code> <code>--upload-only</code> TEXT Only upload the following types of assets to Polygon. - <code>--upload-skip</code> TEXT Skip uploading the following types of assets to Polygon. - <code>--validate-statement</code> BOOLEAN If set, will validate the statement for Polygon. <code>False</code>"},{"location":"setters/reference/cli/#boca","title":"boca","text":"<p>Build a package for BOCA.</p> <p>Usage: <pre><code>rbx package boca [OPTIONS]\n</code></pre></p> Name Type Description Default <code>--verification-level</code>, <code>--verification</code>, <code>-v</code> INTEGER of VerificationLevel Verification level to use when building package. <code>4</code> <code>--upload</code>, <code>-u</code> BOOLEAN If set, will upload the package to BOCA. <code>False</code> <code>--language</code>, <code>-l</code> TEXT If set, will use the given language as the main language. Leave unset if you want to use the language of the topmost statement. -"},{"location":"setters/reference/cli/#moj","title":"moj","text":"<p>Build a package for MOJ.</p> <p>Usage: <pre><code>rbx package moj [OPTIONS]\n</code></pre></p> Name Type Description Default <code>--verification-level</code>, <code>--verification</code>, <code>-v</code> INTEGER of VerificationLevel Verification level to use when building package. <code>4</code> <code>--for-boca</code> BOOLEAN Build a package for BOCA instead of MOJ. <code>False</code>"},{"location":"setters/reference/cli/#pkg","title":"pkg","text":"<p>Build a package for PKG.</p> <p>Usage: <pre><code>rbx package pkg [OPTIONS]\n</code></pre></p> Name Type Description Default <code>--verification-level</code>, <code>--verification</code>, <code>-v</code> INTEGER of VerificationLevel Verification level to use when building package. <code>4</code>"},{"location":"setters/reference/cli/#contest","title":"contest","text":"<p>Manage contests (sub-command).</p> <p>Usage: <pre><code>rbx contest [OPTIONS]\n</code></pre></p>"},{"location":"setters/reference/cli/#create-c_1","title":"create (c)","text":"<p>Create a new contest package.</p> <p>Usage: <pre><code>rbx contest create [OPTIONS]\n</code></pre></p> Name Type Description Default <code>--path</code> TEXT Path where to create the contest. - <code>--preset</code>, <code>-p</code> TEXT Which preset to use to create this package. Can be a named of an already installed preset, or an URI, in which case the preset will be downloaded. If not provided, the default preset will be used, or the active preset if any. -"},{"location":"setters/reference/cli/#init-i","title":"init (i)","text":"<p>Initialize a new contest in the current directory.</p> <p>Usage: <pre><code>rbx contest init [OPTIONS]\n</code></pre></p> Name Type Description Default <code>--preset</code>, <code>-p</code> TEXT Which preset to use to create this package. Can be a named of an already installed preset, or an URI, in which case the preset will be downloaded. If not provided, the default preset will be used, or the active preset if any. -"},{"location":"setters/reference/cli/#edit-e_1","title":"edit (e)","text":"<p>Open contest.rbx.yml in your default editor.</p> <p>Usage: <pre><code>rbx contest edit [OPTIONS]\n</code></pre></p>"},{"location":"setters/reference/cli/#add-a","title":"add (a)","text":"<p>Add new problem to contest.</p> <p>Usage: <pre><code>rbx contest add [OPTIONS]\n</code></pre></p> Name Type Description Default <code>--path</code> TEXT Path where to create the problem. Name part of the path will be used as the problem name. - <code>--short-name</code> TEXT Short name of the problem. Will be used as the identifier in the contest. - <code>--preset</code> TEXT Preset to use when creating the problem. If not specified, the active preset will be used. -"},{"location":"setters/reference/cli/#remove-r","title":"remove (r)","text":"<p>Remove problem from contest.</p> <p>Usage: <pre><code>rbx contest remove &lt;PATH_OR_SHORT_NAME&gt; [OPTIONS]\n</code></pre></p> <p>Arguments:</p> Name Description Required <code>PATH_OR_SHORT_NAME</code> - Yes"},{"location":"setters/reference/cli/#each_1","title":"each","text":"<p>Run a command for each problem in the contest.</p> <p>Usage: <pre><code>rbx contest each [OPTIONS]\n</code></pre></p>"},{"location":"setters/reference/cli/#on_1","title":"on","text":"<p>Run a command in the problem (or in a set of problems) of a context.</p> <p>Usage: <pre><code>rbx contest on &lt;PROBLEMS&gt; [OPTIONS]\n</code></pre></p> <p>Arguments:</p> Name Description Required <code>PROBLEMS</code> - Yes"},{"location":"setters/reference/cli/#summary-sum_1","title":"summary (sum)","text":"<p>Print a summary of the contest.</p> <p>Usage: <pre><code>rbx contest summary [OPTIONS]\n</code></pre></p>"},{"location":"setters/reference/cli/#statements-st_1","title":"statements (st)","text":"<p>Manage contest-level statements.</p> <p>Usage: <pre><code>rbx contest statements [OPTIONS]\n</code></pre></p>"},{"location":"setters/reference/cli/#build-b_2","title":"build (b)","text":"<p>Build statements.</p> <p>Usage: <pre><code>rbx contest statements build &lt;NAMES&gt; [OPTIONS]\n</code></pre></p> <p>Arguments:</p> Name Description Required <code>NAMES</code> Names of statements to build. No Name Type Description Default <code>--verification-level</code>, <code>--verification</code>, <code>-v</code> INTEGER of VerificationLevel Verification level to use when building package. <code>4</code> <code>--languages</code> TEXT Languages to build statements for. If not specified, build statements for all available languages. - <code>--validate</code> BOOLEAN Whether to validate outputs for testcases or not. <code>True</code> <code>--output</code> StatementType Output type to be generated. If not specified, will infer from the conversion steps specified in the package. <code>PDF</code> <code>--samples</code> BOOLEAN Whether to build the statement with samples or not. <code>True</code> <code>--vars</code> TEXT Variables to be used in the statements. - <code>--install-tex</code> BOOLEAN Whether to install missing LaTeX packages. <code>False</code>"},{"location":"setters/reference/cli/#package-pkg_1","title":"package (pkg)","text":"<p>Build contest-level packages.</p> <p>Usage: <pre><code>rbx contest package [OPTIONS]\n</code></pre></p>"},{"location":"setters/reference/cli/#polygon_1","title":"polygon","text":"<p>Build a contest package for Polygon.</p> <p>Usage: <pre><code>rbx contest package polygon [OPTIONS]\n</code></pre></p> Name Type Description Default <code>--verification-level</code>, <code>--verification</code>, <code>-v</code> INTEGER of VerificationLevel Verification level to use when building package. <code>4</code> <code>--language</code>, <code>-l</code> TEXT If set, will use the given language as the main language. -"},{"location":"setters/reference/cli/#boca_1","title":"boca","text":"<p>Build a contest package for BOCA.</p> <p>Usage: <pre><code>rbx contest package boca [OPTIONS]\n</code></pre></p> Name Type Description Default <code>--verification-level</code>, <code>--verification</code>, <code>-v</code> INTEGER of VerificationLevel Verification level to use when building package. <code>4</code>"},{"location":"setters/reference/cli/#pkg_1","title":"pkg","text":"<p>Build a contest package for PKG.</p> <p>Usage: <pre><code>rbx contest package pkg [OPTIONS]\n</code></pre></p> Name Type Description Default <code>--verification-level</code>, <code>--verification</code>, <code>-v</code> INTEGER of VerificationLevel Verification level to use when building package. <code>4</code>"},{"location":"setters/reference/cli/#testcases-tc-t","title":"testcases (tc, t)","text":"<p>Manage testcases (sub-command).</p> <p>Usage: <pre><code>rbx testcases [OPTIONS]\n</code></pre></p>"},{"location":"setters/reference/cli/#view-v","title":"view (v)","text":"<p>View a testcase in your default editor.</p> <p>Usage: <pre><code>rbx testcases view &lt;TC&gt; [OPTIONS]\n</code></pre></p> <p>Arguments:</p> Name Description Required <code>TC</code> Testcase to view. Format: [group]/[index]. Yes Name Type Description Default <code>--input</code>, <code>-i</code> BOOLEAN Whether to open only the input file in the editor. <code>False</code> <code>--output</code>, <code>-o</code> BOOLEAN Whether to open only the output file in the editor. <code>False</code>"},{"location":"setters/reference/cli/#info-i","title":"info (i)","text":"<p>Show information about testcases.</p> <p>Usage: <pre><code>rbx testcases info &lt;PATTERN&gt; [OPTIONS]\n</code></pre></p> <p>Arguments:</p> Name Description Required <code>PATTERN</code> Testcases to detail, as a pattern. Might be a group, or a specific test in the format [group]/[index]. No"},{"location":"setters/reference/cli/#tool-tooling","title":"tool (tooling)","text":"<p>Manage tooling (sub-command).</p> <p>Usage: <pre><code>rbx tool [OPTIONS]\n</code></pre></p>"},{"location":"setters/reference/cli/#convert","title":"convert","text":"<p>Usage: <pre><code>rbx tool convert &lt;PKG&gt; [OPTIONS]\n</code></pre></p> <p>Arguments:</p> Name Description Required <code>PKG</code> The package to convert. Yes Name Type Description Default <code>-s</code>, <code>--source</code> TEXT The format to convert from. - <code>-d</code>, <code>--dest</code> TEXT The format to convert to. - <code>-o</code>, <code>--output</code> TEXT The output path. - <code>--language</code>, <code>-l</code> TEXT The main language of the problem. -"},{"location":"setters/reference/cli/#boca_2","title":"boca","text":"<p>Usage: <pre><code>rbx tool boca [OPTIONS]\n</code></pre></p>"},{"location":"setters/reference/cli/#scrape","title":"scrape","text":"<p>Scrape runs from BOCA.</p> <p>Usage: <pre><code>rbx tool boca scrape [OPTIONS]\n</code></pre></p>"},{"location":"setters/reference/cli/#view","title":"view","text":"<p>Open Textual UI to visualize BOCA submissions.</p> <p>Usage: <pre><code>rbx tool boca view [OPTIONS]\n</code></pre></p> Name Type Description Default <code>--contest-id</code>, <code>-c</code> TEXT Contest identifier to load (stored under app data). -"},{"location":"setters/reference/cli/#generic-types","title":"Generic Types","text":""},{"location":"setters/reference/cli/#rbx.grading.grading_context.CacheLevel","title":"<code>CacheLevel</code>","text":"<p>               Bases: <code>AutoEnum</code></p> Source code in <code>rbx/grading/grading_context.py</code> <pre><code>class CacheLevel(AutoEnum):\n    NO_CACHE = alias('none')\n    CACHE_TRANSIENTLY = alias('transient')\n    CACHE_COMPILATION = alias('compilation')\n    CACHE_ALL = alias('all')\n</code></pre>"},{"location":"setters/reference/cli/#rbx.box.statements.schema.StatementType","title":"<code>StatementType</code>","text":"<p>               Bases: <code>AutoEnum</code></p> Source code in <code>rbx/box/statements/schema.py</code> <pre><code>class StatementType(AutoEnum):\n    rbxTeX = alias('rbx-tex')  # type: ignore\n    \"\"\"Statement written in rbxTeX format.\"\"\"\n\n    rbxMarkdown = alias('rbxMd', 'rbx-markdown', 'rbx-md')  # type: ignore\n    \"\"\"Statement written in rbxMarkdown format.\"\"\"\n\n    TeX = alias('tex')  # type: ignore\n    \"\"\"Statement written in pure LaTeX format.\"\"\"\n\n    JinjaTeX = alias('jinja-tex')  # type: ignore\n    \"\"\"Statement written in LaTeX format with Jinja2 expressions.\"\"\"\n\n    PDF = alias('pdf')  # type: ignore\n    \"\"\"Statement is a PDF.\"\"\"\n\n    def get_file_suffix(self) -&gt; str:\n        if self == StatementType.TeX:\n            return '.tex'\n        if self == StatementType.rbxTeX:\n            return '.rbx.tex'\n        if self == StatementType.rbxMarkdown:\n            return '.rbx.md'\n        if self == StatementType.JinjaTeX:\n            return '.jinja.tex'\n        if self == StatementType.PDF:\n            return '.pdf'\n        raise ValueError(f'Unknown statement type: {self}')\n</code></pre>"},{"location":"setters/reference/cli/#rbx.box.statements.schema.StatementType.rbxTeX","title":"<code>rbxTeX = alias('rbx-tex')</code>","text":"<p>Statement written in rbxTeX format.</p>"},{"location":"setters/reference/cli/#rbx.box.statements.schema.StatementType.rbxMarkdown","title":"<code>rbxMarkdown = alias('rbxMd', 'rbx-markdown', 'rbx-md')</code>","text":"<p>Statement written in rbxMarkdown format.</p>"},{"location":"setters/reference/cli/#rbx.box.statements.schema.StatementType.TeX","title":"<code>TeX = alias('tex')</code>","text":"<p>Statement written in pure LaTeX format.</p>"},{"location":"setters/reference/cli/#rbx.box.statements.schema.StatementType.JinjaTeX","title":"<code>JinjaTeX = alias('jinja-tex')</code>","text":"<p>Statement written in LaTeX format with Jinja2 expressions.</p>"},{"location":"setters/reference/cli/#rbx.box.statements.schema.StatementType.PDF","title":"<code>PDF = alias('pdf')</code>","text":"<p>Statement is a PDF.</p>"},{"location":"setters/reference/cli/#rbx.box.environment.VerificationLevel","title":"<code>VerificationLevel</code>","text":"<p>               Bases: <code>Enum</code></p> Source code in <code>rbx/box/environment.py</code> <pre><code>class VerificationLevel(Enum):\n    NONE = 0\n    VALIDATE = 1\n    FAST_SOLUTIONS = 2\n    ALL_SOLUTIONS = 3\n    FULL = 4\n</code></pre>"},{"location":"setters/reference/contest/","title":"Contest package","text":"<p>This documentation goes over how each field (or group of fields) in <code>contest.rbx.yml</code> works.</p>"},{"location":"setters/reference/contest/#contest-definition","title":"Contest definition","text":"<p>Schema: rbx.box.contest.schema.Contest</p> <p>The only required field of a contest is its <code>name</code>.</p> <p>A barebones package would look something like:</p> <pre><code>name: \"my-problem\"\n</code></pre>"},{"location":"setters/reference/contest/#contest-problem","title":"Contest problem","text":"<p>Schema: <code>List[</code><code>ContestProblem</code><code>]</code></p> <pre><code>name: \"my-contest\"\nproblems:\n  - short_name: \"A\"\n    path: \"A\"\n    color: \"ff0000\"\n    aliases: [\"apple\"]   # Optional; refer to this problem as \"A\" or \"apple\" in e.g. rbx on &lt;name&gt; run\n  - short_name: \"B\"\n    path: \"B\"\n    color: \"00ff00\"\n</code></pre>"},{"location":"setters/reference/contest/schema/","title":"Contest schema","text":""},{"location":"setters/reference/contest/schema/#contestrbxyml","title":"<code>contest.rbx.yml</code>","text":""},{"location":"setters/reference/contest/schema/#rbx.box.contest.schema.Contest","title":"<code>Contest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of this contest.</p> required <code>titles</code> <code>Dict[str, str]</code> <p>Titles for the contest in each language. Languages should be specified as lowercase ISO 639-1 codes.</p> <code>{}</code> <code>problems</code> <code>List[ContestProblem]</code> <p>List of problems in this contest.</p> <code>[]</code> <code>statements</code> <code>List[ContestStatement]</code> <p>Configure statements in this contest, per language.</p> <code>[]</code> <code>vars</code> <code>TypeAliasType</code> <p>Variables to be re-used across the package.</p> <code>{}</code> Source code in <code>rbx/box/contest/schema.py</code> <pre><code>class Contest(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    name: str = NameField(description='Name of this contest.')\n\n    titles: Dict[str, str] = Field(\n        default={},\n        description='Titles for the contest in each language. '\n        'Languages should be specified as lowercase ISO 639-1 codes.',\n    )\n\n    problems: List[ContestProblem] = Field(\n        default=[], description='List of problems in this contest.'\n    )\n\n    @model_validator(mode='after')\n    def check_problem_identifiers_unique(self):\n        seen: Dict[str, str] = {}\n        for problem in self.problems:\n            identifiers = [problem.short_name.lower()] + [\n                a.lower() for a in problem.aliases\n            ]\n            for ident in identifiers:\n                if ident in seen:\n                    raise ValueError(\n                        f'Problem identifier {ident!r} is used by more than one problem '\n                        f'(short_name or alias in problem {seen[ident]!r} and in {problem.short_name!r}).'\n                    )\n                seen[ident] = problem.short_name\n        return self\n\n    statements: Annotated[\n        List[ContestStatement],\n        AfterValidator(is_unique_by_name),\n    ] = Field(\n        default=[],\n        description='Configure statements in this contest, per language.',\n    )\n\n    # Vars to be re-used in the statements.\n    #   - It will be available as \\VAR{vars} variable in the contest-level box statement.\n    vars: RecVars = Field(\n        default={}, description='Variables to be re-used across the package.'\n    )\n\n    @property\n    def expanded_statements(self) -&gt; List[ContestStatement]:\n        return expand_statements(self.statements)\n\n    @property\n    def expanded_vars(self) -&gt; Vars:\n        return expand_vars(self.vars)\n</code></pre>"},{"location":"setters/reference/contest/schema/#rbx.box.contest.schema.ContestProblem","title":"<code>ContestProblem</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>short_name</code> <code>str</code> <p>Short name of the problem. Usually, just an uppercase letter, but can be a sequence of uppercase letters followed by a number.</p> required <code>aliases</code> <code>List[str]</code> <p>Optional list of aliases for this problem. You can refer to the problem by its short_name or by any of these aliases in commands such as [item]rbx on  run[/item]. Aliases must be unique across all problems (case-insensitive). <code>&lt;dynamic&gt;</code> <code>path</code> <code>Path | None</code> <p>Path to the problem relative to the contest package directory. If not specified, will expect the problem to be in ./{short_name}/ folder.</p> <code>None</code> <code>color</code> <code>str | None</code> <p>Color that represents this problem in the contest.</p> <p>Can be a hex color (#abcdef or #abc format), or a color name among available X11 colors.</p> <p>See https://en.wikipedia.org/wiki/X11_color_names for the list of supported color names.</p> <code>None</code> <code>colorName</code> <code>str | None</code> <p>A custom color name for the color provided by this problem.</p> <p>If not provided, will try to infer a color name from the color provided.</p> <code>None</code> Source code in <code>rbx/box/contest/schema.py</code> <pre><code>class ContestProblem(BaseModel):\n    short_name: str = ShortNameField(\n        description=\"\"\"\nShort name of the problem. Usually, just an uppercase letter,\nbut can be a sequence of uppercase letters followed by a number.\"\"\"\n    )\n\n    aliases: List[Alias] = Field(\n        default_factory=list,\n        description=\"\"\"\nOptional list of aliases for this problem. You can refer to the problem by its\nshort_name or by any of these aliases in commands such as [item]rbx on &lt;name&gt; run[/item].\nAliases must be unique across all problems (case-insensitive).\"\"\",\n    )\n\n    path: Optional[pathlib.Path] = Field(\n        default=None,\n        description=\"\"\"\nPath to the problem relative to the contest package directory.\nIf not specified, will expect the problem to be in ./{short_name}/ folder.\"\"\",\n    )\n\n    color: Optional[str] = Field(\n        default=None,\n        description=\"\"\"\nColor that represents this problem in the contest.\n\nCan be a hex color (#abcdef or #abc format), or a color name among available X11 colors.\n\nSee https://en.wikipedia.org/wiki/X11_color_names for the list of supported color names.\n\"\"\",\n    )\n\n    colorName: Optional[str] = Field(\n        default=None,\n        description=\"\"\"\nA custom color name for the color provided by this problem.\n\nIf not provided, will try to infer a color name from the color provided.\n\"\"\",\n        pattern=r'^[a-zA-Z]+$',\n    )\n\n    @model_validator(mode='after')\n    def check_color(self):\n        from colour import Color\n\n        if self.color is None:\n            return self\n\n        Color(self.color)\n        return self\n\n    @property\n    def hex_color(self) -&gt; Optional[str]:\n        from colour import Color\n\n        if self.color is None:\n            return None\n\n        return Color(self.color).hex_l\n\n    @property\n    def color_name(self) -&gt; Optional[str]:\n        if self.colorName is not None:\n            return self.colorName\n\n        if self.color is None:\n            return None\n\n        from colour import Color\n\n        color = Color(self.color)\n        web_color = color.web\n        if web_color.startswith('#'):\n            return 'unknown'\n        return web_color\n\n    def get_path(self) -&gt; pathlib.Path:\n        return self.path or pathlib.Path(self.short_name)\n\n    def all_identifiers(self) -&gt; Set[str]:\n        \"\"\"All names that can be used to refer to this problem (short_name + aliases), lowercased.\"\"\"\n        return {self.short_name.lower()} | {a.lower() for a in self.aliases}\n</code></pre>"},{"location":"setters/reference/contest/schema/#rbx.box.contest.schema.ContestProblem.all_identifiers","title":"<code>all_identifiers()</code>","text":"<p>All names that can be used to refer to this problem (short_name + aliases), lowercased.</p> Source code in <code>rbx/box/contest/schema.py</code> <pre><code>def all_identifiers(self) -&gt; Set[str]:\n    \"\"\"All names that can be used to refer to this problem (short_name + aliases), lowercased.\"\"\"\n    return {self.short_name.lower()} | {a.lower() for a in self.aliases}\n</code></pre>"},{"location":"setters/reference/contest/schema/#rbx.box.contest.schema.ContestStatement","title":"<code>ContestStatement</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of this statement.</p> required <code>extends</code> <code>str | None</code> <p>Name of the statement to inherit from.</p> <code>None</code> <code>language</code> <code>str</code> <p>Language code for this statement (ISO 639-1).</p> <code>'en'</code> <code>title</code> <code>str</code> <p>Title of the contest in this language.Will override the <code>titles</code> field of the contest.</p> <code>''</code> <code>location</code> <code>str | None</code> <p>Location of the contest in this language.</p> <code>None</code> <code>date</code> <code>str | None</code> <p>Date of the contest in this language.</p> <code>None</code> <code>path</code> <code>Path</code> <p>Path to the input statement file.</p> <code>&lt;dynamic&gt;</code> <code>type</code> <code>StatementType</code> <p>Type of the input statement file.</p> <code>rbxTeX</code> <code>joiner</code> <code>JoinTexToPDF | None</code> <p>Joiner to be used to build the statement.</p> <p>This determines how problem statements will be joined into a single contest statement.</p> <code>None</code> <code>steps</code> <code>List[TexToPDF | JinjaTeX | rbxToTeX | rbxMarkdownToTeX]</code> <p>Describes a sequence of conversion steps that should be applied to the statement file of this contest.</p> <p>Usually, it is not necessary to specify these, as they can be inferred from the input statement type and the output statement type, but you can use this to force certain conversion steps to happen.</p> <code>[]</code> <code>configure</code> <code>List[TexToPDF | JinjaTeX | rbxToTeX | rbxMarkdownToTeX]</code> <p>Configure how certain conversion steps should happen when applied to the statement file of this contest.</p> <p>Different from the <code>steps</code> field, this does not force the steps to happen, but rather only configure them in case they are applied.</p> <code>[]</code> <code>assets</code> <code>List[str]</code> <p>Assets relative to the contest directory that should be included while building the statement. Files will be included in the same folder as the statement file. Can be glob pattern as well, such as <code>imgs/*.png</code>.</p> <code>[]</code> <code>override</code> <code>ProblemStatementOverride | None</code> <p>Override configuration for problem statements that are joined into this contest statement.</p> <code>None</code> <code>inheritOverride</code> <code>ProblemStatementOverride | None</code> <p>Override configuration for problem statements that inherit from this contest statement.</p> <code>None</code> <code>match</code> <code>str | None</code> <p>Name of the problem-level statement to match this statement against.</p> <p>If not specified, will match against the first statement of the same language.</p> <code>None</code> <code>vars</code> <code>TypeAliasType</code> <p>Variables to be re-used across the package.</p> <code>{}</code> <code>samples</code> <code>bool</code> <p>Whether to build the statement with samples.</p> <code>True</code> Source code in <code>rbx/box/contest/schema.py</code> <pre><code>class ContestStatement(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    name: str = FNameField(description='Name of this statement.')\n\n    extends: Optional[str] = FNameField(\n        default=None, description='Name of the statement to inherit from.'\n    )\n\n    language: StatementLanguage = Field(\n        default='en', description='Language code for this statement (ISO 639-1).'\n    )\n\n    title: str = Field(\n        default='',\n        description='Title of the contest in this language.'\n        'Will override the `titles` field of the contest.',\n    )\n\n    location: Optional[str] = Field(\n        default=None, description='Location of the contest in this language.'\n    )\n\n    date: Optional[str] = Field(\n        default=None, description='Date of the contest in this language.'\n    )\n\n    path: pathlib.Path = Field(\n        default_factory=pathlib.Path,\n        description='Path to the input statement file.',\n    )\n\n    type: StatementType = Field(\n        default=StatementType.rbxTeX, description='Type of the input statement file.'\n    )\n\n    joiner: Optional[Joiner] = Field(\n        default=None,\n        description=\"\"\"\nJoiner to be used to build the statement.\n\nThis determines how problem statements will be joined into a single contest statement.\"\"\",\n    )\n\n    steps: List[Annotated[ConversionStep, Field(discriminator='type')]] = Field(\n        default=[],\n        description=\"\"\"\nDescribes a sequence of conversion steps that should be applied to the statement file\nof this contest.\n\nUsually, it is not necessary to specify these, as they can be inferred from the\ninput statement type and the output statement type, but you can use this to force\ncertain conversion steps to happen.\n\"\"\",\n    )\n\n    configure: List[Annotated[ConversionStep, Field(discriminator='type')]] = Field(\n        default=[],\n        description=\"\"\"\nConfigure how certain conversion steps should happen when applied to the statement file of\nthis contest.\n\nDifferent from the `steps` field, this does not force the steps to happen, but rather only\nconfigure them in case they are applied.\n\"\"\",\n    )\n\n    assets: List[str] = Field(\n        default=[],\n        description=\"\"\"\nAssets relative to the contest directory that should be included while building\nthe statement. Files will be included in the same folder as the statement file.\nCan be glob pattern as well, such as `imgs/*.png`.\n\"\"\",\n    )\n\n    override: Optional[ProblemStatementOverride] = Field(\n        default=None,\n        description='Override configuration for problem statements that are joined into this contest statement.',\n    )\n\n    inheritOverride: Optional[ProblemStatementOverride] = Field(\n        default=None,\n        description='Override configuration for problem statements that inherit from this contest statement.',\n    )\n\n    match: Optional[str] = FNameField(\n        default=None,\n        description=\"\"\"\n        Name of the problem-level statement to match this statement against.\n\n        If not specified, will match against the first statement of the same language.\n        \"\"\",\n    )\n\n    # Vars to be re-used in the statement.\n    #   - It will be available as \\VAR{vars} variable in the contest-level box statement.\n    vars: RecVars = Field(\n        default={}, description='Variables to be re-used across the package.'\n    )\n\n    samples: bool = Field(\n        default=True,\n        description='Whether to build the statement with samples.',\n    )\n\n    @property\n    def expanded_vars(self) -&gt; Vars:\n        return expand_vars(self.vars)\n</code></pre>"},{"location":"setters/reference/contest/schema/#rbx.box.contest.schema.ProblemStatementOverride","title":"<code>ProblemStatementOverride</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>configure</code> <code>List[TexToPDF | JinjaTeX | rbxToTeX | rbxMarkdownToTeX]</code> <p>Configure how certain conversion steps should happen when applied to the statement file.</p> <p>Different from the <code>steps</code> field, this does not force the steps to happen, but rather only configure them in case they are applied.</p> <code>[]</code> <code>vars</code> <code>Dict[str, int | float | bool | str]</code> <p>Variables to be merged into the problem statement vars.</p> <code>{}</code> Source code in <code>rbx/box/contest/schema.py</code> <pre><code>class ProblemStatementOverride(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    configure: List[Annotated[ConversionStep, Field(discriminator='type')]] = Field(\n        default=[],\n        description=\"\"\"\nConfigure how certain conversion steps should happen when applied to the statement file.\n\nDifferent from the `steps` field, this does not force the steps to happen, but rather only\nconfigure them in case they are applied.\n\"\"\",\n    )\n\n    vars: Dict[str, Primitive] = Field(\n        default={},\n        description='Variables to be merged into the problem statement vars.',\n    )\n</code></pre>"},{"location":"setters/reference/environment/","title":"Environment","text":"<p>An environment file is a YAML configuration file that describes the environment in which rbx will execute your code.</p> <p>The <code>Environment</code> class is used to describe the environment in which the code will be executed. You can follow the schema of this class to figure out everything you can configure in the environment file, but here we'll describe the most common fields.</p>"},{"location":"setters/reference/environment/#compilation-configuration","title":"Compilation configuration","text":"<p>You can define a few default settings for compilation by using the <code>defaultCompilation</code> field.</p> <p>You can look at the <code>CompilationConfig</code> class for more details of what you can do, but here's an example with a few useful settings:</p> <pre><code>defaultCompilation:\n  # Defines a few default limits when compiling in the sandbox.\n  sandbox:\n    timeLimit: 10000 # 10 seconds\n    wallTimeLimit: 10000 # 20 seconds\n    memoryLimit: 1024 # 1gb\n</code></pre> <p>Usually, the default values here are enough, but you can customize this for your needs. For instance, if you have a very slow computer at hand, you might want to increase the limits to ensure the compilers have the time to do their job.</p>"},{"location":"setters/reference/environment/#default-execution-configuration","title":"Default execution configuration","text":"<p>You can establish similar limits for code execution by using the <code>defaultExecution</code> field, by using the <code>ExecutionConfig</code> class.</p> <pre><code>defaultExecution:\n  # Defines a few default limits when running programs in the sandbox.\n  sandbox:\n    timeLimit: 10000 # 10 seconds\n    wallTimeLimit: 10000 # 20 seconds\n    memoryLimit: 1024 # 1gb\n</code></pre> <p>Notice these limits are language agnostic, and problem agnostic. This means you should set this to a value larger than any limit you expect for any problem. This is mostly used to ensure programs that eat too much memory or take too long to finish, but don't have limits applied to them, don't hang forever or crash your system. Examples are checkers, validators, etc.</p>"},{"location":"setters/reference/environment/#languages","title":"Languages","text":"<p>The <code>languages</code> field is used to define the languages supported by the environment. This is a list of <code>EnvironmentLanguage</code> objects, which you can look at the schema for more details.</p> <p>Here's an example of a language definition:</p> <pre><code>languages:\n  - name: \"cpp\" # (1)!\n    readableName: \"C++17\" # (2)!\n    extension: \"cpp\" # (3)!\n    compilation: # (4)!\n      commands:\n        - \"g++ -std=c++20 -O2 -o {executable} {compilable}\"\n    execution: # (5)!\n      command: \"./{executable}\"\n    fileMapping: # (6)!\n      compilable: \"compilable.cpp\"\n</code></pre> <ol> <li>The <code>name</code> field is the name of the language, which will be used to identify the language when    explicitly specifying the language of a solution or other code item in your packages.</li> <li>The <code>readableName</code> field is the name of the language as it will be displayed to you.</li> <li>The <code>extension</code> field identifies the extension of files that will be automatically inferred    to have been written in this language.</li> <li>The <code>compilation</code> field is a <code>CompilationConfig</code> object where    you can specify how code in this language should be compiled. Notice the use of the <code>{executable}</code> and <code>{compilable}</code> placeholders.</li> <li>The <code>execution</code> field is an <code>ExecutionConfig</code> object where    you can specify how code in this language should be executed.</li> <li>The <code>fileMapping</code> field is a <code>FileMapping</code> object where    you can specify how files should be named when copied into the sandbox. Notice you can refer to these    files by using the <code>{file}</code> placeholder in the <code>compilation</code> and <code>execution</code> fields.</li> </ol>"},{"location":"setters/reference/environment/#file-mapping","title":"File mapping","text":"<p>The <code>fileMapping</code> field is a <code>FileMapping</code> object where you can specify how files should be named when copied into the sandbox.</p> <p>Notice you can refer to these files by using the <code>{file}</code> placeholder in the <code>compilation</code> and <code>execution</code> fields when configuring new languages.</p> <p>Here's an example of a file mapping for the Java language, and how you would consume them in the <code>compilation</code> and <code>execution</code> fields:</p> <pre><code>languages:\n  - name: \"java\"\n    readableName: \"Java\"\n    extension: \"java\"\n    compilation:\n      commands:\n        - \"javac -Xlint -encoding UTF-8 {compilable}\"\n        - \"jar cvf {executable} @glob:*.class\"\n    execution:\n      command:\n        \"java -Xss100m -Xmx{{ memory }}m -Xms{{ initialMemory }}m -cp {executable}\n        Main\"\n    fileMapping:\n      compilable: \"Main.java\"\n      executable: \"Main.jar\"\n</code></pre> <p>Notice how we use the <code>{compilable}</code> and <code>{executable}</code> placeholders in the <code>compilation</code> and <code>execution</code> fields, and name them appropriately in the <code>fileMapping</code> field.</p>"},{"location":"setters/reference/environment/#command-variables","title":"Command variables","text":"<p>Also, notice you have a few variables that are available to you in the <code>compilation</code> and <code>execution</code> fields.</p> <ul> <li><code>{compilable}</code>: The path to the file that should be compiled.</li> <li><code>{executable}</code>: The path to the file that should be executed.</li> <li><code>{stdin}</code>: The path to the file that should be used as standard input.</li> <li><code>{stdout}</code>: The path to the file that should be used as standard output.</li> <li><code>{stderr}</code>: The path to the file that should be used as standard error.</li> <li><code>{memory}</code>: The memory limit for the sandbox.</li> <li><code>{initialMemory}</code>: The initial memory for the sandbox.</li> <li><code>{javaClass}</code>: The name of the Java class to be executed.</li> </ul> <p>And you also have available to you a <code>@glob:...</code> command that is expanded into a list of files that match the glob pattern. This is particularly useful for languages that need multiple files to be compiled or executed (such as Java in the example above).</p>"},{"location":"setters/reference/environment/#timing-estimation","title":"Timing estimation","text":"<p>Last but not least, you can configure a timing formula to be used when estimating time limits after running <code>rbx time</code> or <code>rbx run -t</code>.</p> <p>By default, the formula is <code>step_up(max(fastest * 3, slowest * 1.5), 100)</code>. The following variables/functions are available to you:</p> <ul> <li><code>fastest</code>: The time of the fastest solution among all AC solutions.</li> <li><code>slowest</code>: The time of the slowest solution among all AC solutions.</li> <li><code>step_up(value, step)</code>: Returns the value rounded up to the nearest multiple of <code>step</code>.</li> <li><code>step_down(value, step)</code>: Returns the value rounded down to the nearest multiple of <code>step</code>.</li> <li><code>max(a, b)</code>: Returns the maximum of <code>a</code> and <code>b</code>.</li> <li><code>min(a, b)</code>: Returns the minimum of <code>a</code> and <code>b</code>.</li> </ul> <p>You might specify a different formula by using the <code>timing</code> field:</p> <pre><code>timing:\n  formula: \"step_up(max(fastest * 2, slowest * 1.5), 100)\"\n</code></pre>"},{"location":"setters/reference/environment/schema/","title":"Environment schema","text":""},{"location":"setters/reference/environment/schema/#environment","title":"Environment","text":""},{"location":"setters/reference/environment/schema/#rbx.box.environment.BaseCompilationConfig","title":"<code>BaseCompilationConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>commands</code> <code>List[str] | None</code> <p>Commands to compile the program.</p> <code>[]</code> <code>sandbox</code> <code>EnvironmentSandbox | None</code> <p>Sandbox configuration to use when compiling for this language.</p> <code>None</code> <code>passthrough</code> <code>bool | None</code> <p>Whether to pass through the compilable as an executable file.</p> <code>None</code> Source code in <code>rbx/box/environment.py</code> <pre><code>class BaseCompilationConfig(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    commands: Optional[List[str]] = Field(\n        default=[],\n        description=\"\"\"Commands to compile the program.\"\"\",\n    )\n\n    sandbox: Optional[EnvironmentSandbox] = Field(\n        default=None,\n        description=\"\"\"Sandbox configuration to use when compiling for this language.\"\"\",\n    )\n\n    passthrough: Optional[bool] = Field(\n        default=None,\n        description=\"\"\"Whether to pass through the compilable as an executable file.\"\"\",\n    )\n</code></pre>"},{"location":"setters/reference/environment/schema/#rbx.box.environment.BaseExecutionConfig","title":"<code>BaseExecutionConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>command</code> <code>str | None</code> <p>Command to run the program.</p> <code>None</code> <code>sandbox</code> <code>EnvironmentSandbox | None</code> <p>Sandbox configuration to use when executing for this language.</p> <code>None</code> <code>problemLimits</code> <code>Limits</code> <p>Original limits of the problem.</p> <code>&lt;dynamic&gt;</code> Source code in <code>rbx/box/environment.py</code> <pre><code>class BaseExecutionConfig(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    command: Optional[str] = Field(\n        default=None,\n        description=\"\"\"Command to run the program.\"\"\",\n    )\n\n    sandbox: Optional[EnvironmentSandbox] = Field(\n        default=None,\n        description=\"\"\"Sandbox configuration to use when executing for this language.\"\"\",\n    )\n\n    problemLimits: Limits = Field(\n        default_factory=Limits,\n        description=\"\"\"Original limits of the problem.\"\"\",\n    )\n</code></pre>"},{"location":"setters/reference/environment/schema/#rbx.box.environment.CompilationConfig","title":"<code>CompilationConfig</code>","text":"<p>               Bases: <code>BaseCompilationConfig</code></p> <p>Parameters:</p> Name Type Description Default <code>solutionOverrides</code> <code>SolutionCompilationOverrides</code> <p>Overrides to apply when compiling solutions for this language.</p> <code>&lt;dynamic&gt;</code> Source code in <code>rbx/box/environment.py</code> <pre><code>class CompilationConfig(BaseCompilationConfig):\n    solutionOverrides: SolutionCompilationOverrides = Field(\n        default_factory=SolutionCompilationOverrides,\n        description=\"\"\"Overrides to apply when compiling solutions for this language.\"\"\",\n    )\n</code></pre>"},{"location":"setters/reference/environment/schema/#rbx.box.environment.Environment","title":"<code>Environment</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>defaultFileMapping</code> <code>FileMapping | None</code> <p>Default mapping for files within the sandbox. Fields in the mapping can be individually overridden in the language configuration.</p> <code>None</code> <code>defaultCompilation</code> <code>CompilationConfig | None</code> <p>Default compilation configuration to use when compiling programs. Fields in the compilation config can be individually overridden in the language configuration.</p> <code>None</code> <code>defaultExecution</code> <code>ExecutionConfig | None</code> <p>Default execution configuration to use when running programs. Fields in the execution config can be individually overridden in the language configuration.</p> <code>None</code> <code>languages</code> <code>List[EnvironmentLanguage]</code> <p>Configuration for each language supported in this environment.</p> <code>[]</code> <code>sandbox</code> <code>str</code> <p>Identifier of the sandbox used by this environment (e.g. \"stupid\")</p> <code>'stupid'</code> <code>timing</code> <code>TimingConfig</code> <p>Timing configuration for the environment.</p> <code>&lt;dynamic&gt;</code> <code>extensions</code> <code>Extensions | None</code> <p>Extensions to be added to the environment.</p> <code>None</code> <code>buildDir</code> <code>Path</code> <p>Directory to store the build files.</p> <code>PosixPath('build')</code> Source code in <code>rbx/box/environment.py</code> <pre><code>class Environment(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    defaultFileMapping: Optional[FileMapping] = Field(\n        default=None,\n        description=\"\"\"Default mapping for files within the sandbox. Fields in the mapping can be\nindividually overridden in the language configuration.\"\"\",\n    )\n\n    defaultCompilation: Optional[CompilationConfig] = Field(\n        default=None,\n        description=\"\"\"Default compilation configuration to use when compiling programs. Fields in\nthe compilation config can be individually overridden in the language configuration.\"\"\",\n    )\n\n    defaultExecution: Optional[ExecutionConfig] = Field(\n        default=None,\n        description=\"\"\"Default execution configuration to use when running programs. Fields in the\nexecution config can be individually overridden in the language configuration.\"\"\",\n    )\n\n    languages: List[EnvironmentLanguage] = Field(\n        default=[],\n        description=\"\"\"Configuration for each language supported in this environment.\"\"\",\n    )\n\n    sandbox: str = Field(\n        default='stupid',\n        description=\"\"\"Identifier of the sandbox used by this environment (e.g. \"stupid\")\"\"\",\n    )\n\n    timing: TimingConfig = Field(\n        default_factory=TimingConfig,\n        description=\"\"\"Timing configuration for the environment.\"\"\",\n    )\n\n    extensions: Optional[Extensions] = Field(\n        default=None,\n        description=\"\"\"Extensions to be added to the environment.\"\"\",\n    )\n\n    buildDir: pathlib.Path = Field(\n        default=pathlib.Path('build'),\n        description=\"\"\"Directory to store the build files.\"\"\",\n    )\n</code></pre>"},{"location":"setters/reference/environment/schema/#rbx.box.environment.EnvironmentLanguage","title":"<code>EnvironmentLanguage</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Identifier of this language within this environment.</p> required <code>readableName</code> <code>str | None</code> <p>Readable name for this language.</p> <code>None</code> <code>extension</code> <code>str</code> <p>File extension supported by this language. If there's only one language that supports a certain file extension in the environment, the tool will automatically identify the language based on such extension.</p> required <code>extraExtensions</code> <code>List[str]</code> <p>Extra file extensions supported by this language. If not specified, the tool will automatically identify the language based on such extensions.</p> <code>&lt;dynamic&gt;</code> <code>compilation</code> <code>CompilationConfig | None</code> <p>Compilation config to use when compiling programs for this language.</p> <code>None</code> <code>execution</code> <code>ExecutionConfig</code> <p>Execution config to use when running programs for this language.</p> required <code>fileMapping</code> <code>FileMapping | None</code> <p>Mapping for files within the sandbox. If not specified, the default mapping for the environment will be used.</p> <code>None</code> <code>extensions</code> <code>LanguageExtensions | None</code> <p>Extensions to apply for this language.</p> <code>None</code> Source code in <code>rbx/box/environment.py</code> <pre><code>class EnvironmentLanguage(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    name: str = Field(\n        description=\"\"\"Identifier of this language within this environment.\"\"\"\n    )\n\n    readableName: Optional[str] = Field(\n        default=None,\n        description=\"\"\"Readable name for this language.\"\"\",\n    )\n\n    extension: str = Field(\n        description=\"\"\"File extension supported by this language. If there's only one language\nthat supports a certain file extension in the environment, the tool\nwill automatically identify the language based on such extension.\"\"\"\n    )\n\n    extraExtensions: List[str] = Field(\n        default_factory=list,\n        description=\"\"\"Extra file extensions supported by this language. If not specified, the tool\nwill automatically identify the language based on such extensions.\"\"\",\n    )\n\n    compilation: Optional[CompilationConfig] = Field(\n        default=None,\n        description=\"\"\"Compilation config to use when compiling programs for this language.\"\"\",\n    )\n\n    execution: ExecutionConfig = Field(\n        description=\"\"\"Execution config to use when running programs for this language.\"\"\"\n    )\n\n    fileMapping: Optional[FileMapping] = Field(\n        default=None,\n        description=\"\"\"Mapping for files within the sandbox. If not specified, the default mapping\nfor the environment will be used.\"\"\",\n    )\n\n    extensions: Optional[LanguageExtensions] = Field(\n        default=None,\n        description=\"\"\"Extensions to apply for this language.\"\"\",\n    )\n\n    def get_extension(self, name: str, _: Type[T]) -&gt; Optional[T]:\n        if self.extensions is None:\n            return None\n        if not hasattr(self.extensions, name):\n            return None\n        return getattr(self.extensions, name)\n\n    def get_extension_or_default(self, name: str, cls: Type[T]) -&gt; T:\n        return self.get_extension(name, cls) or cls()\n</code></pre>"},{"location":"setters/reference/environment/schema/#rbx.box.environment.EnvironmentSandbox","title":"<code>EnvironmentSandbox</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>maxProcesses</code> <code>int | None</code> <p>Max. number of process to allow to run concurrently for the program.</p> <code>1</code> <code>timeLimit</code> <code>int | None</code> <p>Time limit in milliseconds to allow the program to run.</p> <code>None</code> <code>wallTimeLimit</code> <code>int | None</code> <p>Wall time limit in milliseconds to allow the program to run.</p> <code>None</code> <code>memoryLimit</code> <code>int | None</code> <p>Memory limit in MiB.</p> <code>None</code> <code>fileSizeLimit</code> <code>int | None</code> <p>File size limit in KiB</p> <code>None</code> <code>stackLimit</code> <code>int | None</code> <p>Stack limit in MiB.</p> <code>None</code> <code>preserveEnv</code> <code>bool | None</code> <p>Whether to preserve env. variables coming from the host.</p> <code>False</code> <code>mirrorDirs</code> <code>List[str] | None</code> <p>Directories in the host that should be read-only exposed to the sandbox.</p> <code>[]</code> Source code in <code>rbx/box/environment.py</code> <pre><code>class EnvironmentSandbox(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    maxProcesses: Optional[int] = Field(\n        default=1,\n        description=\"\"\"Max. number of process to allow to run concurrently for the program.\"\"\",\n    )\n\n    timeLimit: Optional[int] = Field(\n        default=None,\n        description=\"\"\"Time limit in milliseconds to allow the program to run.\"\"\",\n    )\n\n    wallTimeLimit: Optional[int] = Field(\n        default=None,\n        description=\"\"\"Wall time limit in milliseconds to allow the program to run.\"\"\",\n    )\n\n    memoryLimit: Optional[int] = Field(\n        default=None,\n        description=\"\"\"Memory limit in MiB.\"\"\",\n    )\n\n    fileSizeLimit: Optional[int] = Field(\n        default=None,\n        description=\"\"\"File size limit in KiB\"\"\",\n    )\n\n    stackLimit: Optional[int] = Field(\n        default=None,\n        description=\"\"\"Stack limit in MiB.\"\"\",\n    )\n\n    preserveEnv: Optional[bool] = Field(\n        default=False,\n        description=\"\"\"Whether to preserve env. variables coming from the host.\"\"\",\n    )\n\n    mirrorDirs: Optional[List[str]] = Field(\n        default=[],\n        description=\"\"\"Directories in the host that should be read-only exposed to the sandbox.\"\"\",\n    )\n</code></pre>"},{"location":"setters/reference/environment/schema/#rbx.box.environment.ExecutionConfig","title":"<code>ExecutionConfig</code>","text":"<p>               Bases: <code>BaseExecutionConfig</code></p> <p>Parameters:</p> Name Type Description Default <code>solutionOverrides</code> <code>SolutionExecutionOverrides</code> <p>Overrides to apply when executing solutions for this language.</p> <code>&lt;dynamic&gt;</code> Source code in <code>rbx/box/environment.py</code> <pre><code>class ExecutionConfig(BaseExecutionConfig):\n    solutionOverrides: SolutionExecutionOverrides = Field(\n        default_factory=SolutionExecutionOverrides,\n        description=\"\"\"Overrides to apply when executing solutions for this language.\"\"\",\n    )\n</code></pre>"},{"location":"setters/reference/environment/schema/#rbx.box.environment.FileMapping","title":"<code>FileMapping</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>str</code> <p>Path where to copy the stdin file to before running the program, relative to the sandbox root.</p> <code>'stdin'</code> <code>output</code> <code>str</code> <p>Path where to output the stdout file after running the program, relative to the sandbox root.</p> <code>'stdout'</code> <code>error</code> <code>str</code> <p>Path where to output the stderr file after running the program, relative to the sandbox root.</p> <code>'stderr'</code> <code>capture</code> <code>str</code> <p>Path where to output the capture file after running the program, relative to the sandbox root.</p> <code>'capture'</code> <code>compilable</code> <code>str</code> <p>Path where to copy the compilable file to before compiling the program, relative to the sandbox root.</p> <code>'{source}'</code> <code>executable</code> <code>str</code> <p>Path to where to output the executable file after compiling the program, relative to the sandbox root.</p> <code>'executable'</code> Source code in <code>rbx/box/environment.py</code> <pre><code>class FileMapping(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    input: str = Field(\n        default='stdin',\n        description=\"\"\"Path where to copy the stdin file to before running the program,\nrelative to the sandbox root.\"\"\",\n    )\n\n    output: str = Field(\n        default='stdout',\n        description=\"\"\"Path where to output the stdout file after running the program,\nrelative to the sandbox root.\"\"\",\n    )\n\n    error: str = Field(\n        default='stderr',\n        description=\"\"\"Path where to output the stderr file after running the program,\nrelative to the sandbox root.\"\"\",\n    )\n\n    capture: str = Field(\n        default='capture',\n        description=\"\"\"Path where to output the capture file after running the program,\nrelative to the sandbox root.\"\"\",\n    )\n\n    compilable: str = Field(\n        default='{source}',\n        description=\"\"\"Path where to copy the compilable file to before compiling the program,\nrelative to the sandbox root.\"\"\",\n    )\n\n    executable: str = Field(\n        default='executable',\n        description=\"\"\"Path to where to output the executable file after compiling the program,\nrelative to the sandbox root.\"\"\",\n    )\n</code></pre>"},{"location":"setters/reference/environment/schema/#rbx.box.environment.SolutionCompilationOverrides","title":"<code>SolutionCompilationOverrides</code>","text":"<p>               Bases: <code>BaseCompilationConfig</code></p> Source code in <code>rbx/box/environment.py</code> <pre><code>class SolutionCompilationOverrides(BaseCompilationConfig):\n    pass\n</code></pre>"},{"location":"setters/reference/environment/schema/#rbx.box.environment.SolutionExecutionOverrides","title":"<code>SolutionExecutionOverrides</code>","text":"<p>               Bases: <code>BaseExecutionConfig</code></p> Source code in <code>rbx/box/environment.py</code> <pre><code>class SolutionExecutionOverrides(BaseExecutionConfig):\n    pass\n</code></pre>"},{"location":"setters/reference/environment/schema/#rbx.box.environment.TimingConfig","title":"<code>TimingConfig</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>formula</code> <code>str</code> <p>Formula to use to calculate the time limit for the environment.</p> <code>'step_up(max(fastest * 3, slowest * 1.5), 100)'</code> Source code in <code>rbx/box/environment.py</code> <pre><code>class TimingConfig(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    formula: str = Field(\n        default='step_up(max(fastest * 3, slowest * 1.5), 100)',\n        description=\"\"\"Formula to use to calculate the time limit for the environment.\"\"\",\n    )\n</code></pre>"},{"location":"setters/reference/environment/schema/#extensions","title":"Extensions","text":""},{"location":"setters/reference/environment/schema/#rbx.box.extensions.Extensions","title":"<code>Extensions</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>boca</code> <code>BocaExtension | None</code> <p>Environment-level extensions for BOCA packaging.</p> <code>None</code> Source code in <code>rbx/box/extensions.py</code> <pre><code>class Extensions(BaseModel):\n    boca: Optional[BocaExtension] = Field(\n        default=None, description='Environment-level extensions for BOCA packaging.'\n    )\n</code></pre>"},{"location":"setters/reference/environment/schema/#rbx.box.extensions.LanguageExtensions","title":"<code>LanguageExtensions</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>boca</code> <code>BocaLanguageExtension | None</code> <p>Language-level extensions for BOCA packaging.</p> <code>None</code> <code>polygon</code> <code>PolygonLanguageExtension | None</code> <p>Language-level extensions for Polygon packaging.</p> <code>None</code> Source code in <code>rbx/box/extensions.py</code> <pre><code>class LanguageExtensions(BaseModel):\n    boca: Optional[BocaLanguageExtension] = Field(\n        default=None, description='Language-level extensions for BOCA packaging.'\n    )\n\n    polygon: Optional[PolygonLanguageExtension] = Field(\n        default=None, description='Language-level extensions for Polygon packaging.'\n    )\n</code></pre>"},{"location":"setters/reference/environment/schema/#boca","title":"BOCA","text":""},{"location":"setters/reference/environment/schema/#rbx.box.packaging.boca.extension.BocaExtension","title":"<code>BocaExtension</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>languages</code> <code>List[Literal[c, cpp, cc, kt, java, py2, py3]]</code> <code>['c', 'cpp', 'cc', 'kt', 'java', 'py2', 'py3']</code> <code>flags</code> <code>Dict[Literal[c, cpp, cc, kt, java, py2, py3], str]</code> <code>{}</code> <code>maximumTimeError</code> <code>float</code> <code>0.2</code> <code>preferContestLetter</code> <code>bool</code> <code>False</code> <code>usePypy</code> <code>bool</code> <code>False</code> Source code in <code>rbx/box/packaging/boca/extension.py</code> <pre><code>class BocaExtension(BaseModel):\n    languages: typing.List[BocaLanguage] = list(typing.get_args(BocaLanguage))\n    flags: typing.Dict[BocaLanguage, str] = {}\n    maximumTimeError: float = _MAX_REP_ERROR\n    preferContestLetter: bool = False\n    usePypy: bool = False\n\n    def flags_with_defaults(self) -&gt; typing.Dict[BocaLanguage, str]:\n        res: typing.Dict[BocaLanguage, str] = {\n            'c': '-std=gnu11 -O2 -lm -static',\n            'cpp': '-O2 -lm -static',\n            'cc': '-std=c++20 -O2 -lm -static',\n        }\n        res.update(self.flags)\n        return res\n</code></pre>"},{"location":"setters/reference/environment/schema/#rbx.box.packaging.boca.extension.BocaLanguageExtension","title":"<code>BocaLanguageExtension</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>bocaLanguage</code> <code>str | None</code> <code>None</code> Source code in <code>rbx/box/packaging/boca/extension.py</code> <pre><code>class BocaLanguageExtension(BaseModel):\n    # BocaLanguage this rbx language matches with.\n    bocaLanguage: typing.Optional[str] = None\n</code></pre>"},{"location":"setters/reference/package/","title":"Problem package","text":"<p>This documentation goes over how each field (or group of fields) in <code>problem.rbx.yml</code> works.</p>"},{"location":"setters/reference/package/#problem-definition","title":"Problem definition","text":"<p>Schema: rbx.box.schema.Package</p> <p>The three main required fields in a <code>problem.rbx.yml</code> package are:</p> <ul> <li><code>name</code>: supports anything matching the regex <code>^[a-zA-Z0-9\\-]+$</code></li> <li><code>timeLimit</code>: the time limit of your problem, in milliseconds.</li> <li><code>memoryLimit</code>: the memory limit of your problem, in megabytes.</li> </ul> <p>A barebones package would look something like:</p> <pre><code>name: \"test-problem\"\ntimeLimit: 1000  # 1 second TL\nmemoryLimit: 256  # 256 MB ML\n</code></pre>"},{"location":"setters/reference/package/#language-modifiers","title":"Language Modifiers","text":"<p>You can add extra language-based limit modifiers to problems.</p> <pre><code>name: \"test-problem\"\ntimeLimit: 1000  # 1 second TL\nmemoryLimit: 256  # 256 MB ML\nmodifiers:\n  java:\n    time: 2000  # 2 second TL for Java\n    memory: 512  # 512 MB ML for Java\n</code></pre>"},{"location":"setters/reference/package/#task-type","title":"Task Type","text":"<p>Field: <code>type</code> Schema: rbx.box.schema.TaskType</p> <p>You can use this (optional) field to specify the type of your problem. If you're building an interactive problem, for instance, you should set this to <code>COMMUNICATION</code>, otherwise the default <code>BATCH</code> will be used.</p> <pre><code>name: \"interactive-problem\"\ntype: COMMUNICATION\ntimeLimit: 1000  # 1 second TL\nmemoryLimit: 256  # 256 MB ML\n</code></pre>"},{"location":"setters/reference/package/#variables","title":"Variables","text":"<p>Field: <code>vars</code> Schema: <code>Dict[str, Union[str, int, float, bool]]</code></p> <p>In the package definition you can define variables that can be referenced in statements, validators, checkers, interactors and stress tests.</p> <p>This is useful to maintain consistency when changing constraints of your problem. A common mistake this field tries to solve is changing constraints in the statement, but not updating them in the other components.</p> <pre><code>vars:\n  N:\n    max: 10000\n  A:\n    max: 100000\n  MOD: py`10**9+7` # Backticks force the var to be evaluated as a Python expression.\n</code></pre> <p>rbx automatically generates an <code>rbx.h</code> header file in the root of your package that you can include in your code to read these variables.</p> <pre><code>#include \"rbx.h\"\n\nint main() {\n  int MAX_N = getVar&lt;int&gt;(\"N.max\");\n  // Rest of your code...\n}\n</code></pre> <p>If you're not using C++ for your components, consider doing so as the rbx experience is tightly integrated with testlib.</p> <p>If not, you can still use the variables in validators, see the Validators section for more information.</p> <p>Warning</p> <p>Refrain from using variables in generators. Although it is tempting to use <code>rbx.h</code> in there, it is not recommended to do so.</p> <p>Read more on the Generators section.</p> <p>Note</p> <p>Variable names should be valid Python identifiers.</p>"},{"location":"setters/reference/package/#checker","title":"Checker","text":"<p>Field: <code>checker</code> Schema: rbx.box.schema.CodeItem</p> <p>Checkers are also a very important part of your problem package, and define how the output of a solution will be judged.</p> <p>The checker is controlled through the top-level parameter <code>checker</code>, and is optional. In the case it is not specified, rbx falls back to testlib's wcmp.cpp, which is a token-based checker that compares the output of the solution with the expected answer. In case of interactive problems, a checker is not required.</p> <p>rbx is tightly integrated with testlib, and thus you can either specify:</p> <ol> <li> <p>The name of any checker in defined in testlib's checkers folder. The checker will be automatically downloaded when running solutions and building the package.</p> <pre><code>checker:\n  path: \"yesno.cpp\"\n</code></pre> <p>Tip</p> <p>If you want to explicitly download a checker from testlib, you can run <code>rbx download checker [name-of-the-checker]</code>.</p> </li> <li> <p>A custom testlib-based checker of your own, placed in the folder (or any sub-folder) of your package.</p> <pre><code>checker:\n  path: \"my-testlib-based-checker.cpp\"\n</code></pre> <p>Tip</p> <p>rbx automatically places <code>testlib.h</code> together with your code when compiling it, but you can explicitly download it with <code>rbx download testlib</code> if you want.</p> <p>Recommended</p> <p>This is usually the recommended solution when building a custom checker, as rbx provides a clear integration with testlib and you can use include <code>rbx.h</code> in your checker to read variables.</p> </li> <li> <p>A custom checker (not necessarily using testlib). It can even be in other language, in which case we suggest specifying the <code>language</code> property.</p> <pre><code>checker:\n  path: \"my-custom-checker.py\"\n  language: \"python\"\n</code></pre> <p>Warning</p> <p>Currently, it is not possible to use variables in custom checkers not written in C++.</p> <p>Note</p> <p>Although this is not a testlib-based checker, we still expect checker programs to follow the same command line structure as testlib, which is receiving and reading three file paths from the command line.</p> <p>Thus, your checker program will be called as <code>&lt;program&gt; &lt;input-file&gt; &lt;output-file&gt; &lt;expected-answer-file&gt;</code>.</p> </li> </ol>"},{"location":"setters/reference/package/#interactor","title":"Interactor","text":"<p>Field: <code>interactor</code> Schema: rbx.box.schema.Interactor</p> <p>You can specify an interactor for your problem, or leave this field empty for non-interactive problems.</p> <pre><code>interactor:\n  path: \"my-interactor.cpp\"\n</code></pre> <p>According to the ICPC package specification, used by the ICPC World Finals, interactors cannot be specified together with a checker, and an error will be thrown if both are present.</p> <p>rbx enforces this rule, but supports interactive problems with a checker if you set the <code>legacy</code> flag in the interactor definition.</p> <pre><code>interactor:\n  path: \"my-interactor.cpp\"\n  legacy: true\n</code></pre> <p>Danger</p> <p>rbx currently only supports testlib-based interactors. If you do not use a testlib-based interactor, rbx will not complain but might behave unexpectedly.</p> <p>Warning</p> <p>Notice that a few judges do not support interactors with a checker, and an error will be thrown if you try to build a package for an unsupported judge with both components specified.</p>"},{"location":"setters/reference/package/#generators","title":"Generators","text":"<p>Field: <code>generators</code> Schema: <code>List[</code><code>Generator</code><code>]</code></p> <p>You can also specify a set of testcase generators that can be re-used in different places in your package (testgroup generation, stress tests to name a couple).</p> <p>Again, we encourage the use of testlib-based generators, but give you the flexibility to develop however you like.</p> <p>After implementing a generator, you can define it in <code>problem.rbx.yml</code> similar to how you define a checker, but you also have to name it to be able to reference it down the line.</p> <pre><code>generators:\n  - name: \"gen\"\n    path: \"my-gen.cpp\"\n</code></pre> <p>Notice also how the <code>generators</code> field is a list, and as such you can define multiple generators.</p> <p>Danger</p> <p>Refrain from using Variables in generators. Although it is tempting to depend on them, it is not a good practice.</p> <p>This will make your generator sensible to the changes you make to the <code>vars</code> field, meaning if you found a testcase that breaks a specific solution, but it depends on a <code>vars</code> entry and you change it, you might end up with a totally different test. Instead, you should be able to describe all your generator parameters through static variables.</p>"},{"location":"setters/reference/package/#solutions","title":"Solutions","text":"<p>Field: <code>solutions</code> Schema: <code>List[</code><code>Solution</code><code>]</code></p> <p>You can specify multiple solutions to your problem, including incorrect ones to check that your testset is strong enough.</p> <p>You can define them similarly to generators and checkers, but you also have to provide an expected outcome for them.</p> <pre><code>solutions:\n  - path: \"sols/main.cpp\"\n    outcome: accepted\n  - path: \"sols/slow.cpp\"\n    outcome: tle\n  - path: \"sols/wa.cpp\"\n    outcome: wa\n</code></pre> <p>Also, you have to define an accepted solution. The first accepted solution in this list will be considered the main solution to generate answers for the testcases.</p> <p>For a full list of expected outcomes, see here.</p>"},{"location":"setters/reference/package/#testcase-groups","title":"Testcase groups","text":"<p>Field: <code>testcases</code> Schema: <code>List[</code><code>TestcaseGroup</code><code>]</code></p> <p>You can define multiple testgroups for you problem. For each testgroup, you can define tests for it in five (5) different ways:</p> <ol> <li> <p>Specifying a sequence of manually defined testcases present in your package's directory with the <code>testcases</code> field.</p> <pre><code>testcases:\n  - name: \"group-1\"\n    testcases:\n      - inputPath: \"manual-tests/1.in\"\n        outputPath: \"manual-tests/1.ans\"\n      - inputPath: \"manual-tests/1.in\"\n</code></pre> <p>Note</p> <p>Notice how the <code>outputPath</code> is optional. If it is not defined, the main solution will be used to generate an output. This is the recommended approach.</p> </li> <li> <p>Specifying a glob of input paths with the <code>testcaseGlob</code> field.</p> <pre><code>testcases:\n  - name: \"group-1\"\n    testcaseGlob: \"tests/*.in\" # (1)!\n</code></pre> <ol> <li>Pick all files ending in <code>.in</code> inside the <code>tests/</code> folder as test inputs for     the testgroup. The files are taken in lexicographically increasing order.</li> </ol> </li> <li> <p>Specifying a list of generator calls with the <code>generators</code> field.</p> <pre><code>testcases:\n  - name: \"generated\"\n    generators:\n      - name: \"gen1\"\n        args: \"1000 30\"\n      - name: \"gen1\"\n        args: \"1000 42\"\n</code></pre> </li> <li> <p>Specifying a static generator script with the <code>generatorScript</code> field:</p> problem.rbx.ymlscript.txt <pre><code>testcases:\n  - name: \"generated\"\n    generatorScript:\n      path: \"script.txt\"\n</code></pre> <pre><code>gen 1000 30\ngen 1000 42\n# ...other tests\n</code></pre> <p>Note</p> <p>The <code>.txt</code> extension is necessary for rbx to identify this is a static script.</p> <p>Recommended</p> <p>This is usually the recommended approach to generate a few pre-defined testcases. Prefer this over the <code>generators</code> call to keep <code>problem.rbx.yml</code> cleaner.</p> </li> <li> <p>Specifying a dynamic generator script with the <code>generatorScript</code> field:</p> problem.rbx.ymlscript.py <pre><code>testcases:\n  - name: \"generated\"\n    generatorScript:\n      path: \"script.py\"\n</code></pre> <pre><code># Generates 10 different cases with different parameters.\nfor i in range(10):\n  print(f'gen 1000 {i}')\n</code></pre> <p>Recommended</p> <p>This is usually the recommended approach to generate multiple random testcases.</p> </li> </ol> <p>Warning</p> <p>If the platform you package the problem for does not support testgroups, tests will be flattened into a single group, and the tests will be executed in the order the groups were defined.</p>"},{"location":"setters/reference/package/#samples","title":"Samples","text":"<p>You can also specify samples to be included in your statement by defining a testgroup named <code>samples</code>. This testgroup has to be the first one defined, otherwise an error will be raised.</p>"},{"location":"setters/reference/package/#validators","title":"Validators","text":"<p>Field: <code>validator</code>, <code>testcases.validator</code> Schema: rbx.box.schema.CodeItem</p> <p>You can specify testlib validators that check whether both manual and generated testcases are in the correct format.</p> <p>You can specify validators in two places:</p> <ol> <li> <p>In the package definition, through the <code>validator</code> field.</p> <pre><code>validator:\n  path: \"validator.cpp\"\n</code></pre> </li> <li> <p>In the testgroup definition, through the <code>validator</code> field, in which case this validator will be executed only for this group, and the package one will be ignored.</p> <pre><code>validator:\n  path: \"validator.cpp\"\ntestcases:\n  - name: \"group-with-usual-constraints\"\n    # ...other testgroup definitions\n  - name: \"group-with-different-constraints\"\n    # ...other testgroup definitions\n    validator:\n      path: \"validator-alternative.cpp\"\n</code></pre> </li> </ol> <p>You can pass variables to validators in two different ways.</p> <ol> <li> <p>(C++ only) Include the <code>rbx.h</code> header and using the <code>getVar</code> accessor.</p> <pre><code>#include \"testlib.h\"\n#include \"rbx.h\"\n\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n\n    int MAX_N = getVar&lt;int&gt;(\"N.max\"); // Read from package vars.\n\n    inf.readInt(1, MAX_N, \"N\");\n    inf.readEoln();\n    inf.readEof();\n}\n</code></pre> <p>This header is automatically generated at your problem's root directory by rbx.</p> <p>Recommended</p> <p>This is the recommended approach of passing variables to validators.</p> </li> <li> <p>Read the variables from the command line.</p> <p>rbx passes all the variables defined in the <code>vars</code> section to the validator through <code>--{name}={value}</code> parameters. You are responsible for writing code to parse them.</p> <pre><code>import sys\n\nvariables = {}\n\nfor arg in sys.argv[1:]:\n  if arg.startswith('--') and '=' in arg:\n    name, value = arg[2:].split('=', 1)\n    variables[name] = value\n\n# Use variables...\n</code></pre> </li> </ol>"},{"location":"setters/reference/package/#extra-validators","title":"Extra validators","text":"<p>You can also specify extra validators to be used in your testcases, both at the problem-level and testgroup-level.</p> <pre><code>validator:\n  path: \"validator.cpp\"\ntestcases:\n  - name: \"group-1\"\n    # ...other testgroup definitions\n  - name: \"group-2-without-solution\"\n    # a group whose testcases don't have a solution\n    extraValidators:\n      - path: \"validator-no-solution.cpp\"\n</code></pre>"},{"location":"setters/reference/package/#stress-tests","title":"Stress tests","text":"<p>Field: <code>stresses</code> Schema: <code>List[</code><code>Stress</code><code>]</code></p> <p>You can pre-define stress tests with a few applications in mind, such as:</p> <ul> <li>Finding testcases that break incorrect solutions;</li> <li>Ensuring solutions you expect to be correct cannot be broken.</li> </ul> <p>Let's break down each field in the stress test below:</p> <pre><code>stresses:\n  - name: \"stress1\"\n    generator:\n      name: \"gen\"\n      args: \"--N.max=[1..1000] @\"\n    finder: \"[sols/wa.cpp] ~ INCORRECT\"\n</code></pre> <ul> <li><code>name</code>: a name for the stress test. Useful when calling this test through <code>rbx stress [name]</code>.</li> <li><code>generator</code>: a generator expression to be repeatedly evaluated in this stress test.</li> <li><code>name</code>: the name of the generator</li> <li><code>args</code>: args pattern to be passed to generator.<ul> <li>You can pass a random integer by writing something like <code>[1..1000]</code>.</li> <li>You can pass variables defined in the <code>vars</code> section with something like <code>&lt;N.max&gt;</code>.</li> <li>You can pass a random choice by writing something like <code>(a|b|c)</code>.</li> <li>You can pass a random hex string by passing <code>@</code>.</li> </ul> </li> <li><code>finder</code>: a finder expression that, when evaluated to true, consider the given generated test as a match</li> </ul>"},{"location":"setters/reference/package/#unit-tests","title":"Unit tests","text":"<p>Field: <code>unitTests</code> Schema: <code>UnitTests</code></p> <p>You can specify unit tests for your validator and your checker through the <code>unitTests</code> field.</p> <pre><code>unitTests:\n  validator:\n    - glob: \"unit/validator/valid_*.in\"  # (1)!\n      outcome: VALID\n    - glob: \"unit/validator/invalid_*.in\"  # (2)!\n      outcome: INVALID\n  checker: \n    - glob: \"unit/checker/ac*\"  # (3)!\n      outcome: ACCEPTED\n    - glob: \"unit/checker/wa*\"\n      outcome: WRONG_ANSWER\n</code></pre> <ol> <li> <p>Specify a glob to match manually crafted input files that when validated should be considered valid.</p> </li> <li> <p>Specify a glob to match manually crafted input files that when validated should be considered INVALID.</p> </li> <li> <p>Specify a glob to match files named <code>unit/checker/ac*(.in|.out|.ans)</code> that when checked should be considered ACCEPTED.</p> </li> </ol> <p>Validator globs are really simple: they should match <code>.in</code> files relative to the problem root directory. Those files will be passed to the validator program and validated.</p> <p>Checker globs are a bit more complex, since they accept three different parameters:</p> <ul> <li>A <code>.in</code> file, the input for the testcase;</li> <li>A <code>.out</code> file, the output of the participant's program;</li> <li>A <code>.ans</code> file, the output of the main solution.</li> </ul> <p>Thus, to test a checker, you should provide a subset of these three (3) files. The checker unit test definition expects a glob that matches the names of these three files. Thus, the glob <code>unit/checker/ac*</code> will match, for instance, <code>unit/checker/ac.in</code>, <code>unit/checker/ac.out</code> and <code>unit/checker/ac.ans</code>.</p> <p>Not all three files must exist, only those required by the checker.</p>"},{"location":"setters/reference/package/schema/","title":"Problem schema","text":""},{"location":"setters/reference/package/schema/#problemrbxyml","title":"<code>problem.rbx.yml</code>","text":""},{"location":"setters/reference/package/schema/#rbx.box.schema.Checker","title":"<code>Checker</code>","text":"<p>               Bases: <code>CodeItem</code></p> <p>Parameters:</p> Name Type Description Default <code>fallback_to</code> <code>Checker | None</code> <p>Checker to fall back to if the mainly specified checker does not exist.</p> <code>None</code> <code>mode</code> <code>Literal['testlib', 'boca']</code> <p>In which compatibility mode the checker should be run.</p> <code>'testlib'</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class Checker(CodeItem):\n    model_config = ConfigDict(extra='forbid')\n\n    fallback_to: Optional[Checker] = Field(\n        default=None,\n        description=\"\"\"Checker to fall back to if the mainly specified checker does not exist.\"\"\",\n    )\n\n    mode: Literal['testlib', 'boca'] = Field(\n        default='testlib',\n        description=\"\"\"In which compatibility mode the checker should be run.\"\"\",\n    )\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.CheckerTest","title":"<code>CheckerTest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>glob</code> <code>str | None</code> <p>A glob pattern for the files to be used as unit test input for the checker.</p> <code>None</code> <code>testplan</code> <code>Path | None</code> <p>A testplan to be used as unit test input for the checker.</p> <code>None</code> <code>outcome</code> <code>ExpectedOutcome | None</code> <p>The expected outcome of the checker.</p> <code>None</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class CheckerTest(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    glob: Optional[str] = Field(\n        default=None,\n        description='A glob pattern for the files to be used as unit test input for the checker.',\n    )\n\n    testplan: Optional[pathlib.Path] = Field(\n        default=None,\n        description='A testplan to be used as unit test input for the checker.',\n    )\n\n    outcome: Optional[ExpectedOutcome] = Field(\n        default=None,\n        description='The expected outcome of the checker.',\n    )\n\n    @model_validator(mode='after')\n    def check_oneof(self):\n        if self.glob is None and self.testplan is None:\n            raise PydanticCustomError(\n                'GLOB_OR_TESTPLAN_REQUIRED',\n                'Either a glob or a testplan must be specified.',\n            )\n        if self.glob is not None and self.testplan is not None:\n            raise PydanticCustomError(\n                'GLOB_AND_TESTPLAN_NOT_ALLOWED',\n                'Either a glob or a testplan must be specified, but not both.',\n            )\n        return self\n\n    @model_validator(mode='after')\n    def check_testplan(self):\n        if self.testplan is not None and self.outcome is not None:\n            raise PydanticCustomError(\n                'OUTCOME_NOT_ALLOWED',\n                'Outcome is not allowed for testplan checker tests.',\n            )\n        return self\n\n    @model_validator(mode='after')\n    def check_glob(self):\n        if self.glob is not None and self.outcome is None:\n            raise PydanticCustomError(\n                'OUTCOME_REQUIRED',\n                'Outcome is required for glob checker tests.',\n            )\n        return self\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.CodeItem","title":"<code>CodeItem</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the code file, relative to the package directory.</p> required <code>language</code> <code>str | None</code> <p>The language of the code file.</p> <code>None</code> <code>compilationFiles</code> <code>List[str] | None</code> <p>Extra files that should be placed alongside the code file during its compilation, such as testlib.h, jngen.h, etc.</p> <p>The paths should be given relative to the package directory, but will be included relative to the <code>path</code> directory.</p> <p>Testlib and jngen are already included by default.</p> <code>[]</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class CodeItem(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    path: pathlib.Path = Field(\n        description=\"\"\"The path to the code file, relative to the package directory.\"\"\"\n    )\n\n    language: Optional[str] = Field(\n        default=None, description=\"\"\"The language of the code file.\"\"\"\n    )\n\n    compilationFiles: Optional[List[str]] = Field(\n        default=[],\n        description=\"\"\"\nExtra files that should be placed alongside the code file during its compilation,\nsuch as testlib.h, jngen.h, etc.\n\nThe paths should be given relative to the package directory, but will be included\nrelative to the `path` directory.\n\nTestlib and jngen are already included by default.\n\"\"\",\n    )\n\n    def href(self, hyperlink: bool = True) -&gt; str:\n        return href(self.path, hyperlink=hyperlink)\n\n    def display(self) -&gt; str:\n        return self.href(hyperlink=False)\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.CodeItemWithDigest","title":"<code>CodeItemWithDigest</code>","text":"<p>               Bases: <code>CodeItem</code></p> <p>Parameters:</p> Name Type Description Default <code>digest</code> <code>str</code> <p>The digest of the code file.</p> required Source code in <code>rbx/box/schema.py</code> <pre><code>class CodeItemWithDigest(CodeItem):\n    model_config = ConfigDict(extra='forbid')\n\n    digest: str = Field(description=\"\"\"The digest of the code file.\"\"\")\n\n    @classmethod\n    def create(cls, code_item: CodeItem, digest: str) -&gt; 'CodeItemWithDigest':\n        return cls(\n            path=code_item.path,\n            language=code_item.language,\n            compilationFiles=code_item.compilationFiles,\n            digest=digest,\n        )\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome","title":"<code>ExpectedOutcome</code>","text":"<p>               Bases: <code>AutoEnum</code></p> Source code in <code>rbx/box/schema.py</code> <pre><code>class ExpectedOutcome(AutoEnum):\n    ANY = alias('any')  # type: ignore\n    \"\"\"Expected outcome for any outcome.\"\"\"\n\n    ACCEPTED = alias('accepted', 'ac', 'correct')  # type: ignore\n    \"\"\"Expected outcome for correct solutions (AC).\"\"\"\n\n    ACCEPTED_OR_TLE = alias(\n        'accepted or time limit exceeded',  # type: ignore\n        'accepted or tle',\n        'ac or tle',\n        'ac/tle',\n        'ac+tle',\n    )  # type: ignore\n    \"\"\"Expected outcome for solutions that finish with either AC or TLE.\n\n    Especially useful when you do not care about the running time of this solution, and\n    want it to not be considered when calculating the timelimit for the problem.\"\"\"\n\n    WRONG_ANSWER = alias('wrong answer', 'wa')  # type: ignore\n    \"\"\"Expected outcome for solutions that finish successfully,\n    but the produced output are incorrect (WA).\"\"\"\n\n    INCORRECT = alias('fail', 'incorrect')  # type: ignore\n    \"\"\"Expected outcome for solutions that finish with any non-AC verdict.\"\"\"\n\n    RUNTIME_ERROR = alias('runtime error', 'rte', 're')  # type: ignore\n    \"\"\"Expected outcome solutions that finish with non-zero code (RTE).\"\"\"\n\n    TIME_LIMIT_EXCEEDED = alias('time limit exceeded', 'timeout', 'tle', 'tl')  # type: ignore\n    \"\"\"Expected outcome for solutions that do not finish in time.\"\"\"\n\n    MEMORY_LIMIT_EXCEEDED = alias('memory limit exceeded', 'mle', 'ml')  # type: ignore\n    \"\"\"Expected outcome for solutions that use more memory than allowed.\"\"\"\n\n    OUTPUT_LIMIT_EXCEEDED = alias('output limit exceeded', 'ole', 'ol')  # type: ignore\n    \"\"\"Expected outcome for solutions that use more output than allowed.\"\"\"\n\n    TLE_OR_RTE = alias('tle or rte', 'tle/rte', 'tle+rte', 'tle or re', 'tle+re')  # type: ignore\n    \"\"\"Expected outcome for solutions that finish with either TLE or RTE.\n\n    Especially useful for environments where TLE and RTE are indistinguishable.\"\"\"\n\n    JUDGE_FAILED = alias('judge failed', 'jf')  # type: ignore\n    \"\"\"Expected outcome for solutions that finish with a judge failed verdict.\n\n    Only useful for checker tests.\"\"\"\n\n    COMPILATION_ERROR = alias('compilation error', 'ce')  # type: ignore\n    \"\"\"Expected outcome for solutions that finish with a compilation error verdict.\n\n    Only useful for checker tests.\"\"\"\n\n    def style(self) -&gt; str:\n        if self == ExpectedOutcome.ANY:\n            return 'orange'\n        if self.match(Outcome.ACCEPTED):\n            return 'green'\n        if self == ExpectedOutcome.WRONG_ANSWER:\n            return 'red'\n        if self == ExpectedOutcome.INCORRECT:\n            return 'red'\n        if self.match(Outcome.TIME_LIMIT_EXCEEDED):\n            return 'yellow'\n        if self.match(Outcome.RUNTIME_ERROR):\n            return 'blue'\n        if self.match(Outcome.MEMORY_LIMIT_EXCEEDED):\n            return 'yellow'\n        if self.match(Outcome.COMPILATION_ERROR):\n            return 'blue'\n        return 'magenta'\n\n    def icon(self) -&gt; str:\n        if self == ExpectedOutcome.ANY:\n            return '?'\n        if self.match(Outcome.ACCEPTED):\n            return '\u2713'\n        if self.is_slow():\n            return '\u29d6'\n        return '\u2717'\n\n    def icon_markup(self, styled: bool = True) -&gt; str:\n        icon = self.icon()\n        if styled:\n            style = self.style()\n            icon = f'[{style}]{icon}[/{style}]'\n        return icon\n\n    def full_style(self) -&gt; str:\n        style = self.style()\n        if self == ExpectedOutcome.ACCEPTED:\n            return f'bold {style}'\n        return style\n\n    def full_markup(self, styled: bool = True) -&gt; str:\n        icon = self.icon_markup()\n        name = self.name\n        if styled:\n            style = self.style()\n            name = f'[{style}]{name}[/{style}]'\n        return f'{icon} {name}'\n\n    def is_slow(self) -&gt; bool:\n        return self in [ExpectedOutcome.TIME_LIMIT_EXCEEDED, ExpectedOutcome.TLE_OR_RTE]\n\n    def matches_tle_and_is_incorrect(self) -&gt; bool:\n        return self.match(Outcome.TIME_LIMIT_EXCEEDED) and not self.match(\n            Outcome.ACCEPTED\n        )\n\n    def match(self, outcome: Outcome) -&gt; bool:\n        if self == ExpectedOutcome.ANY:\n            return True\n        if self == ExpectedOutcome.COMPILATION_ERROR:\n            return outcome == Outcome.COMPILATION_ERROR\n        if self == ExpectedOutcome.ACCEPTED:\n            return outcome == Outcome.ACCEPTED\n        if self == ExpectedOutcome.ACCEPTED_OR_TLE:\n            return outcome in {Outcome.ACCEPTED} or outcome.is_slow()\n        if self == ExpectedOutcome.WRONG_ANSWER:\n            return outcome == Outcome.WRONG_ANSWER\n        if self == ExpectedOutcome.INCORRECT:\n            return (\n                outcome\n                in {\n                    Outcome.WRONG_ANSWER,\n                    Outcome.RUNTIME_ERROR,\n                    Outcome.MEMORY_LIMIT_EXCEEDED,\n                    Outcome.OUTPUT_LIMIT_EXCEEDED,\n                }\n                or outcome.is_slow()\n            )\n        if self == ExpectedOutcome.RUNTIME_ERROR:\n            return outcome == Outcome.RUNTIME_ERROR\n        if self == ExpectedOutcome.TIME_LIMIT_EXCEEDED:\n            return outcome.is_slow()\n        if self == ExpectedOutcome.MEMORY_LIMIT_EXCEEDED:\n            return outcome == Outcome.MEMORY_LIMIT_EXCEEDED\n        if self == ExpectedOutcome.TLE_OR_RTE:\n            return outcome in {Outcome.RUNTIME_ERROR} or outcome.is_slow()\n        if self == ExpectedOutcome.OUTPUT_LIMIT_EXCEEDED:\n            return outcome == Outcome.OUTPUT_LIMIT_EXCEEDED\n        if self == ExpectedOutcome.JUDGE_FAILED:\n            return outcome == Outcome.JUDGE_FAILED\n        return False\n\n    def get_matches(self) -&gt; List[Outcome]:\n        return [outcome for outcome in Outcome if self.match(outcome)]\n\n    def intersect(self, rhs: 'ExpectedOutcome') -&gt; bool:\n        return bool(set(self.get_matches()) &amp; set(rhs.get_matches()))\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome.ACCEPTED","title":"<code>ACCEPTED = alias('accepted', 'ac', 'correct')</code>","text":"<p>Expected outcome for correct solutions (AC).</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome.ACCEPTED_OR_TLE","title":"<code>ACCEPTED_OR_TLE = alias('accepted or time limit exceeded', 'accepted or tle', 'ac or tle', 'ac/tle', 'ac+tle')</code>","text":"<p>Expected outcome for solutions that finish with either AC or TLE.</p> <p>Especially useful when you do not care about the running time of this solution, and want it to not be considered when calculating the timelimit for the problem.</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome.ANY","title":"<code>ANY = alias('any')</code>","text":"<p>Expected outcome for any outcome.</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome.COMPILATION_ERROR","title":"<code>COMPILATION_ERROR = alias('compilation error', 'ce')</code>","text":"<p>Expected outcome for solutions that finish with a compilation error verdict.</p> <p>Only useful for checker tests.</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome.INCORRECT","title":"<code>INCORRECT = alias('fail', 'incorrect')</code>","text":"<p>Expected outcome for solutions that finish with any non-AC verdict.</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome.JUDGE_FAILED","title":"<code>JUDGE_FAILED = alias('judge failed', 'jf')</code>","text":"<p>Expected outcome for solutions that finish with a judge failed verdict.</p> <p>Only useful for checker tests.</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome.MEMORY_LIMIT_EXCEEDED","title":"<code>MEMORY_LIMIT_EXCEEDED = alias('memory limit exceeded', 'mle', 'ml')</code>","text":"<p>Expected outcome for solutions that use more memory than allowed.</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome.OUTPUT_LIMIT_EXCEEDED","title":"<code>OUTPUT_LIMIT_EXCEEDED = alias('output limit exceeded', 'ole', 'ol')</code>","text":"<p>Expected outcome for solutions that use more output than allowed.</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome.RUNTIME_ERROR","title":"<code>RUNTIME_ERROR = alias('runtime error', 'rte', 're')</code>","text":"<p>Expected outcome solutions that finish with non-zero code (RTE).</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome.TIME_LIMIT_EXCEEDED","title":"<code>TIME_LIMIT_EXCEEDED = alias('time limit exceeded', 'timeout', 'tle', 'tl')</code>","text":"<p>Expected outcome for solutions that do not finish in time.</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome.TLE_OR_RTE","title":"<code>TLE_OR_RTE = alias('tle or rte', 'tle/rte', 'tle+rte', 'tle or re', 'tle+re')</code>","text":"<p>Expected outcome for solutions that finish with either TLE or RTE.</p> <p>Especially useful for environments where TLE and RTE are indistinguishable.</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome.WRONG_ANSWER","title":"<code>WRONG_ANSWER = alias('wrong answer', 'wa')</code>","text":"<p>Expected outcome for solutions that finish successfully, but the produced output are incorrect (WA).</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.Generator","title":"<code>Generator</code>","text":"<p>               Bases: <code>CodeItem</code></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the generator.</p> required Source code in <code>rbx/box/schema.py</code> <pre><code>class Generator(CodeItem):\n    model_config = ConfigDict(extra='forbid')\n\n    name: str = Field(description=\"\"\"The name of the generator.\"\"\")\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.GeneratorCall","title":"<code>GeneratorCall</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the generator to call.</p> required <code>args</code> <code>str | None</code> <p>The arguments to pass to the generator.</p> <code>None</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class GeneratorCall(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    name: str = Field(description='The name of the generator to call.')\n\n    args: Optional[str] = Field(\n        default=None, description='The arguments to pass to the generator.'\n    )\n\n    def __str__(self) -&gt; str:\n        return f'{self.name} {self.args}'\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.GeneratorScript","title":"<code>GeneratorScript</code>","text":"<p>               Bases: <code>CodeItem</code></p> <p>Parameters:</p> Name Type Description Default <code>root</code> <code>Path</code> <p>The root directory where the generators should be fetched from.</p> <code>&lt;dynamic&gt;</code> <code>format</code> <code>Literal['rbx', 'box']</code> <p>The format of the generator script.</p> <code>'rbx'</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class GeneratorScript(CodeItem):\n    model_config = ConfigDict(extra='forbid')\n\n    root: pathlib.Path = Field(\n        default_factory=pathlib.Path,\n        description=\"\"\"The root directory where the generators should be fetched from.\"\"\",\n    )\n\n    format: Literal['rbx', 'box'] = Field(\n        default='rbx', description=\"\"\"The format of the generator script.\"\"\"\n    )\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.Interactor","title":"<code>Interactor</code>","text":"<p>               Bases: <code>CodeItem</code></p> <p>Parameters:</p> Name Type Description Default <code>legacy</code> <code>bool</code> <p>Whether this interactor is a legacy interactor and needs a checker to be specified.</p> <code>False</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class Interactor(CodeItem):\n    model_config = ConfigDict(extra='forbid')\n\n    legacy: bool = Field(\n        default=False,\n        description=\"\"\"\nWhether this interactor is a legacy interactor and needs a checker to be specified.\n\"\"\",\n    )\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.LimitModifiers","title":"<code>LimitModifiers</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>timeMultiplier</code> <code>float | None</code> <p>Multiplier for time limit.</p> <code>None</code> <code>time</code> <code>int | None</code> <p>Value to override time limit with, in milliseconds.</p> <code>None</code> <code>memory</code> <code>int | None</code> <p>Value to override memory limit with, in MB.</p> <code>None</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class LimitModifiers(BaseModel):\n    timeMultiplier: Optional[float] = Field(\n        default=None, description='Multiplier for time limit.'\n    )\n    time: Optional[int] = Field(\n        default=None, description='Value to override time limit with, in milliseconds.'\n    )\n    memory: Optional[int] = Field(\n        default=None, description='Value to override memory limit with, in MB.'\n    )\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.LimitsProfile","title":"<code>LimitsProfile</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>inheritFromPackage</code> <code>bool</code> <p>Whether to inherit limits from the package.</p> <code>False</code> <code>timeLimit</code> <code>int | None</code> <p>Time limit of the problem, in milliseconds.</p> <code>None</code> <code>memoryLimit</code> <code>int | None</code> <p>Memory limit of the problem, in MB.</p> <code>None</code> <code>outputLimit</code> <code>int | None</code> <p>Output limit of the problem, in KB.</p> <code>None</code> <code>modifiers</code> <code>Dict[str, LimitModifiers]</code> <p>Limit modifiers that can be specified per language.</p> <code>{}</code> <code>formula</code> <code>str | None</code> <p>A formula to estimate the time limit for the problem.</p> <code>None</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class LimitsProfile(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    inheritFromPackage: bool = Field(\n        default=False,\n        description=\"\"\"\nWhether to inherit limits from the package.\n\"\"\",\n    )\n\n    timeLimit: Optional[int] = Field(\n        default=None, description='Time limit of the problem, in milliseconds.'\n    )\n\n    memoryLimit: Optional[int] = Field(\n        default=None, description='Memory limit of the problem, in MB.'\n    )\n\n    outputLimit: Optional[int] = Field(\n        default=None, description='Output limit of the problem, in KB.'\n    )\n\n    modifiers: Dict[str, LimitModifiers] = Field(\n        default={},\n        description=\"\"\"\n    Limit modifiers that can be specified per language.\n    \"\"\",\n    )\n\n    formula: Optional[str] = Field(\n        default=None,\n        description=\"\"\"\nA formula to estimate the time limit for the problem.\n\"\"\",\n    )\n\n    def timelimit_for_language(self, language: Optional[str] = None) -&gt; int:\n        assert self.timeLimit is not None\n        res = self.timeLimit\n        if language is not None and language in self.modifiers:\n            modifier = self.modifiers[language]\n            if modifier.time is not None:\n                res = modifier.time\n            if modifier.timeMultiplier is not None:\n                res = int(res * float(modifier.timeMultiplier))\n        if 'RBX_TIME_MULTIPLIER' in utils.environ():\n            res = int(res * float(utils.environ()['RBX_TIME_MULTIPLIER']))\n        return res\n\n    def memorylimit_for_language(self, language: Optional[str] = None) -&gt; int:\n        assert self.memoryLimit is not None\n        res = self.memoryLimit\n        if language is None:\n            return res\n        if language not in self.modifiers:\n            return res\n        modifier = self.modifiers[language]\n        if modifier.memory is not None:\n            return modifier.memory\n        return res\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.OutputFromItem","title":"<code>OutputFromItem</code>","text":"<p>               Bases: <code>CodeItem</code></p> <p>Parameters:</p> Name Type Description Default <code>stderr</code> <code>bool</code> <p>Whether the output should be taken from stderr instead of the stdout.</p> <code>False</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class OutputFromItem(CodeItem):\n    model_config = ConfigDict(extra='forbid')\n\n    stderr: bool = Field(\n        default=False,\n        description=\"\"\"Whether the output should be taken from stderr instead of the stdout.\"\"\",\n    )\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.OutputFromItemWithDigest","title":"<code>OutputFromItemWithDigest</code>","text":"<p>               Bases: <code>OutputFromItem</code>, <code>CodeItemWithDigest</code></p> Source code in <code>rbx/box/schema.py</code> <pre><code>class OutputFromItemWithDigest(OutputFromItem, CodeItemWithDigest):\n    model_config = ConfigDict(extra='forbid')\n\n    @classmethod\n    def create(\n        cls, output_from_item: OutputFromItem, digest: str\n    ) -&gt; 'OutputFromItemWithDigest':\n        return cls(\n            path=output_from_item.path,\n            language=output_from_item.language,\n            compilationFiles=output_from_item.compilationFiles,\n            digest=digest,\n        )\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.Package","title":"<code>Package</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the problem.</p> required <code>titles</code> <code>Dict[str, str]</code> <p>Titles for the problem in each language. Languages should be specified as lowercase ISO 639-1 codes.</p> <code>{}</code> <code>type</code> <code>TaskType</code> <p>The type of the problem.</p> <code>BATCH</code> <code>scoring</code> <code>ScoreType</code> <p>The scoring type of the problem.</p> <code>BINARY</code> <code>timeLimit</code> <code>int</code> <p>Time limit of the problem, in milliseconds.</p> required <code>memoryLimit</code> <code>int</code> <p>Memory limit of the problem, in MB.</p> required <code>outputLimit</code> <code>int</code> <p>Output limit of the problem, in KB.</p> <code>4096</code> <code>modifiers</code> <code>Dict[str, LimitModifiers]</code> <p>Limit modifiers that can be specified per language.</p> <code>{}</code> <code>checker</code> <code>Checker | None</code> <p>The checker for this problem.</p> <code>None</code> <code>interactor</code> <code>Interactor | None</code> <p>The interactor for this problem.</p> <code>None</code> <code>validator</code> <code>CodeItem | None</code> <p>The validator for this problem.</p> <code>None</code> <code>extraValidators</code> <code>List[CodeItem]</code> <p>Extra validators for this problem.</p> <code>[]</code> <code>outputValidators</code> <code>List[CodeItem]</code> <p>A list of output validators to use to validate the output of the testcases of this problem.</p> <code>[]</code> <code>visualizer</code> <code>Visualizer | None</code> <p>The visualizer for this problem. Used to produced visualizations for the testcases.</p> <code>None</code> <code>solutionVisualizer</code> <code>Visualizer | None</code> <p>The solution visualizer for this problem. Used to produced visualizations for the outputs of the testcases.</p> <code>None</code> <code>generators</code> <code>List[Generator]</code> <p>Generators for this problem.</p> <code>[]</code> <code>solutions</code> <code>List[Solution]</code> <p>All tested solutions for this problem.</p> <p>The first solution in this list should be the main solution -- the one that is correct and used as reference -- and should have the <code>accepted</code> outcome.</p> <code>[]</code> <code>testcases</code> <code>List[TestcaseGroup]</code> <p>Testcases for the problem.</p> <code>[]</code> <code>stresses</code> <code>List[Stress]</code> <p>Stress tests for the problem.</p> <code>[]</code> <code>statements</code> <code>List[Statement]</code> <p>Statements for the problem.</p> <code>[]</code> <code>vars</code> <code>TypeAliasType</code> <p>Variables to be re-used across the package.</p> <code>{}</code> <code>unitTests</code> <code>UnitTests</code> <p>Unit tests for components of this problem.</p> <code>&lt;dynamic&gt;</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class Package(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    # Name of the problem.\n    name: str = NameField(description='The name of the problem.')\n\n    titles: Dict[str, str] = Field(\n        default={},\n        description='Titles for the problem in each language. '\n        'Languages should be specified as lowercase ISO 639-1 codes.',\n    )\n\n    type: TaskType = Field(\n        default=TaskType.BATCH, description='The type of the problem.'\n    )\n\n    scoring: ScoreType = Field(\n        default=ScoreType.BINARY, description='The scoring type of the problem.'\n    )\n\n    timeLimit: int = Field(description='Time limit of the problem, in milliseconds.')\n\n    memoryLimit: int = Field(description='Memory limit of the problem, in MB.')\n\n    outputLimit: int = Field(\n        default=4 * 1024, description='Output limit of the problem, in KB.'\n    )\n\n    modifiers: Dict[str, LimitModifiers] = Field(\n        default={},\n        description=\"\"\"\n    Limit modifiers that can be specified per language.\n    \"\"\",\n    )\n\n    checker: Optional[Checker] = Field(\n        default=None, description='The checker for this problem.'\n    )\n\n    interactor: Optional[Interactor] = Field(\n        default=None, description='The interactor for this problem.'\n    )\n\n    validator: Optional[CodeItem] = Field(\n        default=None, description='The validator for this problem.'\n    )\n\n    extraValidators: List[CodeItem] = Field(\n        default=[], description='Extra validators for this problem.'\n    )\n\n    outputValidators: List[CodeItem] = Field(\n        default=[],\n        description=\"\"\"\nA list of output validators to use to validate the output of the testcases of this problem.\n\"\"\",\n    )\n\n    visualizer: Optional[Visualizer] = Field(\n        default=None,\n        description='The visualizer for this problem. Used to produced visualizations for the testcases.',\n    )\n\n    solutionVisualizer: Optional[Visualizer] = Field(\n        default=None,\n        description='The solution visualizer for this problem. Used to produced visualizations for the outputs of the testcases.',\n    )\n\n    generators: List[Generator] = Field(\n        default=[], description='Generators for this problem.'\n    )\n\n    solutions: List[Solution] = Field(\n        default=[],\n        description=\"\"\"\nAll tested solutions for this problem.\n\nThe first solution in this list should be the main solution -- the one\nthat is correct and used as reference -- and should have the `accepted` outcome.\n\"\"\",\n    )\n\n    testcases: List[TestcaseGroup] = Field(\n        default=[], description='Testcases for the problem.'\n    )\n\n    stresses: List[Stress] = Field(\n        default=[], description='Stress tests for the problem.'\n    )\n\n    statements: Annotated[\n        List[Statement],\n        AfterValidator(is_unique_by_name),\n    ] = Field(default=[], description='Statements for the problem.')\n\n    # Vars to be re-used across the package.\n    #   - It will be passed as --key=value arguments to the validator.\n    #   - It will be available as \\VAR{key} variables in the rbx statement.\n    vars: RecVars = Field(\n        default={}, description='Variables to be re-used across the package.'\n    )\n\n    unitTests: UnitTests = Field(\n        default_factory=UnitTests,\n        description='Unit tests for components of this problem.',\n    )\n\n    @property\n    def expanded_statements(self) -&gt; List[Statement]:\n        return expand_statements(self.statements)\n\n    @property\n    def expanded_vars(self) -&gt; Vars:\n        return expand_vars(self.vars)\n\n    @model_validator(mode='after')\n    def check_first_solution_is_main_if_there_is_ac(self):\n        if all(sol.outcome != Outcome.ACCEPTED for sol in self.solutions):\n            # No main solution.\n            return self\n        if self.solutions:\n            if self.solutions[0].outcome != ExpectedOutcome.ACCEPTED:\n                raise PydanticCustomError(\n                    'MISSING_MAIN_SOLUTION',\n                    'The first solution in the package must have the \"ACCEPTED\" outcome if there are ACCEPTED solutions.',\n                )\n        return self\n\n    @model_validator(mode='after')\n    def samples_come_first(self):\n        for i, group in enumerate(self.testcases):\n            if group.name == 'samples' and i &gt; 0:\n                raise PydanticCustomError(\n                    'SAMPLES_NOT_FIRST',\n                    'The \"samples\" group must be the first group in the package, but is actually the {i}-th',\n                    {'i': i + 1},\n                )\n        return self\n\n    @model_validator(mode='after')\n    def check_scoring_fields(self):\n        if not self.scoring == ScoreType.POINTS:\n            for group in self.testcases:\n                if group.deps:\n                    raise PydanticCustomError(\n                        'DEPS_NOT_ALLOWED',\n                        'Dependencies are not allowed for groups of problems with scoring != POINTS.',\n                    )\n                if group.score != 0:\n                    raise PydanticCustomError(\n                        'SCORE_NOT_ALLOWED',\n                        'Non-zero score is not allowed for groups of problems with scoring != POINTS.',\n                    )\n            for solution in self.solutions:\n                if solution.score is not None:\n                    raise PydanticCustomError(\n                        'SCORE_NOT_ALLOWED',\n                        'Expected score is not allowed for solutions of problems with scoring != POINTS.',\n                    )\n        return self\n\n    @model_validator(mode='after')\n    def check_deps(self):\n        depends = collections.defaultdict(list)\n        for group in self.testcases:\n            if group.name == 'samples':\n                if group.deps:\n                    raise PydanticCustomError(\n                        'DEPS_NOT_ALLOWED',\n                        'Dependencies are not allowed for the \"samples\" group.',\n                    )\n                continue\n            depends[group.name].extend(group.deps)\n\n        visiting = set()\n        visited = set()\n\n        def dfs(u):\n            visiting.add(u)\n            for v in depends[u]:\n                if v in visiting:\n                    return True\n                if v not in visited:\n                    if dfs(v):\n                        return True\n            visiting.remove(u)\n            visited.add(u)\n            return False\n\n        for group in self.testcases:\n            if group.name != 'samples' and group.name not in visited:\n                if dfs(group.name):\n                    raise PydanticCustomError(\n                        'CYCLIC_DEPENDENCY',\n                        'Cyclic dependency detected involving test group \"{group_name}\".',\n                        {'group_name': group.name},\n                    )\n        return self\n\n    @model_validator(mode='after')\n    def check_checker_and_interactor_for_task_type(self):\n        if self.type == TaskType.BATCH:\n            if self.interactor is not None:\n                raise PydanticCustomError(\n                    'INTERACTOR_NOT_ALLOWED',\n                    'Interactor is not allowed for batch problems. Change the task type to COMMUNICATION.',\n                )\n        if self.type == TaskType.COMMUNICATION:\n            if self.checker is not None and (\n                self.interactor is None or not self.interactor.legacy\n            ):\n                raise PydanticCustomError(\n                    'CHECKER_NOT_ALLOWED',\n                    'Checkers should not be specified for communication problems.',\n                )\n        return self\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ScoreType","title":"<code>ScoreType</code>","text":"<p>               Bases: <code>AutoEnum</code></p> Source code in <code>rbx/box/schema.py</code> <pre><code>class ScoreType(AutoEnum):\n    BINARY = alias('binary')  # type: ignore\n    \"\"\"Scoring for ICPC-like problems, where the problem is considered a point if it pass all testcases.\"\"\"\n\n    POINTS = alias('points')  # type: ignore\n    \"\"\"Subtasks scoring, where each passing testgroup is worth a number of points that are summed up.\"\"\"\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ScoreType.BINARY","title":"<code>BINARY = alias('binary')</code>","text":"<p>Scoring for ICPC-like problems, where the problem is considered a point if it pass all testcases.</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ScoreType.POINTS","title":"<code>POINTS = alias('points')</code>","text":"<p>Subtasks scoring, where each passing testgroup is worth a number of points that are summed up.</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.Solution","title":"<code>Solution</code>","text":"<p>               Bases: <code>CodeItem</code></p> <p>Parameters:</p> Name Type Description Default <code>outcome</code> <code>ExpectedOutcome</code> <p>The expected outcome of this solution.</p> <code>ANY</code> <code>tags</code> <code>List[str]</code> <p>Tags to be associated with this solution.</p> <code>[]</code> <code>score</code> <code>int | Tuple[int | None, int | None] | None</code> <p>The score of this solution in the final score. Should either be an integer, which means the solution should have this exact score, or a tuple of two integers, which means the solution should have a score between the two integers (inclusive).</p> <p>If one of the integers is set to be null, it means that the solution should have a score between the other integer and negative/positive infinity.</p> <code>None</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class Solution(CodeItem):\n    model_config = ConfigDict(extra='forbid')\n\n    outcome: ExpectedOutcome = Field(\n        default=ExpectedOutcome.ANY,\n        description=\"\"\"The expected outcome of this solution.\"\"\",\n    )\n\n    tags: List[str] = Field(\n        default=[],\n        description=\"\"\"Tags to be associated with this solution.\"\"\",\n    )\n\n    score: Optional[Union[int, Tuple[Optional[int], Optional[int]]]] = Field(\n        default=None,\n        description=\"\"\"The score of this solution in the final score.\nShould either be an integer, which means the solution should have this exact score,\nor a tuple of two integers, which means the solution should have a score between the two integers (inclusive).\n\nIf one of the integers is set to be null, it means that the solution should have a score between the other integer and negative/positive infinity.\"\"\",\n    )\n\n    def expected_score_range(self) -&gt; Optional[Tuple[int, int]]:\n        if self.score is None:\n            return None\n        if isinstance(self.score, int):\n            return (self.score, self.score)\n        assert isinstance(self.score, tuple)\n        assert len(self.score) == 2\n\n        lo, hi = self.score\n        if lo is None:\n            lo = 0\n        if hi is None:\n            hi = 10**9\n        return (lo, hi)\n\n    def href(self, hyperlink: bool = True) -&gt; str:\n        return href(self.path, style=self.outcome.full_style(), hyperlink=hyperlink)\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.Stress","title":"<code>Stress</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the stress test.</p> required <code>generator</code> <code>GeneratorCall</code> <p>Generator pattern to call during stress-test.</p> required <code>finder</code> <code>str</code> <p>Finder expression to be used to match against generated tests.</p> required Source code in <code>rbx/box/schema.py</code> <pre><code>class Stress(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    name: str = NameField(description='The name of the stress test.')\n\n    generator: GeneratorCall = Field(\n        description='Generator pattern to call during stress-test.'\n    )\n\n    finder: str = Field(\n        description='Finder expression to be used to match against generated tests.'\n    )\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.TaskType","title":"<code>TaskType</code>","text":"<p>               Bases: <code>AutoEnum</code></p> Source code in <code>rbx/box/schema.py</code> <pre><code>class TaskType(AutoEnum):\n    BATCH = alias('batch')  # type: ignore\n    \"\"\"Batch task.\"\"\"\n\n    COMMUNICATION = alias('communication')  # type: ignore\n    \"\"\"Communication task.\"\"\"\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.TaskType.BATCH","title":"<code>BATCH = alias('batch')</code>","text":"<p>Batch task.</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.TaskType.COMMUNICATION","title":"<code>COMMUNICATION = alias('communication')</code>","text":"<p>Communication task.</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.Testcase","title":"<code>Testcase</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>inputPath</code> <code>Path</code> <p>The path of the input file.</p> required <code>outputPath</code> <code>Path | None</code> <p>The path of the output file.</p> <code>None</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class Testcase(BaseModel):\n    __test__ = False\n\n    model_config = ConfigDict(extra='forbid')\n\n    inputPath: pathlib.Path = Field(description=\"\"\"The path of the input file.\"\"\")\n\n    outputPath: Optional[pathlib.Path] = Field(\n        default=None, description=\"\"\"The path of the output file.\"\"\"\n    )\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.TestcaseGroup","title":"<code>TestcaseGroup</code>","text":"<p>               Bases: <code>TestcaseSubgroup</code></p> <p>Parameters:</p> Name Type Description Default <code>subgroups</code> <code>List[TestcaseSubgroup]</code> <p>A list of test subgroups to define for this group.</p> <code>[]</code> <code>validator</code> <code>CodeItem | None</code> <p>A validator to use to validate the testcases of this group. If specified, will use this validator instead of the package-level validator. Useful in cases where the constraints vary across test groups.</p> <code>None</code> <code>score</code> <code>int</code> <p>The score of this group in the final score. Useful for problems that have points.</p> <code>0</code> <code>deps</code> <code>List[str]</code> <p>A list of other groups this group depends on to run and be considered accepted.</p> <p>The <code>samples</code> group is implicitly a dependency of every other group.</p> <code>[]</code> <code>model_solution</code> <code>ForwardRef('Optional[Solution]')</code> <p>The solution to be used to generate outputs for this testgroup.</p> <p>Can only be set for the \"samples\" testgroup.</p> <code>None</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class TestcaseGroup(TestcaseSubgroup):\n    model_config = ConfigDict(extra='forbid')\n\n    subgroups: List[TestcaseSubgroup] = Field(\n        default=[],\n        description=\"\"\"\nA list of test subgroups to define for this group.\n        \"\"\",\n    )\n\n    validator: Optional[CodeItem] = Field(\n        default=None,\n        description=\"\"\"\nA validator to use to validate the testcases of this group.\nIf specified, will use this validator instead of the package-level validator.\nUseful in cases where the constraints vary across test groups.\n\"\"\",\n    )\n\n    score: int = Field(\n        default=0,\n        description=\"\"\"\nThe score of this group in the final score. Useful for\nproblems that have points.\n\"\"\",\n    )\n\n    deps: List[str] = Field(\n        default=[],\n        description=\"\"\"\nA list of other groups this group depends on to run and be considered accepted.\n\nThe `samples` group is implicitly a dependency of every other group.\n\"\"\",\n    )\n\n    model_solution: Optional[Solution] = Field(\n        default=None,\n        description=\"\"\"\nThe solution to be used to generate outputs for this testgroup.\n\nCan only be set for the \"samples\" testgroup.\n\"\"\",\n    )\n\n    @model_validator(mode='after')\n    def check_model_solution_for_samples(self):\n        if self.name == 'samples':\n            return self\n        if self.model_solution is not None:\n            raise PydanticCustomError(\n                'MODEL_SOLUTION_NOT_ALLOWED',\n                'Model solution can only be set for the \"samples\" testgroup.',\n            )\n        return self\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.TestcaseSubgroup","title":"<code>TestcaseSubgroup</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the test group.</p> required <code>testcases</code> <code>List[Testcase]</code> <p>The path of testcases to add to this group, in the order they're defined.</p> <code>[]</code> <code>testcaseGlob</code> <code>str | None</code> <p>A Python glob that matches input file paths relative to the package directory. The globbed files should end with the extension \".in\", and their corresponding outputs, if defined, should have the same file name, but ending with \".ans\".</p> <code>None</code> <code>generators</code> <code>List[GeneratorCall]</code> <p>A list of generators to call to generate testcases for this group.</p> <code>[]</code> <code>generatorScript</code> <code>GeneratorScript | None</code> <p>A generator script to call to generate testcases for this group.</p> <code>None</code> <code>extraValidators</code> <code>List[CodeItem]</code> <p>A list of extra validators to use to validate the testcases of this subgroup.</p> <code>[]</code> <code>outputValidators</code> <code>List[CodeItem]</code> <p>A list of output validators to use to validate the output of the testcases of this subgroup.</p> <code>[]</code> <code>visualizer</code> <code>Visualizer | None</code> <p>The visualizer for this problem. Used to produced visualizations for the testcases. Has priority over the visualizer specified in the package.</p> <code>None</code> <code>solutionVisualizer</code> <code>Visualizer | None</code> <p>The solution visualizer for this problem. Used to produced visualizations for the outputs of the testcases. Has priority over the solution visualizer specified in the package.</p> <code>None</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class TestcaseSubgroup(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    name: str = NameField(description='The name of the test group.')\n\n    testcases: List[Testcase] = Field(\n        default=[],\n        description=\"\"\"\nThe path of testcases to add to this group,\nin the order they're defined.\"\"\",\n    )\n\n    testcaseGlob: Optional[str] = Field(\n        default=None,\n        description=\"\"\"\nA Python glob that matches input file paths relative to the\npackage directory. The globbed files should end with the extension\n\".in\", and their corresponding outputs, if defined, should have the same file name,\nbut ending with \".ans\".\n\"\"\",\n    )\n\n    generators: List[GeneratorCall] = Field(\n        default=[],\n        description=\"\"\"\nA list of generators to call to generate testcases for this group.\n\"\"\",\n    )\n\n    generatorScript: Optional[GeneratorScript] = Field(\n        default=None,\n        description=\"\"\"\nA generator script to call to generate testcases for this group.\n\"\"\",\n    )\n\n    extraValidators: List[CodeItem] = Field(\n        default=[],\n        description=\"\"\"\nA list of extra validators to use to validate the testcases of this subgroup.\n\"\"\",\n    )\n\n    outputValidators: List[CodeItem] = Field(\n        default=[],\n        description=\"\"\"\nA list of output validators to use to validate the output of the testcases of this subgroup.\n\"\"\",\n    )\n\n    visualizer: Optional[Visualizer] = Field(\n        default=None,\n        description='The visualizer for this problem. Used to produced visualizations for the testcases. '\n        'Has priority over the visualizer specified in the package.',\n    )\n\n    solutionVisualizer: Optional[Visualizer] = Field(\n        default=None,\n        description='The solution visualizer for this problem. Used to produced visualizations for the outputs of the testcases. '\n        'Has priority over the solution visualizer specified in the package.',\n    )\n\n    @model_validator(mode='after')\n    def check_oneof(self) -&gt; 'TestcaseSubgroup':\n        _check_oneof(\n            self,\n            [\n                'testcases',\n                'testcaseGlob',\n                'generators',\n                'generatorScript',\n            ],\n        )\n        return self\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.UnitTests","title":"<code>UnitTests</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>validator</code> <code>List[ValidatorTest]</code> <p>Unit tests for the validator.</p> <code>[]</code> <code>checker</code> <code>List[CheckerTest]</code> <p>Unit tests for the checker.</p> <code>[]</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class UnitTests(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    validator: List[ValidatorTest] = Field(\n        default=[],\n        description='Unit tests for the validator.',\n    )\n\n    checker: List[CheckerTest] = Field(\n        default=[],\n        description='Unit tests for the checker.',\n    )\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ValidatorOutcome","title":"<code>ValidatorOutcome</code>","text":"<p>               Bases: <code>AutoEnum</code></p> Source code in <code>rbx/box/schema.py</code> <pre><code>class ValidatorOutcome(AutoEnum):\n    VALID = alias('valid')  # type: ignore\n    \"\"\"Expected outcome for valid tests.\"\"\"\n\n    INVALID = alias('invalid')  # type: ignore\n    \"\"\"Expected outcome for invalid tests.\"\"\"\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ValidatorOutcome.INVALID","title":"<code>INVALID = alias('invalid')</code>","text":"<p>Expected outcome for invalid tests.</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ValidatorOutcome.VALID","title":"<code>VALID = alias('valid')</code>","text":"<p>Expected outcome for valid tests.</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ValidatorTest","title":"<code>ValidatorTest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>glob</code> <code>str | None</code> <p>A glob pattern for the input files to be used as unit test input for the validator.</p> <code>None</code> <code>testplan</code> <code>Path | None</code> <p>A testplan to be used as unit test input for the validator.</p> <code>None</code> <code>outcome</code> <code>ValidatorOutcome | None</code> <p>The expected outcome of the validator.</p> <code>None</code> <code>validator</code> <code>CodeItem | None</code> <p>The validator to use for this test. If not specified, will use the package-level validator.</p> <code>None</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class ValidatorTest(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    glob: Optional[str] = Field(\n        default=None,\n        description='A glob pattern for the input files to be used as unit test input for the validator.',\n    )\n\n    testplan: Optional[pathlib.Path] = Field(\n        default=None,\n        description='A testplan to be used as unit test input for the validator.',\n    )\n\n    outcome: Optional[ValidatorOutcome] = Field(\n        default=None,\n        description='The expected outcome of the validator.',\n    )\n\n    validator: Optional[CodeItem] = Field(\n        default=None,\n        description='The validator to use for this test. If not specified, will use the package-level validator.',\n    )\n\n    @model_validator(mode='after')\n    def check_oneof(self):\n        if self.glob is None and self.testplan is None:\n            raise PydanticCustomError(\n                'GLOB_OR_TESTPLAN_REQUIRED',\n                'Either a glob or a testplan must be specified.',\n            )\n        if self.glob is not None and self.testplan is not None:\n            raise PydanticCustomError(\n                'GLOB_AND_TESTPLAN_NOT_ALLOWED',\n                'Either a glob or a testplan must be specified, but not both.',\n            )\n        return self\n\n    @model_validator(mode='after')\n    def check_testplan(self):\n        if self.testplan is not None and self.outcome is not None:\n            raise PydanticCustomError(\n                'OUTCOME_NOT_ALLOWED',\n                'Outcome is not allowed for testplan validator tests.',\n            )\n        return self\n\n    @model_validator(mode='after')\n    def check_glob(self):\n        if self.glob is not None and self.outcome is None:\n            raise PydanticCustomError(\n                'OUTCOME_REQUIRED',\n                'Outcome is required for glob validator tests.',\n            )\n        return self\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.Visualizer","title":"<code>Visualizer</code>","text":"<p>               Bases: <code>CodeItem</code></p> <p>Parameters:</p> Name Type Description Default <code>extension</code> <code>str</code> <p>The extension of the visualization file generated by the visualizer.</p> required <code>answer_from</code> <code>Literal['stderr'] | OutputFromItem | None</code> <p>Program to generate additional answer file to pass to the visualizer.         If not specified, the reference answer file will be used.</p> <code>None</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class Visualizer(CodeItem):\n    model_config = ConfigDict(extra='forbid')\n\n    extension: str = Field(\n        description=\"\"\"The extension of the visualization file generated by the visualizer.\n        \"\"\",\n    )\n\n    answer_from: Optional[OutputFrom] = Field(\n        default=None,\n        description=\"\"\"Program to generate additional answer file to pass to the visualizer.\n        If not specified, the reference answer file will be used.\"\"\",\n    )\n\n    def get_suffix(self) -&gt; str:\n        return f'.{self.extension}'\n</code></pre>"},{"location":"setters/reference/package/schema/#statements","title":"Statements","text":""},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.Statement","title":"<code>Statement</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of this statement.</p> required <code>inheritFromContest</code> <code>bool</code> <p>Whether the configuration for this statement should be inherited from the contest. When this field is set to true, the statement for this problem can only be built if it's within a contest and there is a contest statement matching it.</p> <code>False</code> <code>extends</code> <code>str | None</code> <p>Name of the statement that this statement extends.</p> <code>None</code> <code>language</code> <code>str</code> <p>Language code of this statement (ISO 639-1).</p> <code>'en'</code> <code>title</code> <code>str | None</code> <p>Title of the problem, as it appears in the statement. Can be left unset if the problem has no title or if title comes from the <code>titles</code> field of the package.</p> <code>None</code> <code>path</code> <code>Path</code> <p>Path to the input statement file.</p> <code>&lt;dynamic&gt;</code> <code>type</code> <code>StatementType</code> <p>Type of the input statement file.</p> <code>rbxTeX</code> <code>steps</code> <code>List[TexToPDF | JinjaTeX | rbxToTeX | rbxMarkdownToTeX]</code> <p>Describes a sequence of conversion steps that should be applied to the statement file.</p> <p>Usually, it is not necessary to specify these, as they can be inferred from the input statement type and the output statement type, but you can use this to force certain conversion steps to happen.</p> <code>[]</code> <code>configure</code> <code>List[TexToPDF | JinjaTeX | rbxToTeX | rbxMarkdownToTeX]</code> <p>Configure how certain conversion steps should happen when applied to the statement file.</p> <p>Different from the <code>steps</code> field, this does not force the steps to happen, but rather only configure them in case they are applied.</p> <code>[]</code> <code>assets</code> <code>List[str]</code> <p>Assets relative to the package directory that should be included while building the statement. Files will be included in the same folder as the statement file, preserving their relativeness. Can be glob pattern as well, such as <code>imgs/*.png</code>.</p> <code>[]</code> <code>vars</code> <code>TypeAliasType</code> <p>Variables to be used in the statement.</p> <code>{}</code> <code>samples</code> <code>bool</code> <p>Whether to build the statement with samples.</p> <code>True</code> Source code in <code>rbx/box/statements/schema.py</code> <pre><code>class Statement(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    name: str = FNameField(description='Name of this statement.')\n\n    inheritFromContest: bool = Field(\n        default=False,\n        description='Whether the configuration for this statement should be inherited from the contest. '\n        \"When this field is set to true, the statement for this problem can only be built if it's within \"\n        'a contest and there is a contest statement matching it.',\n    )\n\n    extends: Optional[str] = FNameField(\n        default=None,\n        description='Name of the statement that this statement extends.',\n    )\n\n    language: StatementLanguage = Field(\n        default='en', description='Language code of this statement (ISO 639-1).'\n    )\n\n    title: Optional[str] = Field(\n        default=None,\n        description='Title of the problem, as it appears in the statement. '\n        'Can be left unset if the problem has no title or if title comes '\n        'from the `titles` field of the package.',\n    )\n\n    path: pathlib.Path = Field(\n        default_factory=pathlib.Path, description='Path to the input statement file.'\n    )\n\n    type: StatementType = Field(\n        default=StatementType.rbxTeX, description='Type of the input statement file.'\n    )\n\n    steps: List[Annotated[ConversionStep, Field(discriminator='type')]] = Field(\n        default=[],\n        description=\"\"\"\nDescribes a sequence of conversion steps that should be applied to the statement file.\n\nUsually, it is not necessary to specify these, as they can be inferred from the\ninput statement type and the output statement type, but you can use this to force\ncertain conversion steps to happen.\n\"\"\",\n    )\n\n    configure: List[Annotated[ConversionStep, Field(discriminator='type')]] = Field(\n        default=[],\n        description=\"\"\"\nConfigure how certain conversion steps should happen when applied to the statement file.\n\nDifferent from the `steps` field, this does not force the steps to happen, but rather only\nconfigure them in case they are applied.\n\"\"\",\n    )\n\n    assets: List[str] = Field(\n        default=[],\n        description=\"\"\"\nAssets relative to the package directory that should be included while building\nthe statement. Files will be included in the same folder as the statement file, preserving\ntheir relativeness. Can be glob pattern as well, such as `imgs/*.png`.\n\"\"\",\n    )\n\n    vars: RecVars = Field(\n        default={},\n        description='Variables to be used in the statement.',\n    )\n\n    samples: bool = Field(\n        default=True,\n        description='Whether to build the statement with samples.',\n    )\n\n    @property\n    def expanded_vars(self) -&gt; Vars:\n        return expand_vars(self.vars)\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.StatementType","title":"<code>StatementType</code>","text":"<p>               Bases: <code>AutoEnum</code></p> Source code in <code>rbx/box/statements/schema.py</code> <pre><code>class StatementType(AutoEnum):\n    rbxTeX = alias('rbx-tex')  # type: ignore\n    \"\"\"Statement written in rbxTeX format.\"\"\"\n\n    rbxMarkdown = alias('rbxMd', 'rbx-markdown', 'rbx-md')  # type: ignore\n    \"\"\"Statement written in rbxMarkdown format.\"\"\"\n\n    TeX = alias('tex')  # type: ignore\n    \"\"\"Statement written in pure LaTeX format.\"\"\"\n\n    JinjaTeX = alias('jinja-tex')  # type: ignore\n    \"\"\"Statement written in LaTeX format with Jinja2 expressions.\"\"\"\n\n    PDF = alias('pdf')  # type: ignore\n    \"\"\"Statement is a PDF.\"\"\"\n\n    def get_file_suffix(self) -&gt; str:\n        if self == StatementType.TeX:\n            return '.tex'\n        if self == StatementType.rbxTeX:\n            return '.rbx.tex'\n        if self == StatementType.rbxMarkdown:\n            return '.rbx.md'\n        if self == StatementType.JinjaTeX:\n            return '.jinja.tex'\n        if self == StatementType.PDF:\n            return '.pdf'\n        raise ValueError(f'Unknown statement type: {self}')\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.StatementType.rbxTeX","title":"<code>rbxTeX = alias('rbx-tex')</code>","text":"<p>Statement written in rbxTeX format.</p>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.StatementType.rbxMarkdown","title":"<code>rbxMarkdown = alias('rbxMd', 'rbx-markdown', 'rbx-md')</code>","text":"<p>Statement written in rbxMarkdown format.</p>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.StatementType.TeX","title":"<code>TeX = alias('tex')</code>","text":"<p>Statement written in pure LaTeX format.</p>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.StatementType.JinjaTeX","title":"<code>JinjaTeX = alias('jinja-tex')</code>","text":"<p>Statement written in LaTeX format with Jinja2 expressions.</p>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.StatementType.PDF","title":"<code>PDF = alias('pdf')</code>","text":"<p>Statement is a PDF.</p>"},{"location":"setters/reference/package/schema/#conversion-nodes","title":"Conversion nodes","text":""},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.ConversionType","title":"<code>ConversionType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> Source code in <code>rbx/box/statements/schema.py</code> <pre><code>class ConversionType(str, Enum):\n    rbxToTex = 'rbx-tex'\n    \"\"\"Conversion from rbxTeX to LaTeX.\"\"\"\n\n    rbxMarkdownToTeX = 'rbx-md-tex'\n    \"\"\"Conversion from rbxMarkdown to LaTeX.\"\"\"\n    TexToPDF = 'tex2pdf'\n    \"\"\"Conversion from LaTeX to PDF using pdfLaTeX.\"\"\"\n\n    JinjaTeX = 'jinja-tex'\n    \"\"\"Conversion from LaTeX with Jinja2 expressions to LaTeX.\"\"\"\n\n    def __repr__(self):\n        return str.__repr__(self.value)\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.ConversionType.JinjaTeX","title":"<code>JinjaTeX = 'jinja-tex'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Conversion from LaTeX with Jinja2 expressions to LaTeX.</p>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.ConversionType.TexToPDF","title":"<code>TexToPDF = 'tex2pdf'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Conversion from LaTeX to PDF using pdfLaTeX.</p>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.ConversionType.rbxMarkdownToTeX","title":"<code>rbxMarkdownToTeX = 'rbx-md-tex'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Conversion from rbxMarkdown to LaTeX.</p>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.ConversionType.rbxToTex","title":"<code>rbxToTex = 'rbx-tex'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Conversion from rbxTeX to LaTeX.</p>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.JinjaTeX","title":"<code>JinjaTeX</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>Literal['jinja-tex']</code> required Source code in <code>rbx/box/statements/schema.py</code> <pre><code>class JinjaTeX(BaseModel):\n    type: Literal[ConversionType.JinjaTeX]\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.JoinTexToPDF","title":"<code>JoinTexToPDF</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configures the joining of contest and problem texes to PDF.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>Literal['tex2pdf']</code> required Source code in <code>rbx/box/statements/schema.py</code> <pre><code>class JoinTexToPDF(BaseModel):\n    \"\"\"Configures the joining of contest and problem texes to PDF.\"\"\"\n\n    type: Literal[JoinerType.TexToPDF]\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.JoinerType","title":"<code>JoinerType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> Source code in <code>rbx/box/statements/schema.py</code> <pre><code>class JoinerType(str, Enum):\n    TexToPDF = 'tex2pdf'\n    \"\"\"Join contest tex and problem texs to PDF using pdfLaTeX.\"\"\"\n\n    def __repr__(self):\n        return str.__repr__(self.value)\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.JoinerType.TexToPDF","title":"<code>TexToPDF = 'tex2pdf'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Join contest tex and problem texs to PDF using pdfLaTeX.</p>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.TexToPDF","title":"<code>TexToPDF</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configures the conversion between LaTeX and PDF using pdfLaTeX.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>Literal['tex2pdf']</code> required <code>externalize</code> <code>bool</code> <p>Whether to externalize TikZ graphics.</p> <code>False</code> <code>demacro</code> <code>bool</code> <p>Whether to save macro definitions to a JSON file.</p> <code>False</code> Source code in <code>rbx/box/statements/schema.py</code> <pre><code>class TexToPDF(BaseModel):\n    \"\"\"Configures the conversion between LaTeX and PDF using pdfLaTeX.\"\"\"\n\n    type: Literal[ConversionType.TexToPDF]\n\n    externalize: bool = Field(\n        default=False,\n        description='Whether to externalize TikZ graphics.',\n    )\n\n    demacro: bool = Field(\n        default=False,\n        description='Whether to save macro definitions to a JSON file.',\n    )\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.rbxMarkdownToTeX","title":"<code>rbxMarkdownToTeX</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configures the conversion between rbxMarkdown and LaTeX.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>Literal['rbx-md-tex']</code> required Source code in <code>rbx/box/statements/schema.py</code> <pre><code>class rbxMarkdownToTeX(BaseModel):\n    \"\"\"Configures the conversion between rbxMarkdown and LaTeX.\"\"\"\n\n    type: Literal[ConversionType.rbxMarkdownToTeX]\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.rbxToTeX","title":"<code>rbxToTeX</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configures the conversion between rbxTeX and LaTeX.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>Literal['rbx-tex']</code> required <code>template</code> <code>Path</code> <p>Path to the template that should be used to render the rbx-tex blocks.</p> <code>PosixPath('template.rbx.tex')</code> <code>externalize</code> <code>bool</code> <p>Whether to externalize TikZ graphics.</p> <code>False</code> Source code in <code>rbx/box/statements/schema.py</code> <pre><code>class rbxToTeX(BaseModel):\n    \"\"\"Configures the conversion between rbxTeX and LaTeX.\"\"\"\n\n    type: Literal[ConversionType.rbxToTex]\n\n    template: pathlib.Path = Field(\n        default=pathlib.Path('template.rbx.tex'),\n        description='Path to the template that should be used to render the rbx-tex blocks.',\n    )\n\n    externalize: bool = Field(\n        default=False,\n        description='Whether to externalize TikZ graphics.',\n    )\n</code></pre>"},{"location":"setters/running/","title":"Running","text":"<p>rbx provides a range of options to run your solutions. In the sections below, we'll go through each of them.</p>"},{"location":"setters/running/#running-solutions-on-the-whole-testset","title":"Running solutions on the whole testset","text":"<p>You can use the <code>rbx run</code> command to run your solutions on the whole testset.</p> <p>The command will run all selected solutions (or all declared solutions if none are selected) on all testcases, providing for each of them the solution outcome, and for the whole testset the timing and memory usage.</p> <p>Below are some examples of how to use the command.</p> <pre><code># Run all solutions on all testcases\nrbx run\n\n# Run a single solution (or a list of solutions) on all testcases\nrbx run &lt;solution-name&gt; ...\n\n# Run all AC solutions on all testcases\nrbx run --outcome AC\n\n# Run all WA solutions on all testcases\nrbx run --outcome WA\n\n# Run all solutions, and provide a table-like output instead\n# of the default output\nrbx run -d\n\n# Interactively pick which solutions to run\nrbx run -c\n</code></pre> <p>One can also set the verification level to be used when running the solutions.</p> <pre><code>rbx run -v{0,1,2,3,4}\n</code></pre> <p>You can read more about each verification level here.</p> <p>By default, rbx will run solutions with the maximum verification level. This means tests will be built and verified, and that all solutions will be run with twice the time limit, and a warning will show up if a TLE solution passed in <code>2*TL</code>.</p> <p>The results of a <code>rbx run</code> command can be inspected through the <code>rbx ui</code> command, as shown in the animation below.</p>"},{"location":"setters/running/#running-tests-with-custom-inputs","title":"Running tests with custom inputs","text":"<p>You might want to run your solutions on a testcase that is not part of the testset, or even on a specific testcase of the testset.</p> <p>You can do this with the <code>rbx irun</code> command. The command will select which solutions to run similar to <code>rbx run</code>. This means you can specify with the following flags:</p> <pre><code># Run a single solution (or a list of solutions) on a specific testcase\nrbx irun &lt;solution-name&gt; ...\n\n# Run all AC solutions on a specific testcase\nrbx irun --outcome AC\n\n# Interactively pick which solutions to run\nrbx irun -c\n</code></pre> <p>By default, <code>rbx irun</code> will prompt you to type a testcase input. After you've finished typing it, you can press <code>Ctrl+D</code> to tell rbx that you're done.</p> <p>rbx will then run the solutions on the testcase you've provided, and print the results into files. You can also use the <code>-p</code> flag to instruct it to print the results into the console instead.</p> <p>Tip</p> <p>By default, the test you've written will be validated, so make sure you've typed it perfectly.</p> <p>If you want to disable validation, you can pass the <code>-v0</code> flag to set the verification level to 0.</p> <p>You can also specify a certain testcase of the testset to run using the <code>-t</code> flag followed by the testcase notation, which is composed of <code>&lt;testgroup-name&gt;/&lt;testcase-index&gt;</code>. For instance, <code>samples/0</code> is the first testcase in the <code>sample</code> testgroup, and <code>secret/10</code> is the 11th testcase in the <code>secret</code> testgroup.</p> <pre><code>rbx irun -t sample/0\n</code></pre> <p>Last but not least, you can also specify a generator call to be used when generating the testcase.</p> <pre><code>rbx irun -g \"gen 100 123\" -p\n</code></pre>"},{"location":"setters/statements/","title":"Statements","text":"<p>The statement is the document that describes the problem to the contestant. It typically contains the problem description, input format, output format, constraints, and samples.</p> <p>rbx supports a powerful and flexible statement system that allows you to write statements in multiple formats, including the custom rbxTeX format, as well as standard LaTeX and PDF.</p>"},{"location":"setters/statements/#overview","title":"Overview","text":"<p>Regardless of the format you choose, every statement goes through a build pipeline to generally produce a PDF file (though you can also export the intermediate LaTeX if needed).</p> <pre><code>graph LR\n    Source[Source File] --&gt;|Builder| TeX[LaTeX File]\n    TeX --&gt;|pdfLaTeX| PDF[PDF File]</code></pre>"},{"location":"setters/statements/#supported-formats","title":"Supported formats","text":"<p>rbx supports multiple formats for writing statements. We highly recommend using rbxTeX for most problems, as it offers the best balance between power and ease of use.</p> Format Description Best for... rbxTeX Recommended. A superset of LaTeX with block structure and variable interpolation. Most problems. It separates content from layout effectively. JinjaTeX Pure LaTeX with Jinja2 templating. Import existing statements, but still leverage from templating. Pure LaTeX Standard static LaTeX files. Importing existing statements without modifications. PDF Pre-built PDF files. Using statements that are already built/provided as PDFs."},{"location":"setters/statements/#configuration","title":"Configuration","text":"<p>Statements are configured in the <code>problem.rbx.yml</code> file under the <code>statements</code> list. You can define multiple statements for the same problem (e.g., different languages, different versions).</p> problem.rbx.yml<pre><code>statements:\n  - name: statement-en        # (1)!\n    language: en              # (2)!\n    path: statement.en.tex    # (3)!\n    type: rbx-tex             # (4)!\n    assets:                   # (5)!\n      - images/*.png\n    vars:                     # (6)!\n      editorial: false\n      showLimits: true\n</code></pre> <ol> <li>name: A unique identifier for the statement. Used to refer to this statement.</li> <li>language: The language code (ISO 639-1) for the statement.</li> <li>path: Path to the statement file, relative to the package root.</li> <li>type: The format of the statement. Can be <code>rbx-tex</code>, <code>jinja-tex</code>, <code>tex</code>, or <code>pdf</code>.</li> <li>assets: A list of files (globs supported) to be included in the build directory.</li> <li>vars: Custom variables to be injected into the statement.</li> </ol>"},{"location":"setters/statements/#assets-and-resources","title":"Assets and resources","text":"<p>You can include images, style files, and other resources in your statement using the <code>assets</code> field. These files will be copied to the build directory alongside your statement file, preserving their relative paths.</p> <pre><code>statements:\n  - name: statement-en\n    path: statements/en.tex\n    assets:\n      - statements/images/*.png\n      - statements/icpc.sty\n</code></pre> <p>In the case above, the statement source file <code>en.tex</code> will be placed in <code>&lt;build-dir&gt;/en.tex</code> while building, while an image such as <code>statements/images/example.png</code> will be placed in <code>&lt;build-dir&gt;/images/example.png</code>. In other words, the path of the asset relative to the statement source file is preserved in the build directory.</p> <p>Tip</p> <p>Keep your statement files and assets organized in a subdirectory (e.g., <code>statements/</code> or <code>doc/</code>) to avoid cluttering the package root.</p>"},{"location":"setters/statements/#building-statements","title":"Building statements","text":"<p>To build statements, use the <code>rbx statements build</code> command (or alias <code>rbx st b</code>):</p> <pre><code># Build all statements\nrbx statements build\n\n# Build specific statements by name\nrbx statements build statement-en\n\n# Build for specific languages\nrbx statements build --languages en pt\n</code></pre> <p>The built statements will be placed in the <code>build/</code> directory of your package.</p>"},{"location":"setters/statements/contest/","title":"Contest statements","text":"<p>In addition to problem-level statements, rbx supports creating contest statements. A contest statement is typically a single document (usually PDF) that aggregates all the problem statements in a contest, often with a cover page, customized header/footer, and problem numbering.</p>"},{"location":"setters/statements/contest/#configuration","title":"Configuration","text":"<p>Contest statements are defined in the <code>contest.rbx.yml</code> file, and are usually JinjaTeX statements since there's no need to define blocks (but can be rbxTeX as well if you prefer).</p> contest.rbx.yml<pre><code>name: \"my-contest\"\nproblems:\n  - short_name: A\n    path: problems/A\n  - short_name: B\n    path: problems/B\n\nstatements:\n  - name: contest-en\n    title: \"My Contest\"\n    language: en\n    path: statement/contest.rbx.tex\n    type: jinja-tex\n    # Contest-statement specific knobs.\n    match: statement-en # (1)!\n    joiner: {type: \"tex2pdf\"} # (2)!\n    override:\n      configure: # (3)!\n        - type: \"rbx-tex\" # Convert rbxTeX to TeX\n          template: \"statement/contest_template.rbx.tex\"\n      vars: # (4)!\n        showLimits: true\n    vars: # (5)!\n      editorial: false\n</code></pre> <ol> <li>match: Point to the <code>name</code> of the problem statements that should be built     and joined into this contest statement.</li> <li>joiner: Usually <code>tex2pdf</code>, meaning each problem-level statement will be     built into a TeX file (as opposed to the default PDF) and then, after that,     joined into a single PDF file. This configuration is crucial for contest-level     statements.</li> <li>override.configure: Overrides the <code>rbx-tex</code> template to use when building each     problem statement. Useful because the problem template when building for contests     has to be slightly different (no <code>\\document</code> directive and such).</li> <li>override.vars: Variables to pass to the problem statement context.</li> <li>vars: Variables to pass to the contest statement context.</li> </ol>"},{"location":"setters/statements/contest/#building-contest-statements","title":"Building contest statements","text":"<p>The build process for contest statements is slightly different. Instead of compiling each problem statement to PDF individually and merging them, rbx usually compiles the contest template which includes the content of each problem.</p>"},{"location":"setters/statements/contest/#the-contest-template","title":"The contest template","text":"<p>The contest template receives a few special variables.</p> <p>The <code>contest</code> variable contains the following attributes:</p> <ul> <li><code>contest.title</code>: The title of the contest.</li> </ul> <p>The <code>lang</code> variable contains the language of the contest (ISO 639-1 code).</p> <p>The <code>languages</code> and <code>keyed_languages</code> variables contains the programming languages available for contestants, based on the languages configured in the preset. <code>languages</code> is a list, and <code>keyed_languages</code> is a dictionary with the language ID as the key. These are really useful when you want to render an info sheet.</p> <p>The <code>vars</code> variable receive all variables defined in the contest statement configuration.</p> <p>The <code>problems</code> variable is a list of problems in the contest. You can read more about what is available in each problem here. Additionally, it will have a <code>problem.path</code> field pointing to the built TeX file of the problem statement, which you can use in your contest template to include it.</p> contest.tex<pre><code>\\documentclass{article}\n\\usepackage{icpcformat} % Your custom package\n\n\\title{\\VAR{contest.title}}\n\n\\begin{document}\n\\maketitle\n\n% Render contest header, front-page, etc.\n\n% Iterate over problems\n%- for problem in problems\n    \\clearpage\n    \\subimport{\\VAR{problem.path | parent}/}{\\VAR{problem.path | stem}}\n%- endfor\n\n\\end{document}\n</code></pre>"},{"location":"setters/statements/contest/#variable-overrides","title":"Variable overrides","text":"<p>You can override problem-level settings within the contest statement configuration. This is useful if you want to change the visual appearance of problems specifically for the contest book (e.g., adding the \"Editorial\" block or changing time limit rendering).</p> contest.rbx.yml<pre><code>statements:\n  - name: contest-editorial\n    # Other options...\n    override:\n      vars:\n        # Sets a custom variable that identifies this as the\n        # editorial. This can be used in the problem template to\n        # render an additional \"Editorial\" block after the statements.\n        editorial: true\n</code></pre>"},{"location":"setters/statements/contest/#matching","title":"Matching","text":"<p>When building a contest statement, rbx tries to find the corresponding problem statement for each problem. By default, it matches based on language.</p> <ul> <li>If the contest statement is <code>en</code>, it looks for an <code>en</code> statement in each problem definition.</li> <li>You can customize this matching behavior if needed using the <code>match</code> field in <code>contest.rbx.yml</code>.</li> </ul>"},{"location":"setters/statements/contest/#example-matching-by-name","title":"Example: Matching by Name","text":"<p>If you have multiple statements per language (e.g., <code>statement-en</code> and <code>statement-en-simplified</code>) and want to pick a specific one for the contest:</p> contest.rbx.ymlproblem.rbx.yml <pre><code>statements:\n  - name: contest-en\n    language: en\n    path: contest.rbx.tex\n    match: statement-en-simplified # (1)!\n</code></pre> <ol> <li>This tells rbx to look for a statement named <code>statement-en-simplified</code> in each problem, instead of just picking the first English statement.</li> </ol> <pre><code>statements:\n  - name: statement-en\n    language: en\n    path: statement-en.rbx.tex\n    type: rbx-tex\n\n  - name: statement-en-simplified\n    language: en\n    path: statement-en-simplified.rbx.tex\n    type: rbx-tex\n</code></pre>"},{"location":"setters/statements/contest/#learn-through-examples","title":"Learn through examples","text":"<p>Look at our default preset to see how it works and modify it to your liking.</p>"},{"location":"setters/statements/templates/","title":"Templates","text":"<p>The power of rbxTeX comes from its template system. The content you write in blocks (description, input, output) is injected into a base LaTeX template to produce the final document.</p>"},{"location":"setters/statements/templates/#default-template","title":"Default template","text":"<p>By default, rbx uses a built-in template that provides a standard competitive programming layout. However, you can (and often should) provide your own <code>template.rbx.tex</code> or modify the existing template to match your contest's branding or specific requirements.</p> <p>To use the default template as is, you can simply create a problem from the default preset, and fill in the blocks in your main statement file.</p> <p>You can find the default template here to use as inspiration to create your own.</p>"},{"location":"setters/statements/templates/#customizing-templates","title":"Customizing templates","text":"<p>To use a custom template, simply create a file named <code>template.rbx.tex</code> in the same directory as your statement file, and refer to it in your statement configuration.</p> problem.rbx.yml<pre><code>statements:\n  - name: statement\n    path: statement/statement.rbx.tex\n    configure:\n      - type: rbx-tex\n        template: \"statement/template.rbx.tex\"\n</code></pre>"},{"location":"setters/statements/templates/#template-structure","title":"Template structure","text":"<p>A template is a LaTeX file that defines the document structure and placeholders for content blocks. It uses Jinja2 syntax for logic and variables.</p>"},{"location":"setters/statements/templates/#rbx-provided-variables","title":"rbx-provided variables","text":"<p>The following variables are available in the template context:</p> <ul> <li><code>problem</code>: An object containing problem metadata.<ul> <li><code>problem.title</code>: The problem title.</li> <li><code>problem.short_name</code>: The problem short name (e.g., <code>A</code>, <code>B</code>, etc.).</li> <li><code>problem.blocks</code>: A dictionary of content blocks (e.g., <code>problem.blocks.legend</code>, <code>problem.blocks.input</code>, etc.).</li> <li><code>problem.samples</code>: A list of sample objects.</li> <li><code>problem.vars</code>: Variables defined in <code>problem.rbx.yml</code>.</li> <li><code>problem.limits</code>: Time and memory limits.</li> </ul> </li> </ul> <p>The <code>sample</code> object contains the following attributes:</p> <ul> <li><code>sample.inputPath</code>: The input path, relative to the statement build directory (a <code>pathlib.Path</code> object, so <code>read_text()</code> can be called)</li> <li><code>sample.outputPath</code>: The output path, relative to the statement build directory, similar to the input path</li> </ul> <p>The <code>limits</code> object contains the following attributes/methods:</p> <ul> <li><code>limits.timeLimit</code>: The time limit in milliseconds</li> <li><code>limits.memoryLimit</code>: The memory limit in megabytes</li> <li><code>limits.outputLimit</code>: The output limit in megabytes</li> <li><code>limits.timelimit_for_language(lang)</code>: The time limit in milliseconds for a specific language.</li> <li><code>limits.memorylimit_for_language(lang)</code>: The memory limit in megabytes for a specific language.</li> </ul>"},{"location":"setters/statements/templates/#creating-custom-blocks","title":"Creating custom blocks","text":"<p>While the default template uses standard blocks (<code>description</code>, <code>input</code>, etc.), you can define custom blocks in your rbxTeX files and render them in your template.</p> <p>For example, if you want a \"Hint\" section:</p> <ol> <li> <p>In your statement:     statement.rbx.tex<pre><code>%- block hint\nTry to use dynamic programming.\n%- endblock\n</code></pre></p> </li> <li> <p>In your template:     template.rbx.tex<pre><code>% ...\n%- if problem.blocks.hint\n\\section*{Hint}\n\\VAR{problem.blocks.hint}\n%- endif\n% ...\n</code></pre></p> </li> </ol> <p>This gives you unlimited flexibility to structure your problem statements.</p>"},{"location":"setters/statements/templates/#example-template","title":"Example Template","text":"<p>Here is a simplified example of a custom template:</p> template.rbx.tex<pre><code>\\documentclass{article}\n\\begin{document}\n\n\\section*{\\VAR{problem.short_name}. \\VAR{problem.title}}\n\n\\VAR{problem.blocks.description}\n\n\\subsection*{Input}\n\\VAR{problem.blocks.input}\n\n\\subsection*{Output}\n\\VAR{problem.blocks.output}\n\n\\subsection*{Samples}\n%- for sample in problem.samples\n\\subsection*{Sample \\VAR{loop.index}}\n\\begin{itemize}\n    \\item \\textbf{Input:} \\texttt{\\VAR{sample.inputPath.read_text()}}\n    \\item \\textbf{Output:} \\texttt{\\VAR{sample.outputPath.read_text()}}\n\\end{itemize}\n%- endfor\n\n%- if problem.blocks.notes is defined\n\\subsection*{Note}\n\\VAR{problem.blocks.notes}\n%- endif\n\n\\end{document}\n</code></pre>"},{"location":"setters/statements/templates/#learn-more-through-examples","title":"Learn more through examples","text":"<p>Look at our default preset to see how it works and modify it to your liking.</p>"},{"location":"setters/statements/formats/latex/","title":"LaTeX statements","text":"<p>For advanced use cases, you can write statements directly in LaTeX. rbx supports two flavors of LaTeX statements: JinjaTeX and Pure LaTeX.</p> <p>Recommendation</p> <p>For most use cases, we recommend using rbxTeX instead of raw LaTeX. It provides a higher-level abstraction and handles document structure automatically, and the difference between them is minimal.</p>"},{"location":"setters/statements/formats/latex/#jinjatex","title":"JinjaTeX","text":"<p>JinjaTeX (extension: <code>.jinja.tex</code> or <code>.tex</code> with valid configuration) is a format that combines standard LaTeX with the Jinja2 templating engine.</p> <p>Unlike rbxTeX, which abstracts away the document structure using blocks, JinjaTeX gives you full control over the entire LaTeX document. You are responsible for writing the <code>\\documentclass</code>, <code>\\begin{document}</code>, etc, plus any other LaTeX and Jinja2 code you need.</p>"},{"location":"setters/statements/formats/latex/#when-to-use","title":"When to use","text":"<p>Using JinjaLaTeX, you can inject variables and logic into your LaTeX documents, making it easier to generate dynamic content, but if starting your statement from scratch, we recommend using rbxTeX instead.</p>"},{"location":"setters/statements/formats/latex/#syntax","title":"Syntax","text":"<p>You can use <code>\\VAR{...}</code> to inject variables if using JinjaLaTeX. You can read other supported syntax in Jinja2 documentation.</p> <p>You can also read the set of automatically available variables in the rbxTeX documentation.</p> <pre><code>\\documentclass{article}\n\n\\begin{document}\n\\title{\\VAR{problem.title}}\n\\maketitle\n\n\\section{Input}\n...\n\n\\section{Samples}\n% Iterate over samples manually\n%- for sample in problem.samples\n  \\subsection*{Sample \\VAR{loop.index}}\n  \\begin{verbatim}\n  \\VAR{sample.inputPath.read_text()}\n  \\end{verbatim}\n%- endfor\n\\end{document}\n</code></pre>"},{"location":"setters/statements/formats/latex/#pure-latex","title":"Pure LaTeX","text":"<p>Pure LaTeX (extension: <code>.tex</code>) treats the file as a static LaTeX document. No templating or variable substitution is performed.</p>"},{"location":"setters/statements/formats/latex/#when-to-use_1","title":"When to use","text":"<ul> <li>You have an existing LaTeX statement and just want rbx to compile it to PDF.</li> <li>You don't need any dynamic features or variable injection.</li> <li>You want to ensure the file is valid standard LaTeX that can be compiled by any TeX distribution without preprocessing.</li> </ul> <p>In all other cases, we recommend using rbxTeX.</p>"},{"location":"setters/statements/formats/pdf/","title":"PDF statements","text":"<p>If you already have a pre-built statement (e.g., from an external tool or an old archive), you can configure rbx to use it directly.</p>"},{"location":"setters/statements/formats/pdf/#configuration","title":"Configuration","text":"<p>To use a PDF file as a statement:</p> problem.rbx.yml<pre><code>statements:\n  - name: statement\n    path: statement.pdf\n    type: pdf\n</code></pre>"},{"location":"setters/statements/formats/pdf/#behavior","title":"Behavior","text":"<p>When the statement type is <code>pdf</code>, the build process is essentially a copy operation. The source PDF is copied to the build directory. No templating, variable substitution, or asset processing is performed on the PDF content itself.</p>"},{"location":"setters/statements/formats/rbxtex/","title":"rbxTeX statements","text":"<p>rbxTeX (extension: <code>.rbx.tex</code>) is the recommended format for writing problem statements in rbx. It is a superset of LaTeX that adds a structured, block-based approach to writing statements, making them easier to organize and maintain.</p>"},{"location":"setters/statements/formats/rbxtex/#why-rbxtex","title":"Why rbxTeX?","text":"<p>Standard LaTeX files can be cluttered with boilerplate code (document headers, packages, macros). rbxTeX helps separating the content of the problem (description, input, output) from the layout (the LaTeX template) with the use of the templating engine Jinja2.</p> <p>Key features:</p> <ul> <li>Block-based: Organize content into logical sections (<code>legend</code>, <code>input</code>, etc.).</li> <li>Variable interpolation: Use <code>\\VAR{...}</code> to inject dynamic values like time limits and other user-defined variables.</li> <li>Sample generation: Samples are automatically fetched and made accessible as a Jinja2 variable.</li> <li>Leverage full LaTeX power: You can still use any LaTeX capability, rbxTeX is just a wrapper around LaTeX.</li> </ul>"},{"location":"setters/statements/formats/rbxtex/#definition","title":"Definition","text":"<p>rbxTeX statements usually consist of two files: the main file (usually named <code>statement.rbx.tex</code>) and the template file (usually named <code>template.rbx.tex</code>).</p> <p>The main file contains the blocks that define the content of the problem statement. Think of it as usually containing a few sections, such as the <code>legend</code>, the <code>input</code>, the <code>output</code>, the <code>notes</code>, etc.</p> <p>The template file contains the layout of the problem statement, and through the use of Jinja2, it can access the content of the blocks defined in the main file and render them in the appropriate place.</p> <p>In a problem, a rbxTeX statement can be defined as:</p> problem.rbx.yml<pre><code>statements:\n  - name: statement\n    path: statement/statement.rbx.tex # The main file\n    configure:\n      - type: rbx-tex\n        template: \"statement/template.rbx.tex\" # The template file\n</code></pre> <p>For contest-level statements, please read the Contest Statement section.</p>"},{"location":"setters/statements/formats/rbxtex/#syntax","title":"Syntax","text":"<p>rbxTeX introduces a few special commands on top of LaTeX.</p>"},{"location":"setters/statements/formats/rbxtex/#blocks","title":"Blocks","text":"<p>Blocks are the core of rbxTeX statement organization that are usually placed in the main file. In rbxTeX, instead of mixing your content with layout commands (like <code>\\section</code> or <code>\\begin{itemize}</code>), you define semantic blocks of content. The template then decides where and how to render these blocks.</p> <p>This separation of concerns allows you to:</p> <ul> <li>Change the look of your statement just by swapping the template, without touching the content.</li> <li>Reuse content easily (e.g., using the same block for both the full statement and a simplified statement).</li> </ul> statement.rbx.tex<pre><code>%- block input\nThe input consists of a single integer $N$.\n%- endblock\n\n%- block output\nThe output consists of a single integer $N$.\n%- endblock\n</code></pre> <p>You don't always need to define custom blocks, rbx works out-of-the-box with a few pre-defined blocks that adhere to the nomenclature and sectioning used by Polygon. See the default blocks section for more information.</p>"},{"location":"setters/statements/formats/rbxtex/#variables","title":"Variables","text":"<p>You can inject variables from <code>problem.rbx.yml</code> using the <code>\\VAR{&lt;variable-name&gt;}</code> syntax, or <code>\\VAR{vars.&lt;variable-name&gt;}</code> syntax when there's a conflict between built-in variables and your custom variables.</p> statement.rbx.texproblem.rbx.yml statement.rbx.tex<pre><code>%- block input\nThe input consists of a single integer $N$\n($\\VAR{N.min} \\le N \\le \\VAR{N.max}$).\n%- endblock\n</code></pre> problem.rbx.yml<pre><code>vars:\n  N:\n    min: 1\n    max: 100\n</code></pre>"},{"location":"setters/statements/formats/rbxtex/#comments","title":"Comments","text":"<p>You can use standard LaTeX comments <code>% ...</code>, but rbxTeX also supports block comments that are stripped before processing:</p> <pre><code>%# This is a comment that won't appear in the final LaTeX output\n</code></pre>"},{"location":"setters/statements/formats/rbxtex/#other-jinja2-features","title":"Other Jinja2 features","text":"<p>Take a look at Jinja2 website to see how other features work, such as conditionals, loops, etc. These are very powerful for templating.</p>"},{"location":"setters/statements/formats/rbxtex/#default-blocks","title":"Default blocks","text":"<p>The default template supports the following blocks:</p> Block Name Description <code>legend</code> The main problem description (the story and the task). <code>input</code> Description of the input format. <code>output</code> Description of the output format. <code>interaction</code> (Interactive problems only) Description of the interaction protocol. <code>notes</code> Any additional notes, hints, or explanations. <code>editorial</code> (Optional) Solution tutorial/editorial. <code>explanation_N</code> Explanation for the N-th sample (0-indexed). <p>These can be specified in the main file, and will be rendered in the default templates supported by rbx. It is a good practice to reuse these commonly defined blocks in your own templates as well, since they're semantically meaningful, and have a special treatment for Polygon packages.</p>"},{"location":"setters/statements/formats/rbxtex/#example","title":"Example","text":"<p>Here is a barebones example of a problem statement written in rbxTeX.</p> Main (statement.rbx.tex)Template (template.rbx.tex) <pre><code>%- block description\nAlice and Bob are playing a game with a sequence of integers.\nThe game consists of $K$ turns. In each turn, a player can...\n\nCalculate the final score of the winner.\n%- endblock\n\n%- block input\nThe first line contains two integers $N$ and $K$ ($\\VAR{N.min} \\le N, K \\le \\VAR{N.max}$) \u2014 the length of the sequence and the number of turns.\n\nThe second line contains $N$ integers $A_1, A_2, \\dots, A_N$ ($|A_i| \\le \\VAR{A.max}$).\n%- endblock\n\n%- block output\nOutput a single integer \u2014 the final score of the winner.\n%- endblock\n\n%- block notes\nIn the first sample, Alice chooses to...\n%- endblock\n\n%# We can explain specific samples using explanation blocks instead of notes if preferred.\n%- block explanation_0\nThis explanation corresponds to the first sample case.\n%- endblock\n</code></pre> <pre><code>\\documentclass{article}\n\\begin{document}\n\n\\section*{\\VAR{problem.short_name}. \\VAR{problem.title}}\n\n\\VAR{problem.blocks.description}\n\n\\subsection*{Input}\n\\VAR{problem.blocks.input}\n\n\\subsection*{Output}\n\\VAR{problem.blocks.output}\n\n\\subsection*{Samples}\n%- for sample in problem.samples\n\\subsection*{Sample \\VAR{loop.index}}\n\\begin{itemize}\n    \\item \\textbf{Input:} \\texttt{\\VAR{sample.inputPath.read_text()}}\n    \\item \\textbf{Output:} \\texttt{\\VAR{sample.outputPath.read_text()}}\n\\end{itemize}\n%- endfor\n\n%- if problem.blocks.notes is defined\n\\subsection*{Note}\n\\VAR{problem.blocks.notes}\n%- endif\n\n\\end{document}\n</code></pre>"},{"location":"setters/statements/formats/rbxtex/#learn-more-about-templating","title":"Learn more about templating","text":"<p>Learn more about creating your own template in our templating guide.</p>"},{"location":"setters/testset/","title":"Testset","text":"<p>The testset contains the tests that will be used to judge a problem, and can be decomposed into two components:</p> <ul> <li>Its skeleton: which are tests are samples? how other tests are grouped?</li> <li>How to generate tests for each group? Are the tests manually defined? Are they generated by a script?</li> </ul> <p>The test skeleton can be specified in the <code>problem.rbx.yml</code> file through the <code>testcases</code> field. This field is a list of <code>TestcaseGroup</code> objects, which describe a group of tests.</p> <p>Every test group should have an unique name. The name will be used to identify the group of tests when running rbx commands. There's a special reserved name, <code>samples</code>, which will be used to identify the group of samples.</p> <p>Below, an example of a very simple, ICPC-style test plan: just two groups, one secret, with tests hidden to the user and one with the samples.</p> problem.rbx.yml<pre><code># ...\ntestcases:\n  - name: 'samples'\n  - name: 'secret'\n</code></pre> <p>Of course, we have to add tests to these groups. The rest of this section will be devoted to this topic.</p> <p>There are 5 different ways of adding tests to group:</p> <p>Method</p> <p>Field</p> <p>Description</p> <p>List of testcases </p> <p><code>testcases</code> </p> <p>A list of <code>Testcase</code> objects that manually defines a few testcases.</p> <p>A testcase glob </p> <p><code>testcaseGlob</code> </p> <p>A path glob (string) that matches a set of testcase inputs (<code>.in</code> files).</p> <p>A list of generator calls </p> <p><code>generators</code> </p> <p>A list of <code>GeneratorCall</code> objects, which describe how to generate the tests for the group.</p> <p>A static generator script (aka a testplan)</p> <p><code>generatorScript</code> </p> <p>A path to a <code>.txt</code> file -- each of its lines is a generator call for a testcase.</p> <p>A dynamic generator script </p> <p><code>generatorScript</code> </p> <p>A path to a code or script that, when called, will generate a static generator script.</p> <p>In this section, we'll talk about the two most recommended approaches: using a testcase glob and using a generator script.</p>"},{"location":"setters/testset/#defining-the-testset","title":"Defining the testset","text":""},{"location":"setters/testset/#testcase-glob","title":"Testcase glob","text":"<p>Testcase globbing is the simplest way of adding manually defined tests to a group.</p> problem.rbx.yml<pre><code>testcases:\n  - name: 'samples'\n    testcaseGlob: 'tests/*.in'\n</code></pre> <p>In the example above, we define a group of samples which will contains tests matching the glob <code>tests/*.in</code>.</p> <p>Thus, if there are 3 files in the <code>tests</code> directory, <code>tests/01.in</code>, <code>tests/02.in</code> and <code>tests/03.in</code>, all these three will be added to the samples group.</p> <p>Test ordering</p> <p>The order of the tests will be the lexicographical order of the files.</p> <p>Be careful to not define tests as <code>1.in</code>, <code>2.in</code>, ..., <code>10.in</code> as this will lead to a test set where test <code>10.in</code> is executed before test <code>2.in</code>.</p> <p>Instead, define the tests as <code>01.in</code>, <code>02.in</code>, ..., <code>10.in</code>, using leading zeroes.</p>"},{"location":"setters/testset/#generator-script","title":"Generator script","text":"<p>If you haven't read the Generators section yet, you should read it before proceeding.</p> <p>A generator script is a script that will be used to generate tests for a group.</p> <p>It can be either a static script (in which case we also call it a testplan) or a dynamic script, and can be specified through the <code>generatorScript</code> field of a test group.</p>"},{"location":"setters/testset/#static-generator-script-aka-testplan","title":"Static generator script (aka testplan)","text":"<p>A static generator script (or a testplan) is a <code>.txt</code> file containing a list of line-separated generator calls.</p> <p>A generator call is simply a pair of <code>&lt;generator-name&gt; &lt;generator-args...&gt;</code>, where <code>&lt;generator-args&gt;</code> is a list of space-separated arguments to pass to the generator.</p> <p>Testplan can also have lines starting with a <code>#</code>, denoting this line is a comment and should be ignored, or even empty lines.</p> <p>Below there's an example of a testplan for a problem that has two generators, <code>random</code> and <code>small</code>, and how to define it in the <code>problem.rbx.yml</code> file.</p> testplan.txtproblem.rbx.yml <pre><code># Two random tests\nrandom 10 100\nrandom 10 1000\n\n# Two small tests\nsmall 50\nsmall 100\n</code></pre> <pre><code>testcases:\n  - name: 'samples'\n    testcaseGlob: 'tests/*.in'\n  - name: 'secret'\n    generatorScript:\n      path: 'testplan.txt'\n</code></pre>"},{"location":"setters/testset/#dynamic-generator-script","title":"Dynamic generator script","text":"<p>A dynamic generator script is a code that produces a testplan. Think of a code (in Python, or even in C++) that produces a testplan file as its output.</p> <p>Below, there's an example of a dynamic generator script for a problem that has a <code>random</code> generator.</p> testplan.pyproblem.rbx.yml <pre><code>for i in range(10):\n    print(f\"random {i}\")\n</code></pre> <pre><code>testcases:\n  - name: 'samples'\n    testcaseGlob: 'tests/*.in'\n  - name: 'secret'\n    generatorScript:\n      path: 'testplan.py'\n</code></pre> <p>The script spits a testplan with exactly 10 random tests, each one generated from a different argument between 0 and 9.</p>"},{"location":"setters/testset/#advanced-testplan-features","title":"Advanced testplan features","text":"<p>The static generator script (testplan) supports a few advanced features that can be useful in some scenarios.</p>"},{"location":"setters/testset/#manual-tests-input","title":"Manual tests (<code>@input</code>)","text":"<p>You can define manual tests directly in the testplan using the <code>@input</code> directive. This is useful when you want to add some edge cases that are hard to generate with a generator.</p> <p>You can specify the input content using a quoted string (single or double quotes) or a block of braced content.</p> <pre><code># Single line input (not raw)\n@input \"10 20\\n\"\n\n# Multi-line input (triple quotes, raw)\n@input \"\"\"10\n20\n30\"\"\"\n\n# Multi-line input (braces, raw, lines around the input are stripped)\n# Recommended approach.\n@input {\n10\n20\n30\n}\n</code></pre>"},{"location":"setters/testset/#copying-tests-copy","title":"Copying tests (<code>@copy</code>)","text":"<p>You can include existing test files in the testplan using the <code>@copy</code> directive. This is useful when you have some manual tests in a directory and you want to include them in the testplan.</p> <pre><code>@copy tests/manual/01.in\n@copy tests/manual/02.in\n</code></pre>"},{"location":"setters/testset/#grouping-tests-testgroup","title":"Grouping tests (<code>@testgroup</code>)","text":"<p>You can group tests using the <code>@testgroup</code> directive. This is useful when you want to add the specified tests only to testgroups that have this name. This is useful when different testgroups import the same testplan, but you want to create separate tests for each group.</p> <pre><code># This test will be part of any testgroup that imports this testplan.\nrandom 5\n\n@testgroup subtask1 {\n    # These tests will be part only of testgroups that have the name 'subtask1' and\n    # import this testplan.\n    random 10\n    random 20\n    @input \"5\"\n}\n\n@testgroup subtask2 {\n    # These tests will be part only of testgroups that have the name 'subtask2' and\n    # import this testplan.\n    random 100\n}\n</code></pre>"},{"location":"setters/testset/#what-about-the-outputs","title":"What about the outputs?","text":"<p>Until now, we've just generated the inputs of our testcases. What about the outputs? Where they come from?</p> <p>By default, rbx will use the model solution to generate the outputs of the testcases. This will be done when building the testset.</p> <p>The model solution is the topmost accepted solution in the <code>solutions</code> field of the <code>problem.rbx.yml</code> file.</p> <p>In some cases, though, it's useful to specify a different output than the one generated by the model solution. You can create an <code>.ans</code> file in the same directory as the <code>.in</code> file to specify the answer for the problem, and override the one provided by the model solution (if it exists).</p> <p>Notice this will affect both the testset itself, and the sample output rendered in the statement.</p> <p>There are times, though, where you only want to modify the statement output without affecting the testset (think of cases where the model solution output reveals too much about the intended solution). You can create an <code>.out</code> file in the same directory as the <code>.in</code> file to specify the output for the problem.</p> <p>You can only create manually crafted outputs for testcases you've defined manually (with a testcase glob, for instance).</p> <p>Let's look at the file tree above, and assume we have a testcase glob for samples such as <code>tests/*.in</code>.</p> <pre><code>- tests/\n  - 01.in\n  - 01.out  # This will override the output in the statement.\n  - 02.in\n  - 02.ans  # This will override the answer both in the statement AND in the testset.\n</code></pre>"},{"location":"setters/testset/#what-about-interactive-problems","title":"What about interactive problems?","text":"<p>For interactive problems, you can create a <code>.interaction</code> file in the very same path (and with the very same name) as the <code>.in</code> files you've manually defined.</p> <p>This file should contain the interaction between the solution and the interactor. Each line of interaction should start with either <code>&lt;</code> or <code>&gt;</code> to denote whether this was the output of the interactor or the output of the solution, respectively.</p> <pre><code>&lt; this is an interactor line\n&lt; followed by another line\n&gt; this is the solution\n</code></pre>"},{"location":"setters/testset/#building-the-testset","title":"Building the testset","text":"<p>The command below can be used to build the testset.</p> <pre><code>rbx build\n</code></pre> <p>This command will build the testset, using the generator scripts to generate the tests for each group. All tests will be written to the <code>build/tests</code> directory, which you can inspect manually in our file system.</p> <p>This command also accepts an extra verification flag (<code>-v</code>), which you can use to control whether validators will be run after generating the tests or not. The flag defaults to <code>-v0</code>, which means no verification will be done.</p> <pre><code>rbx build -v1\n</code></pre> <p>You can read more about the verification level flag in the verification section and about validation in the Validators section.</p>"},{"location":"setters/testset/#visualizing-the-testset","title":"Visualizing the testset","text":"<p>You can use the <code>rbx ui</code> to visualize the testcases that were built through the <code>rbx build</code> command.</p> <pre><code>rbx ui\n</code></pre> <p>This command will start an interactive UI in your terminal which you can use to browse the testset.</p>"},{"location":"setters/testset/generators/","title":"Generators","text":"<p>Generators are a testlib concept. They are programs that produce a testcase for a problem.</p> <p>In this section, we'll learn how to write a generator. If you already know how to do so, you can take a look at the Testset section to learn how to use them to produce your testset.</p>"},{"location":"setters/testset/generators/#generator-call","title":"Generator call","text":"<p>In rbx, generators are programs that produce a testplan from a given list of arguments.</p> <p>Let's say we have an executable <code>generator.exe</code>. Calling it should produce a testcase into the stdout.</p> <pre><code>./generator.exe 123 &gt; testcase\n</code></pre> <p>The program + all the arguments passed to it constitute what we call a generator call.</p> <p>In rbx, every generator should have a name. This name is used to identify the generator within a generator call for a better readability. These names are defined in the <code>problem.rbx.yml</code>.</p> problem.rbx.yml <pre><code>generators:\n    - name: \"generator\"\n      path: \"generator.cpp\"  \n</code></pre> <p>A valid generator call for the generator above would be <code>generator 123</code>.</p>"},{"location":"setters/testset/generators/#idempotency","title":"Idempotency","text":"<p>Generators should be idempotent. This means that two equal generator calls should always produce the same output.</p> <p>testlib <code>rnd</code> library is designed to be used in an idempotent way. In fact, the seed number for the <code>rnd</code> object's random number generator is a hash of the generator call.</p> <p>This means that using the <code>rnd</code> object in a generator as the only source of randomness will guarantee idempotency.</p> <p>Introducing randomness</p> <p>If you need to generate a testcase with the same set of parameters, but with a different seed, simply append a few random characters to the generator call.</p> <p>They will be ignored by your generator, but will be used to compute the seed for <code>rnd</code>, potentially producing a different testcase.</p> <pre><code>gen 100\ngen 100 abc\n</code></pre> <p>The two generator calls above might produce the different testcases for a generator expecting a single positional argument, as long as <code>rnd</code> is used by the generator to define its output.</p> <p>The trailing <code>abc</code> piece is just used to produce a different seed.</p>"},{"location":"setters/testset/generators/#writing-a-generator","title":"Writing a generator","text":"<p>You can read more about generators in the testlib documentation. It's very thorough and show a bunch of details about the APIs.</p> <pre><code>#include \"testlib.h\"\n\nint main(int argc, char* argv[]) {\n    registerGen(argc, argv, 1);\n\n    int N = opt&lt;int&gt;(1);\n    int MAX = opt&lt;int&gt;(\"MAX\");\n\n    for (int i = 0; i &lt; N; i++) {\n      if (i) cout &lt;&lt; \" \";\n      cout &lt;&lt; rnd.next(1, MAX);\n    }\n    cout &lt;&lt; endl;\n}\n</code></pre> <p>The generator above produces a testcase with <code>N</code> integers, each one between 1 and <code>MAX</code>, separated by spaces.</p> <p>testlib provides the <code>opt&lt;...&gt;()</code> function to parse command line arguments, in two variants:</p> <ul> <li><code>opt&lt;&gt;(int i)</code>: Parses a positional argument in the i-th position (1-indexed).</li> <li><code>opt&lt;&gt;(string name)</code>: Parses argument with the given name.</li> </ul> <p>In the case above, a valid generator call would be:</p> <pre><code>./generator.exe 10 --MAX_A=1000\n</code></pre> <p>To generate 10 random integers ranging from 1 to 1000.</p> <p>Random numbers can be generated using the <code>rnd</code> object. The <code>rnd.next()</code> function can be used to generate a random integer between two values, but there are also other overrides available for it.</p> <p>Take a look at the testlib documentation for more details, and also at the examples on their GitHub repository.</p> <p>Info</p> <p>You can always call your generator manually with:</p> <pre><code>rbx compile &lt;path-to-generator&gt;\nbuild/exe args...\n</code></pre> <p>You can also run solutions interactively against a generator call with:</p> <pre><code>rbx irun -g \"&lt;generator-name&gt; &lt;args...&gt;\"\n</code></pre> <p>Read more about <code>rbx irun</code> in the Running solutions section.</p>"},{"location":"setters/testset/generators/#jngen-the-jack-of-all-trades","title":"Jngen, the jack of all trades","text":"<p>rbx also has a built-in integration with jngen. This is a test generation library implemented by Ivan Smirnov.</p> <p>Jngen is a very powerful library that can generate all sorts of random objects: permutations, trees, graphs, strings, and more.</p> <p>It is a bit less mature and tested than testlib, but it's a great tool to have in your toolbox. Check it at its GitHub repository.</p> <p>To implement a Jngen-based generator, it suffices to include the <code>jngen.h</code> header</p> <p>Under development</p> <p>This section is under development. If you want to contribute, please send a PR to our repository.</p>"},{"location":"setters/testset/visualizers/","title":"Visualizers","text":"<p>Visualizers are small programs that transform a raw testcase input (and optionally its output) into a human-readable format, such as an image or an interactive HTML page.</p> <p>They are extremely useful for debugging geometry problems, game-theory problems, or any problem where the input is a complex structure that is hard to parse mentally.</p> <p>For instance, finding a bug in a Convex Hull algorithm is much easier if you can see the points and the hull, rather than staring at a list of coordinates.</p>"},{"location":"setters/testset/visualizers/#configuration","title":"Configuration","text":"<p>You can configure a global visualizer for your problem in the <code>problem.rbx.yml</code> file, specifically in the <code>visualizer</code> field.</p> problem.rbx.yml<pre><code># ...\nvisualizer:\n  path: visualizers/visualizer.py\n  extension: 'png'\n</code></pre> <p>The configuration above tells rbx that:</p> <ol> <li>The visualizer source code is located at <code>visualizers/visualizer.py</code>.</li> <li>The visualizer produces files with the <code>.png</code> extension.</li> </ol> <p>The visualizer script itself receives the following arguments:</p> <pre><code>./visualizer &lt;visualization-path&gt; &lt;input-file&gt; [&lt;output-file&gt;] [&lt;answer-file&gt;]\n</code></pre> <ul> <li><code>&lt;visualization-path&gt;</code>: The path where the visualizer should write the visualization.</li> <li><code>&lt;input-file&gt;</code>: The path to the input file of the testcase.</li> <li><code>&lt;output-file&gt;</code> (optional): The path to the output file of the testcase (participant's output).</li> <li><code>&lt;answer-file&gt;</code> (optional): The path to the answer file of the testcase (jury's output).</li> </ul>"},{"location":"setters/testset/visualizers/#input-vs-solution-visualizers","title":"Input vs Solution Visualizers","text":"<p>rbx distinguishes between two types of visualizers:</p> <ul> <li>Input visualizer: Used to visualize a testcase -- and only the testcase. It receives only the <code>&lt;input-file&gt;</code> and the <code>&lt;output-file&gt;</code> is set to the model solution's output, if it is available.</li> <li>Solution visualizer: Used to visualize the output of a solution in the context of a given testcase. Besides the <code>&lt;input-file&gt;</code>, it also receives an <code>&lt;output-file&gt;</code> which is the output of a solution for a testcase. Besides that, it can also receive an <code>&lt;answer-file&gt;</code>, pointing to the expected answer for this test, if it is available.</li> </ul> <p>Let's use as an example a convex hull problem. Think of a input visualizer as being useful for seeing the points in the plane, as well as the expected convex hull polygon. Solution visualizers can then be used to render the polygon produced by a specific solution. </p> <p>They're quite similar, but it's useful to allow them to be configured separately. By default, the <code>visualizer</code> field configures both input and solution visualizers. If you want to configure them separately, or if your solution visualizer is different from the input visualizer, you can use the <code>solutionVisualizer</code> field.</p> problem.rbx.yml<pre><code>solutionVisualizer:\n  path: 'visualizers/solution_visualizer.py'\n  extension: 'png'\n</code></pre>"},{"location":"setters/testset/visualizers/#answer-sources-answer_from","title":"Answer sources (<code>answer_from</code>)","text":"<p>Sometimes, the raw output of the model solution is not enough for the visualizer.</p> <p>For instance, in a convex hull problem, you might be asked to print its area -- a single number. This number can't really be used to render anything useful for debugging. The convex hull points, on the other hand, are much more useful.</p> <p>You can modify your model solution to output the trace to <code>stderr</code>, and then tell the visualizer to read the answer from <code>stderr</code>:</p> problem.rbx.yml<pre><code>visualizer:\n  path: 'visualizers/visualizer.py'\n  extension: 'png'\n  answer_from: 'stderr'\n</code></pre> <p>Warning</p> <p>Be careful when using <code>stderr</code> to output the visualizable output. If you print too much into the <code>stderr</code>, your program might slow down. In these cases, prefer the solution below.</p> <p>Alternatively, you can specify a separate program that generates the answer for the visualizer:</p> problem.rbx.yml<pre><code>visualizer:\n  path: 'visualizers/visualizer.py'\n  extension: 'png'\n  answer_from:\n    path: 'visualizers/generate_answer.cpp'\n    stderr: false  # Set to true if your program outputs into stderr of stdout\n</code></pre>"},{"location":"setters/testset/visualizers/#writing-a-visualizer","title":"Writing a visualizer","text":"<p>Visualizers can be written in any language supported by rbx.</p> <p>For Python, a simple visualizer structure would look like this:</p> <pre><code>import sys\n\ntry:\n    import matplotlib.pyplot as plt\nexcept ImportError:\n    print(\"Matplotlib is not installed. Please install it with: pip install matplotlib\")\n    sys.exit(1)\n\ndest_path, input_path = sys.argv[1], sys.argv[2]\n\n# Read points (x, y) from input file\nX, Y = [], []\nwith open(input_path) as f:\n    # Skip header (usually N) if necessary, or just read everything\n    for line in f:\n        parts = line.split()\n        if len(parts) &gt;= 2:\n            X.append(float(parts[0]))\n            Y.append(float(parts[1]))\n\n# Plot\nplt.scatter(X, Y)\nplt.title(\"Points Visualization\")\n\n# Save to destination\nplt.savefig(dest_path)\n</code></pre> <p>Tip</p> <p>In the LLM era, visualizers are particularly easy to be generated.</p> <p>Tip</p> <p>Visualizers often require external libraries to function properly. Make sure that you fail gracefully if a required library is not available. Other setter facing this issue will be able to quickly see a dependency is missing and fix it.</p>"},{"location":"setters/testset/visualizers/#usage","title":"Usage","text":""},{"location":"setters/testset/visualizers/#in-rbx-ui","title":"In <code>rbx ui</code>","text":"<p>The most common way to use visualizers is through the Test Explorer UI, accessible via <code>rbx ui</code>.</p> <ul> <li>Press v to run the input visualizer for the selected testcase.</li> <li>Press Shift+v (or V) to run the solution visualizer for the selected testcase (requires a solution to be selected).</li> </ul> <p>The visualization will be generated and automatically opened in the program associated with the visualizer's output extension. For instance, if the visualizer produces a <code>.png</code> file, it will be opened in your default image viewer.</p>"},{"location":"setters/testset/visualizers/#interactive-mode","title":"Interactive mode","text":"<p>When run from <code>rbx ui</code>, a visualizer takes an additional option <code>-i</code>, that tells it's being run in a interactive flow. This is useful for visualizers that want to open an interactive window to show the visualization (for instance, where the user can zoom).</p> <p>A visualizer can notify rbx that it was run in interactive mode and produced no file by exitting with code 42. In this case, rbx will not try to open any file, and rather just execute the program and wait to act interactively with the user.</p>"},{"location":"setters/testset/visualizers/#in-rbx-build","title":"In <code>rbx build</code>","text":"<p>You can also batch-generate visualizations for all testcases during the build process:</p> <pre><code>rbx build --visualize\n</code></pre> <p>This will generate input visualizations for all testcases and store them in the build directory, typically under <code>build/tests/&lt;testgroup&gt;/visualization</code>.</p>"},{"location":"setters/verification/","title":"Verification","text":"<p>rbx provides a range of solutions to improve the quality and correctness of your testset and the testlib assets you use. You can see a quick summary of the features in the table below, and then read more about each one in the following sections.</p> <p>Feature</p> <p>Description</p> <p>Validators </p> <p>Check whether your test inputs are conforming the to the format you expect.</p> <p>Unit tests </p> <p>Check whether your checker and/or validator are behaving as expected against manually defined inputs.</p> <p>Stress testing </p> <p>Check whether your validators, checkers and correct solutions are behaving as expected against randomly generated inputs.</p>"},{"location":"setters/verification/#verification-level","title":"Verification Level","text":"<p>rbx also has the concept of a verification level. This is a way to specify how strict the verification should be when building your testset and running solutions.</p> <p>The verification level will usually be specified along your rbx command.</p> <pre><code>rbx build -v{0,1}  # defaults to 1\nrbx run -v{0,1,2,3,4}  # defaults to 4\nrbx package -v{0,1,2,3,4}  # defaults to 4\n</code></pre> <p>The verification level is a non-negative incremental enum, which means that the level <code>N+1</code> will include all the checks of level <code>N</code>, plus what is specified in the table below:</p> Level Description <code>0</code> / <code>NONE</code> No verification. <code>1</code> / <code>VALIDATE</code> Run validators on the generated testset. <code>2</code> / <code>FAST_SOLUTIONS</code> Run all non-TLE solutions. <code>3</code> / <code>ALL_SOLUTIONS</code> Run all solutions, including TLE. <code>4</code> / <code>FULL</code> Run solutions with twice the TL to check if TLE solutions still pass. <p>Setting a larger value is usually the recommended approach to ensure all your expectations are being met.</p> <p>Setting a smaller value is usually useful when you want to run the commands faster, and you are sure that the checks you are running are not being violated.</p>"},{"location":"setters/verification/unit-tests/","title":"Unit tests","text":"<p>rbx provides a way for you to unit test your validators and your checker.</p> <p>You can define unit tests in the <code>unitTests</code> field in your <code>problem.rbx.yml</code> file.</p> problem.rbx.yml<pre><code>unitTests:\n  validator:\n    - glob: unit/validator/valid_*.in\n      outcome: VALID\n    - glob: unit/validator/invalid_*.in\n      outcome: INVALID\n  checker:\n    - glob: unit/checker/ac*\n      outcome: ACCEPTED\n    - glob: unit/checker/wa*\n      outcome: WRONG_ANSWER\n</code></pre> <p>The unit tests can be run with the following command:</p> <pre><code>rbx unit\n</code></pre> <p>In the next sections, we'll go through what each of these fields mean, and how to define the actual test inputs.</p>"},{"location":"setters/verification/unit-tests/#testing-validators","title":"Testing validators","text":"<p>Let's say we have a validator that checks if the input contains a connected graph in the format.</p> <pre><code>N M\nu_1 v_1\nu_2 v_2\n...\nu_M v_M\n</code></pre> <p>We'll omit the actual validator code here for simplicity, but you can see an example at the Validators section.</p> <p>We can create positive (valid) and negative (invalid) unit tests for the problem by defining the following in our <code>problem.rbx.yml</code> file:</p> problem.rbx.yml<pre><code>unitTests:\n  validator:\n    - glob: unit/validator/valid_*.in\n      outcome: VALID\n    - glob: unit/validator/invalid_*.in\n      outcome: INVALID\n</code></pre> <p>Now, every input file matching the glob <code>unit/validator/valid_*.in</code> will be considered a valid input and every input file matching the glob <code>unit/validator/invalid_*.in</code> will be considered an invalid input.</p> <p>To check the tests are working properly, let's create the following files in the <code>unit/validator</code> directory:</p> valid_CONNECTED.ininvalid_NOT_CONNECTED.ininvalid_VERTEX_OUT_OF_BOUNDS.in unit/validator/valid_CONNECTED.in<pre><code>3 3\n1 2\n2 3\n1 3\n</code></pre> unit/validator/invalid_NOT_CONNECTED.in<pre><code>3 1\n1 2\n</code></pre> unit/validator/invalid_VERTEX_OUT_OF_BOUNDS.in<pre><code>3 3\n1 2\n2 3\n2 4\n</code></pre> <p>Now, when you run <code>rbx unit</code>, you should see all the three tests passing if the validator is implemented correctly, and we should see failures if the validator does not behave as expected.</p>"},{"location":"setters/verification/unit-tests/#testing-checkers","title":"Testing checkers","text":"<p>Now, let's say we have a checker that checks whether the output of the participant is a path between two vertices 1 and <code>N</code> in a graph with <code>N</code> vertices and <code>M</code> edges.</p> <p>Let's say we have a checker that expects a number <code>K</code> in the first line, and then <code>K</code> numbers on the second line, which are the vertices on the path.</p> <p>The checker code is omitted for simplicity. You can check the complete code in the Checkers section.</p> <p>We can create unit tests for this checker by defining the following in our <code>problem.rbx.yml</code> file:</p> problem.rbx.yml<pre><code>unitTests:\n  checker:\n    - glob: unit/checker/ac*\n      outcome: ACCEPTED\n    - glob: unit/checker/wa*\n      outcome: WRONG_ANSWER\n</code></pre> <p>These will define the general skeleton of our checker unit tests. Remember that checkers are a bit more complex than validators, and accept three different files as input:</p> <ul> <li><code>&lt;file&gt;.in</code>: The input file for this testcase.</li> <li><code>&lt;file&gt;.out</code>: The output file of the participant for this testcase.</li> <li><code>&lt;file&gt;.ans</code>: The answer file (output of the model solution) for this testcase.</li> </ul> <p>The glob pattern <code>unit/checker/ac*</code> will match any file that starts with <code>ac</code> in its name, and ends with <code>.in</code>, <code>.out</code>, or <code>.ans</code>. Then, these three files will be passed to the checker for testing. If some of them are missing, the checker will simply receive an empty file in their place.</p> <p>Let's say we have the following files in the <code>unit/checker</code> directory:</p> ac_VALID_PATH.inac_VALID_PATH.out unit/checker/ac_VALID_PATH.in<pre><code>3 2\n1 2\n2 3\n</code></pre> unit/checker/ac_VALID_PATH.out<pre><code>3\n1 2 3\n</code></pre> <p>Here, we don't even set a <code>.ans</code> file, because the aforementioned checker will simply ignore it anyways. If you run <code>rbx unit</code>, this test should pass, because the checker will indeed return accepted for this output.</p> <p>Let's test now that the checker fails when the output is not a valid path on the output.</p> wa_NON_EXISTING_EDGE.inwa_NON_EXISTING_EDGE.out unit/checker/wa_NON_EXISTING_EDGE.in<pre><code>3 2\n1 3\n1 2\n</code></pre> unit/checker/wa_NON_EXISTING_EDGE.out<pre><code>3\n1 2 3\n</code></pre> <p>If you run <code>rbx unit</code>, this test should also pass, because the checker will indeed return wrong answer for this output, since the participant's output uses an edge that does not exist in the input.</p> <p>In problems where the model solution output is consumed by the checker, we can additionally define the <code>.ans</code> file as well, and the checker will consume it.</p>"},{"location":"setters/verification/unit-tests/#testing-extra-validators","title":"Testing extra validators","text":"<p>You can test extra validators in the same way as the main validator by simply specifying the validator that should be testedin the <code>unitTests</code> field. By default, the main validator will be tested.</p> problem.rbx.yml<pre><code>unitTests:\n  validator:\n    - glob: unit/validator/valid_*.in\n      outcome: VALID\n    - glob: unit/validator/invalid_*.in\n      outcome: INVALID\n    - glob: unit/extra-validator/valid_*.in\n      outcome: VALID\n      validator: extra-validator.cpp\n    - glob: unit/extra-validator/invalid_*.in\n      outcome: INVALID\n      validator: extra-validator.cpp\n</code></pre>"},{"location":"setters/verification/unit-tests/#using-test-plans","title":"Using test plans","text":"<p>While defining tests using glob patterns is simple and works well for file-based tests, it can be cumbersome if you have many small unit tests and don't want to create a separate file for each one. For this use case, rbx supports test plans.</p> <p>A test plan is a single file that contains multiple unit tests defined using a special syntax. You can define test plans in your <code>problem.rbx.yml</code> file:</p> problem.rbx.yml<pre><code>unitTests:\n  validator:\n    - testplan: unit/validator/tests.txt\n  checker:\n    - testplan: unit/checker/tests.txt\n</code></pre>"},{"location":"setters/verification/unit-tests/#syntax-reference","title":"Syntax reference","text":"<p>Test plans use a simple DSL to define tests. You can define tests using the <code>@test</code> block or the simplified <code>@input</code> syntax.</p>"},{"location":"setters/verification/unit-tests/#the-test-block","title":"The <code>@test</code> block","text":"<p>The <code>@test</code> block is the most general way to define a test. It allows you to specify the input, output, and answer for a test case.</p> <pre><code>@test name EXPECTATION {\n    @input {\n        ... input content ...\n    }\n    @output {\n        ... output content ...\n    }\n    @answer {\n        ... answer content ...\n    }\n}\n</code></pre> <ul> <li><code>name</code> (optional): The name of the test case.</li> <li><code>EXPECTATION</code>: The expected outcome (e.g., <code>VALID</code>, <code>INVALID</code> for validators; <code>ACCEPTED</code>, <code>WRONG_ANSWER</code>, etc. for checkers).</li> </ul>"},{"location":"setters/verification/unit-tests/#simplified-input-syntax","title":"Simplified <code>@input</code> syntax","text":"<p>For simple tests where you only need to specify the input (common in validator tests), you can use the simplified <code>@input</code> syntax:</p> <pre><code>@input name EXPECTATION {\n    ... input content ...\n}\n</code></pre> <p>or for one-liners:</p> <pre><code>@input name EXPECTATION \"input content\"\n</code></pre>"},{"location":"setters/verification/unit-tests/#when-to-use-what","title":"When to use what?","text":"<ul> <li>Use the simplified <code>@input</code> syntax when you only need to provide the input file. This is most common for validator tests, where you only care about whether the input is valid or not.</li> <li>Use the <code>@test</code> block when you need to specify more than just the input, such as the <code>output</code> (participant's output) or <code>answer</code> (model answer), or when you prefer a more structured format for complex multi-line inputs. This is often needed for checker tests.</li> </ul>"},{"location":"setters/verification/unit-tests/#examples","title":"Examples","text":"Validator test planChecker test plan unit/validator/tests.txt<pre><code>// You can use comments starting with // or #\n\n@input valid_1 VALID {\n    3 3\n    1 2\n    2 3\n    3 1\n}\n\n@input invalid_n_negative INVALID \"-1 3\"\n\n@input INVALID {\n    3 1\n    1 2\n}\n</code></pre> unit/checker/tests.txt<pre><code>@test valid_path ACCEPTED {\n    @input {\n        3 2\n        1 2\n        2 3\n    }\n    @output {\n        3\n        1 2 3\n    }\n}\n\n@test wrong_path WRONG_ANSWER {\n    @input {\n        3 2\n        1 2\n        2 3\n    }\n    @output {\n        2\n        1 2\n    }\n}\n</code></pre>"},{"location":"setters/verification/validators/","title":"Validators","text":"<p>Validator is a concept introduced by testlib to verify whether the tests you generate for a problem are in the format you really expect.</p> <p>Think of the frustrating scenarios where you've written in the statement that the graph should be connected, or a tree, or a DAG, but there was a test in your testset that contradicted this. Even experienced setters make these mistakes, and it's important to have extra guards to catch them.</p> <p>Similar to Codeforces, rbx offers built-in support for testlib validators (and also encourages you to use it), but also provides the flexibility for you to write your own.</p>"},{"location":"setters/verification/validators/#motivational-problem","title":"Motivational problem","text":"<p>For the next sections, let's assume we have a problem that asks you to find a path between two vertices 1 and <code>N</code> in a connected graph with <code>N</code> vertices numbered from 1 to <code>N</code>, where <code>N</code> is between 2 and 1000 and <code>M</code> is between 1 and <code>N * (N - 1) / 2</code>.</p> <p>Let's assume the input is given like this:</p> <pre><code>3 2\n1 2\n2 3\n</code></pre> <p>In the first line, we have the number of vertices <code>N</code> and the number of edges <code>M</code>, separated by a single space.</p> <p>In the next <code>M</code> lines, we have the edges of the graph, represented by two integers <code>u</code> and <code>v</code> separated by a single space, indicating that there is an undirected edge between vertex <code>u</code> and vertex <code>v</code>. Then, the file ends.</p> <p>Let's write a validator to verify that our testset does not violate these constraints.</p>"},{"location":"setters/verification/validators/#using-testlib-validators","title":"Using testlib validators","text":"<p>You can read more about testlib validators in the Codeforces documentation.</p> <p>To use a testlib validator, you need to specify the path to the validator in the <code>validator</code> field. testlib validators are always written in C++ and should include the <code>testlib.h</code> header. rbx treats this header especially, and will automatically place it along your validator when compiling it.</p> problem.rbx.yml<pre><code>validator:\n  path: 'validator.cpp'\n</code></pre> <p>Let's write a simple validator that checks the input format above.</p> validator.cpp<pre><code>#include \"testlib.h\"\n\nint main(int argc, char *argv[]) {\n  registerValidation(argc, argv);\n\n  int n = inf.readInt(2, 1000, \"N\"); // (1)!\n  inf.readSpace();\n  int m = inf.readInt(1, n * (n - 1) / 2, \"M\"); // (2)!\n  inf.readEoln();\n\n  // Read all the M edges of the graph.\n  for (int i = 0; i &lt; m; i++) {\n    int u = inf.readInt(1, n, \"u\");\n    inf.readSpace();\n    int v = inf.readInt(1, n, \"v\");\n    inf.readEoln();\n  }\n\n  inf.readEof(); // (3)!\n}\n</code></pre> <ol> <li> <p>We read the number of vertices <code>N</code> and check that it is an integer between 2 and 1000.     Notice we also set a variable name <code>N</code>.</p> <p>This is used for testlib to print useful error messages when an issue is found.</p> </li> <li> <p>We read the number of edges <code>M</code> and check that it is between 1 and <code>N * (N - 1) / 2</code>.</p> <p>Notice how we re-use the variable <code>n</code> we read before.</p> </li> <li> <p>We read the end of the file.</p> </li> </ol> <p>Notice we're super strict about spaces, end-of-lines and end-of-file here. That's the purpose of the validator component.</p> <p>Of course, we still have to check that the graph is connected, but let's do this in a minute.</p> <p>Let's first talk about variables. As explained in the Variables section, we can use variables to refer to constraints in the input. </p> <p>At the moment, we're hard coding the lower and upper bounds for <code>N</code> in the validator. If we change the problem statement to, let's say, allow <code>N</code> between 3 and 500 instead, we'd have to remember to modify the validator. This is a dangerous practice, as it's super easy to forget to do so.</p> <p>Let's do the following modifications to our problem to make it safer:</p> validator.cppproblem.rbx.yml <pre><code>#include \"testlib.h\"\n#include \"rbx.h\"\n\nint main(int argc, char *argv[]) {\n  registerValidation(argc, argv);\n  int MIN_N = getVar&lt;int&gt;(\"N.min\");\n  int MAX_N = getVar&lt;int&gt;(\"N.max\");\n\n  int n = inf.readInt(MIN_N, MAX_N, \"N\");\n  // ...rest of the validator...\n}\n</code></pre> <pre><code># ...rest of the problem.rbx.yml...\nvars:\n  N:\n    min: 2\n    max: 1000\n</code></pre> <p>rbx will automatically generate an <code>rbx.h</code> header file for you, which will include the variables you defined in your <code>problem.rbx.yml</code> file, that you can access in your validator with the <code>getVar&lt;&gt;()</code> function.</p> <p>To read more about variables, check the Variables section.</p> <p>Now, let's finally check that the graph is connected.</p> validator.cpp<pre><code>#include \"testlib.h\"\n#include \"rbx.h\"\n\nbool checkConnected(const vector&lt;vector&lt;int&gt;&gt; &amp;adj, int n) {\n  vector&lt;bool&gt; visited(n + 1);\n  queue&lt;int&gt; q;\n  q.push(1);\n  visited[1] = true;\n\n  while (!q.empty()) {\n    int u = q.front();\n    q.pop();\n\n    for (int v : adj[u]) {\n      if (!visited[v]) {\n        visited[v] = true;\n        q.push(v);\n      }\n    }\n  }\n\n  for (int i = 1; i &lt;= n; i++) {\n    if (!visited[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nint main(int argc, char *argv[]) {\n  registerValidation(argc, argv);\n  int MIN_N = getVar&lt;int&gt;(\"N.min\");\n  int MAX_N = getVar&lt;int&gt;(\"N.max\");\n\n  int n = inf.readInt(MIN_N, MAX_N, \"N\");\n  inf.readSpace();\n  int m = inf.readInt(1, n * (n - 1) / 2, \"M\");\n  inf.readEoln();\n\n  vector&lt;vector&lt;int&gt;&gt; adj(n + 1);\n\n  // Read all the M edges of the graph.\n  for (int i = 0; i &lt; m; i++) {\n    int u = inf.readInt(1, n, \"u\");\n    inf.readSpace();\n    int v = inf.readInt(1, n, \"v\");\n    inf.readEoln();\n\n    adj[u].push_back(v);\n    adj[v].push_back(u);\n  }\n\n  ensuref(checkConnected(adj, n), \"The graph is not connected.\");\n\n  inf.readEof();\n}\n</code></pre> <p>Tip</p> <p>You can always manually call a validator on a custom input with <code>rbx validate</code>.</p>"},{"location":"setters/verification/validators/#using-custom-validators","title":"Using custom validators","text":"<p>Let's say you want to build a custom Python3 validator. You can do that similarly by specifying a Python validator in the <code>validator</code> field.</p> problem.rbx.ymlvalidator.py <pre><code>validator:\n  path: 'validator.py'\n</code></pre> <pre><code># ... read the input ...\n\ndef check_connected(adj, n):\n    # ... check if the graph is connected ...\n\nassert check_connected(adj, n), \"The graph is not connected.\"\n\n# ...\n</code></pre> <p>Warning</p> <p>We strongly recommend using testlib validators.</p> <p>They're not only easier to write, but also provides a set of tested utilites to read and stricly check parts of the input, something you would've to do manually otherwise.</p>"},{"location":"setters/verification/validators/#defining-additional-validators","title":"Defining additional validators","text":"<p>rbx provides a couple ways of defining additional validators for a problem or testset.</p> <p>The first one is by using the <code>extraValidators</code> field in the <code>problem.rbx.yml</code> file.</p> <p>This allows you to, for instance, define validators that check for different properties of the input separately.</p> problem.rbx.yml<pre><code>validator:\n  path: 'validator.cpp'\nextraValidators:\n  - path: 'connected-validator.cpp'\n  - path: 'bipartite-validator.cpp'\n</code></pre> <p>Or define validators that check for common properties of the input file that you'd rather keep off of the main validator.</p> problem.rbx.yml<pre><code>validator:\n  path: 'validator.cpp'\nextraValidators:\n  - path: 'only-printable-ascii.py'\n  - path: 'no-tabs.py'\n  - path: 'no-consecutive-spaces.py'\n</code></pre> <p>Another way of additional validators it to specify validators (or extra validators) for a specific test group in your problem.</p> <p>This is often useful for problems that have multiple subtasks with different constraints, but can also be useful for ICPC-style contests where you use the grouping feature to separate tests you've generated with a specific purpose in mind.</p> <p>Considering the problem above one more time, let's say we have a specific testplan focused on tests that contain a straight path from 1 to <code>N</code>, because we know that this is the largest solution a participant can get. We might want to have a validator to ensure tests coming from this testplan really have this property.</p> problem.rbx.yml<pre><code># ... rest of the problem.rbx.yml ...\nvalidator:\n  path: 'validator.cpp'\ntestcases:\n  - name: samples\n    testcaseGlob: manual_tests/samples/*.in\n  - name: general\n    generatorScript:\n      path: testplan/general.txt\n  - name: straight\n    generatorScript:\n      path: testplan/straight.txt\n    extraValidators:\n      - path: 'straight-validator.cpp'\n</code></pre>"}]}